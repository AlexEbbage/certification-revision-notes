<div>
    <h1 id="chapter-4">Chapter 4: Implement Data Access</h1>
    <p>Skills covered in this chapter are:</p>
    <ul>
        <li><a href="#skill-4-1">Skill 4.1: Perform I/O Operations</a></li>
        <li><a href="#skill-4-2">Skill 4.2: Consume Data</a></li>
        <li><a href="#skill-4-3">Skill 4.3: Query and Manipulate Data and Objects by Using LINQ</a></li>
        <li><a href="#skill-4-4">Skill 4.4: Serialize and Deserialize Data by Using Binary and Custom Serialization, and
                XML, JSON and Data Contract Serializer</a></li>
        <li><a href="#skill-4-5">Skill 4.5: Store Data in and Retrieve Data from Collections</a></li>
        <li><a href="#qa-4">Thought Experiments</a></li>
    </ul>
    <div>
        <h2 id="skill-4-1">Skill 4.1: Perform I/O Operations</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Read and write files and streams</li>
            <li>Read and write from the network by using classes in the System.NET namespace</li>
            <li>Implement asynchronous I/O operations</li>
        </ul>
        <div>
            <h3>Read and Write Files and Streams</h3>
            <ul>
                <li>A stream is a software object that represents a stream of data.</li>
                <li>The .NET framework provides a Stream class that serves as the parent type to a range of classes that
                    can be used to read and write data.</li>
                <li>There are 3 ways that a program can interact with a stream:
                    <ul>
                        <li>Write a sequence of bytes to a stream</li>
                        <li>Read a sequence of bytes from a stream</li>
                        <li>Position the "file pointer" in a stream</li>
                    </ul>
                </li>
                <li>File Pointer: Position in the stream where the next read or write operation will take place.</li>
                <li>Seek Method: Provided by the stream to set the file pointer position.</li>
                <li>The Stream class is abstract and serves as a template for streams that connect to actual storage
                    resources.</li>
                <li>Any object that can work with a Stream can work with any objects that behave like a stream.</li>
                <li>System.IO.Stream is the base type to 5 types: BufferedStream, FileStream, MemoryStream, PipeStream,
                    and NetworkStream.</li>
                <li>Each base class contains the Stream behaviours that allow data to be transferred. However, each type
                    is created differently. <i>e.g. A FileStream must specify the path to the file, and a Memory Stream
                        must specify the buffer in memory.</i></li>
            </ul>
            <h4>Use FileStream</h4>
            <ul>
                <li>The FileStream object provides a stream instance connected to a file which converts calls into the
                    stream into commands for the filesystem on the computer running the program.</li>
                <li>The file system provides the interface to the physical device performing the data storage for the
                    computer.</li>
                <li>A call to the stream object's Write method will generate a request to the file system to write the
                    data to the storage.</li>
                <li>
                    <code>
                        static void Main(string[] args){
                        // Writing to a files
                        FileStream outputStream = new FileStream("Output.txt", FileMode.OpenOrCreate, FileAccess.Write);
                        string outputMessageString = "Hello world";
                        byte[] outputMessageBytes = Encoding.UTF8.GetBytes(outputMessageString);
                        outputStream.Write(outputMessageBytes, 0, outputMessageBytes.Length);
                        outputStream.Close();

                        // Reading from files
                        FileStream inputStream = new FileStream("Output.txt", FileMode.Open, FileAccess.Read);
                        long fileLength = inputStream.Length;
                        byte[] readBytes = new byte[fileLength];
                        inputStream.Read(readBytes, 0, (int)fileLength);
                        string readString = Encoding.UTF8.GetString(readBytes);
                        inputStream.Close();
                        Console.WriteLine("Read message: {0}", readString);

                        Console.ReadKey();
                        }
                    </code>
                </li>
            </ul>
            <h4>Control File Use with FileMode and FileAccess</h4>
            <ul>
                <li>A stream can be associated with reading, writing, or updating a file.</li>
                <li>The base Stream class provides properties that a program can use to determine the abilities of a
                    given stream instance.</li>
                <li>The FileMode enumeration is used in the constructor of a FileStream to indicate how the file is to
                    be opened:
                    <ul>
                        <li><b>FileMode.Append:</b> Open a file for appending to the end. If the file exists, move the
                            seek position to the end of this file. If not, create it. Only useable if the file is being
                            opened for writing.</li>
                        <li><b>FileMode.Create:</b> Create a file for writing. If it exists, it is overwritten.</li>
                        <li><b>FileMode.CreateNew:</b> Create a file for writing. If it exists, an exception is thrown.
                        </li>
                        <li><b>FileMode.Open:</b> Open an existing file. If it doesn't exist, an exception is thrown.
                            The mode can be used for reading or writing.</li>
                        <li><b>FileMode.OpenOrCreate:</b> Open a file for reading or writing. If it doesn't exist, an
                            empty file is created. The mode can be used for reading or writing.</li>
                        <li><b>FileMode.Truncate:</b> Open a file for writing and remove any existing contents.</li>
                    </ul>
                </li>
                <li>The FileAccess enumeration is used to indicate how the file is to be used:
                    <ul>
                        <li><b>FileMode.Read:</b> Open a file for writing.</li>
                        <li><b>FileMode.ReadWrite:</b> Open a file for reading or writing.</li>
                        <li><b>FileMode.Write:</b> Open a file for writing.</li>
                    </ul>
                </li>
            </ul>
            <h4>Convert Text to Binary Data with Unicode</h4>
            <ul>
                <li>The System.Text namespace has the Encoding class which has a property, UTF8, which provides methods
                    that will encode and decode Unicode text.</li>
                <li>Unicode is a mapping of character symbols to number vaules. The UTF8 encoding maps Unicode
                    charaacters onto 8-bit calues that can be stored in arrays of bytes.</li>
                <li>Most text files are encoded using UTF8.</li>
                <li>The Encoding class also provides support for other encoding standaring including UTF32 and ASCII.
                </li>
                <li>The GetBytes encoding method takes a C# string and returns the bytes that represent that string in
                    the specified encoding.</li>
                <li>The GetString decoding method takes an array of bytes and returns the string that a buffer full of
                    bytes represents.</li>
            </ul>
            <h4>IDispose and FileStream Objects</h4>
            <ul>
                <li>The stream class implements IDisposable, meaning objects derived from the Stream type must also
                    implement the interface.</li>
                <li>This also means the using construction can be used to ensure that files are closed when they are no
                    longer required.</li>
            </ul>
            <h4>Work with Text Files</h4>
            <ul>
                <li>The filesystem makes no particular distinciton between text files and binary files.</li>
                <li>The TextWriter and TextReader classes are abstract stream classes which make it much easier to work
                    with text, and define a set of methods that can be used with text.</li>
                <li>The StreamWriter class extends the TextWriter class to allow us to write text to streams.
                    <code>
                        using (StreamWriter writeStream = new StreamWriter("Output.txt")){
                        writeStream.Write("Hello world!");
                        }

                        using (StreamReader readStream = new StreamReader("Output.txt")){
                        string readString = readStream.ReadToEnd();
                        Console.WriteLine("Text read: {0}", readString);
                        }
                    </code>
                </li>
            </ul>
            <h4>Chain Stream Together</h4>
            <ul>
                <li>The Stream class has a constructor that will accept another stream as a paramter, allowing the
                    creation of chains of streams.</li>
                <li>This example shhows how to use the GZipStream from the System.IO.Compression namespace in a chain of
                    streams that will save and load compressed text:
                    <code>
                        using (FileStream writeFile = new FileStream("CompressedText.zip", FileMode.OpenOrCreate,
                        FileAccess.Write))
                        {
                        using (GZipStream writeFileZip = new GZipStream(writeFile, CompressionMode.Compress))
                        {
                        using (StreamWriter writeFileText = new StreamWriter(writeFileZip))
                        {
                        writeFileText.Write("Hello world!");
                        }
                        }
                        }

                        using (FileStream readFile = new FileStream("CompressedText.zip", FileMode.Open,
                        FileAccess.Read))
                        {
                        using (GZipStream readFileZip = new GZipStream(readFile, CompressionMode.Decompress))
                        {
                        using (StreamReader readFileText = new StreamReader(readFileZip))
                        {
                        string readString = readFileText.ReadToEnd();
                        Console.WriteLine("Text read: {0}", readString);
                        }
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Use the File Class</h4>
            <ul>
                <li>The Files class is a helper class that makes it easier to work with files.</li>
                <li>It contains a set of static methods that can be used to append text to a file, copy a file, create a
                    file, delete a fil, move a file, open a file, read a file, and manage file security.</li>
            </ul>
            <h4>Handle Stream Exceptions</h4>
            <ul>
                <li>When creating applications that use streams you need to ensure that your code can deal with any
                    exceptions that might be thrown by a stream.</li>
                <li>An application may try to open a file that doesn't exist, or a given storage device may become full
                    during writing.</li>
                <li>It is possible that threads in multi-threaded applications can "fight" over files. If one thread
                    attempts to access a file already in use by another this will lead to exceptions being thrown.</li>
            </ul>
            <h4>Handle Stream Exceptions</h4>
            <ul>
                <li>When creating applications that use streams you need to ensure that your code can deal with any
                    exceptions that might be thrown by a stream.</li>
                <li>An application may try to open a file that doesn't exist, or a given storage device may become full
                    during writing.</li>
                <li>It is possible that threads in multi-threaded applications can "fight" over files. If one thread
                    attempts to access a file already in use by another this will lead to exceptions being thrown.</li>
            </ul>
            <h4>File Storage</h4>
            <ul>
                <li>A storage device can be devided into partitions. Each represents an area on the storage device that
                    can be used to store data.</li>
                <li>A partition on a storage device is exposed as a drive which, on the Windows OS, is represented by a
                    drive letter.</li>
                <li>The drive letter is assigned by the OS and is used as the root of an absolute path to a file on the
                    computer.</li>
                <li>The Disk Management application allows administrators to re-assign drive letter, combine multiple
                    physical drivers into a single logical driver, and attach virtual hard drives (VHD) created from
                    drive images.</li>
                <li>Each of the partitions on a physical storage device is formatted using a particular filing system
                    that manages the storage of files.</li>
                <li>The System.IO namespace provides the DriveInfo class which can be used to obtain information about
                    the drivers attached to a system.</li>
            </ul>
            <h4>Use FileInfo</h4>
            <ul>
                <li>A file system maintains information about each file it stores. Including the name, permissions,
                    dates for creation and modification, and the physical location on the storage device.</li>
                <li>It also maintains attribute information about each file. Attribute information is held as a single
                    value with different bits in the value indicating different attributes.</li>
                <li>Logical operators can be used to work with these values and to assign different attributes to a
                    file.</li>
                <li>The available attributes are as follows:
                    <ul>
                        <li><b>FileAttributes.Archive:</b> The file has not been backed up yet. The attribute will be
                            cleared when/if the file is backed up.</li>
                        <li><b>FileAttributes.Compressed:</b> The file is compressed. This is not something that our
                            program should change.</li>
                        <li><b>FileAttributes.Directory:</b> The file is a directory. This is not something that our
                            prgram should change.</li>
                        <li><b>FileAttributes.Hidden:</b> This file will not appear in an ordinary directory listing.
                        </li>
                        <li><b>FileAttributes.Normal:</b> This is a normal file with no special attributes. This
                            attribute is only valid when there are no other attributes assigned to the file.</li>
                        <li><b>FileAttributes.ReadOnly:</b> The file cannot be written.</li>
                        <li><b>FileAttributes.System:</b> The file is part of the OS and is used by it.</li>
                        <li><b>FileAttributes.Temporary:</b> The file is a temporary file that will not be required when
                            the application has finished. The file system will attempt to keep this file in memory to
                            improve performance.</li>
                    </ul>
                </li>
                <li>This information is exposed in a C# program via the FileInfo class.</li>
                <li>You can use a FileInfo instance to open a file for reading and writing, moving a file, renaming a
                    file, and also modifying the security settings of a file.</li>
                <li>Some of the functions provided by FileInfo are diplicates of those provided by the File class.</li>
                <li>The File class is most useful when you want to perform an action on a single file, and FileInfo when
                    working with a large number of files.</li>
            </ul>
            <h4>Use the Directory and DirectoryInfo Classes</h4>
            <ul>
                <li>A file system can create files that contain collections of file information items called directories
                    or folders.</li>
                <li>Directories can contain directory information about child directories, which allows a user to nest
                    directories to create tree structures.</li>
                <li>As with files, there are 2 way to work with directories: the Directory class and the DirectoryInfo
                    class.</li>
                <li>The Directory class is static and provides methods that can enumerate the contents of directories
                    and to create and manipulate directories.</li>
            </ul>
            <h4>Files and Paths</h4>
            <ul>
                <li>A path defines the location of a file on a storage device. They can be relative or absolute.</li>
                <li>A relative path specifies the location of a file relative to the folder in which the program is
                    presently running. They can specify a file in a parent directory, or a file in a directory in
                    another part of the tree.</li>
                <li>The period "." character means the current directory and a double period ".." means the directory
                    above the current one.</li>
                <li>The "@" character can be placed at the start of a string to mark it as a verbatim string. This means
                    that any escape character will be ignored making it useful because otherwise backslash characters
                    might be interpreted as escape characters.</li>
                <li>An absolute path includes the drive letter and identifies all the sub-directories in the path to the
                    file.</li>
                <li>The Path class provides methods to remove filenames from full paths, change the extension on a
                    filename, and combine filenames and directory paths.</li>
                <li>The Path class is very useful and should always be used in preference to manually working with path
                    string.</li>
                <li>It also provides methods that can generate temporary filenames.</li>
            </ul>
            <h4>Searching for Files</h4>
            <ul>
                <li>The DirectoryInfo class provides a method called GetFiles that can be used to get a collection of
                    FileInfo items that describe the files in a directory.</li>
                <li>One overload of GetFiles can accept a search string. An asterisk "*" character in the search string
                    represents any number of characters and the question mark "?" character can repreent a single
                    character.</li>
                <li>Recursion can be used to retrieve the files of nested directories, and nested directories within
                    those directories.</li>
            </ul>
        </div>
        <div>
            <h3>Read and Write from the Network by Using Classes in the System.NET Namespace</h3>
            <ul>
                <li>.NET Framework provides a range of application programming interfaces that cn interact with a TCP/IP
                    (Transmission Control Protcol/Internet Protocol) network.</li>
                <li>C# programs can create network socket objects that can communicate over the network by sending
                    unacknowledged datagrams using UDP (User Datagram Protocol) or creating managed connection using TCP
                    (Transmission Control Protocol).</li>
                <li>Classes in the System.Net namespace allow a porgram to communicate with servers using the HTTP
                    (HyperText Transport Protocol). This protocol operates on top of a TCP/IP connection.</li>
                <li>An HTTP client, for example a web browser, creates a TCP connection to a server an makes a request
                    for data by sending the HTTP GET command. The server will then respond with a page of information
                    and the TCP connection will close.</li>
                <li>Information returned from the server will be formatted using HTML (HyperText Markup Language) and
                    rendered by the browser.</li>
                <li>In the case of an ASP (Active Server Pages) application the HTMl document may be produced
                    dynamically by software, rather than being loaded from a file stored on the server.</li>
                <li>HTTP was originally used for the sharing of human-readable web pages. However, now an HTTP request
                    can return an XML or JSON formatted document that describes data in an application.</li>
                <li>The REST (REpresentational State Transfer) architecture uses the GET, PUT, POST and DELETE
                    operations of HTTP to allow a client to request a server to perform functions in a client-server
                    application.</li>
                <li>The fundamental operation that is used to communicate with these and other servers is the sending of
                    a "web request" to a server to perform an HTML command on the server.</li>
            </ul>
            <h4>WebRequest</h4>
            <ul>
                <li>The WebRequest class is an abstract base class that specifies the behaviours of a web request. it
                    exposes a static factory method called Create, which is given a URI (Universal Resource Identifier)
                    string that specifies the resource that is to be used.</li>
                <li>The Create method inspects the URI and returns a child of the WebRequest class that matches that
                    resource, these are: HttpWebRequest, FtpWebRequest, and FileWebRequest.</li>
                <li>In the case of a website, a URI string will start with "http" or "https" and the Create method will
                    return an HttpWebRequest instance.</li>
                <li>The GetResponse method on an HttpWebRequest returns a WebResponse instance that describes the
                    response from the server.</li>
                <li>To read the text from a webpage you must use the GetResponseStream method on the response.</li>
                <li>Using WebRequest instances to read web pages works, but is rather complicated. It does have the
                    advantage that a program can set a wide range of properties on the web request to tailor it to
                    particular server requirements.</li>
                <li>
                    <code>
                        WebRequest webRequest = WebRequest.Create("https://microsoft.com");
                        WebResponse webResponse = webRequest.GetResponse();

                        using (StreamReader responseReader = new StreamReader(webResponse.GetResponseStream()))
                        {
                        string siteText = responseReader.ReadToEnd();
                        Console.WriteLine(siteText);
                        }
                    </code>
                </li>
            </ul>
            <h4>WebClient</h4>
            <ul>
                <li>The WebClient class provides a simpler and quicker way of reading the text from a web server. </li>
                <li>There is no need to create a stream to read the page contents and there is no need to deal with the
                    response to the web request before you cna obtain the reply from the server.</li>
                <li>
                    <code>
                        WebClient client = new WebClient();
                        string siteText = client.DownloadString("https://www.microsoft.com");
                        Console.WriteLine(siteText);
                    </code>
                </li>
                <li>The WebClient also provides methods that can be used to read from the server asynchronously.
                    <code>
                        async Task&lt;string&gt; readWebpage(string uri)
                        {
                        WebClient client = new WebClient();
                        return await client.DownloadStringTaskAsync(uri);
                        }
                    </code>
                </li>
            </ul>
            <h4>HttpClient</h4>
            <ul>
                <li>The HttpClient is important because it is the way Windows Universal Applications download the
                    contents of a website.</li>
                <li>Unlike the WebRequest and the WebClient classes, an HttpClient only provides asynchronous methods,
                    but can be used in a very similar manner to the WebClient.</li>
                <li>
                    <code>
                        async Task&lt;string&gt; readWebpage(string uri)
                        {
                        HttpClient client = new HttpClient();
                        return await client.GetStringAsync(uri);
                        }
                    </code>
                </li>
            </ul>
            <h4>Exception Handling</h4>
            <ul>
                <li>As with file handling, loading information from the Internet is prone to error. Network connectons
                    may be broken or servers may be unavailable.</li>
                <li>This means web request code should be enclosed in appropriate exception handlers.</li>
            </ul>
        </div>
        <div>
            <h3>Implement Asynchronous I/O Operations</h3>
            <ul>
                <li>When a user has to wait for a synchronous file action to perform it may lead to a very poor user
                    experience.</li>
                <li>File operations provided by the File class do not have any asynchronous versions, so the FileStream
                    class should be used instead.
                    <code>
                        async Task WriteBytesAsync(string filename, byte[] items)
                        {
                        using (FileStream outStream = new FileStream(filename, FileMode.OpenOrCreate, FileAccess.Write))
                        {
                        await outStream.WriteAsync(items, 0, items.Length);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Handling Exceptions in Asynchronous Methods</h4>
            <ul>
                <li>If any exceptions are thrown by the asynchronous file write method they must be caught and a message
                    displayed for the user.</li>
                <li>This will only happen if the WriteBytesAsync method returns a Task object that is awaited when the
                    WriteBytesAsync method is called.
                    <code>
                        private async void StartTaskButton_Click(object sender, RoutedEventArgs e)
                        {
                        byte[] data = new byte[100];

                        try
                        {
                        // This filename contains an invalid character.
                        await WriteBytesAsynctask("demo:.dat", data);
                        }
                        catch (Exception ex)
                        {
                        MessageBox.Show(ex.Message, "File write failed");
                        }
                        }
                    </code>
                </li>
                <li>The only asynchronous methods that should return void are the actual event handlers for the windows
                    controls. Other asynchronous methods must return either a result or a Task, so that any thrown
                    exceptions can be dealt with correctly.</li>
            </ul>
        </div>
        <div>
            <h3>Implement Asynchronous I/O Operations</h3>
            <ul>
                <li>When a user has to wait for a synchronous file action to perform it may lead to a very poor user
                    experience.</li>
                <li>File operations provided by the File class do not have any asynchronous versions, so the FileStream
                    class should be used instead.
                    <code>
                        async Task WriteBytesAsync(string filename, byte[] items)
                        {
                        using (FileStream outStream = new FileStream(filename, FileMode.OpenOrCreate, FileAccess.Write))
                        {
                        await outStream.WriteAsync(items, 0, items.Length);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Handling Exceptions in Asynchronous Methods</h4>
            <ul>
                <li>If any exceptions are thrown by the asynchronous file write method they must be caught and a message
                    displayed for the user.</li>
                <li>This will only happen if the WriteBytesAsync method returns a Task object that is awaited when the
                    WriteBytesAsync method is called.
                    <code>
                        private async void StartTaskButton_Click(object sender, RoutedEventArgs e)
                        {
                        byte[] data = new byte[100];

                        try
                        {
                        // This filename contains an invalid character.
                        await WriteBytesAsynctask("demo:.dat", data);
                        }
                        catch (Exception ex)
                        {
                        MessageBox.Show(ex.Message, "File write failed");
                        }
                        }
                    </code>
                </li>
                <li>The only asynchronous methods that should return void are the actual event handlers for the windows
                    controls. Other asynchronous methods must return either a result or a Task, so that any thrown
                    exceptions can be dealt with correctly.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-2">Skill 4.2: Consume Data</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Retrieve data from a database</li>
            <li>Update date in a database</li>
            <li>Consume JSON and XMl data</li>
            <li>Retrieve data by using web Windows Communication Foundation (WCF)</li>
        </ul>
        <div>
            <h3>Retrieve Data from a Database</h3>
            <h4>Data in a Database</h4>
            <ul>
                <li>The following class contains data members and an integer ID value, which will be used by the
                    database to allow it to uniquely identify each record.
                    <code>
                        public class MusicTrack
                        {
                        public int ID {get; set;}
                        public string Artist {get; set;}
                        public string Title {get; set;}
                        public int Length {get; set;}
                        }
                    </code>
                </li>
                <li>The Entity Framework toolchain uses the class definnition to produce a table in a database that has
                    the required data storage.</li>
                <li>From a data design point of view, a table in a database can be considered as a collection of
                    objects.</li>
            </ul>
            <h4>Read with SQL</h4>
            <ul>
                <li>A database is managed by a server process that accepts commands and acts on them. These commands are
                    given in the SQL (Structured Query Language) format.</li>
                <li>SQL dates back to the 1970's and is called a domain specific language because it is used solely for
                    expressing commands to control a database.</li>
                <li>The asterisk "*" character in SQL is a wildcard that matches all the entries in the table.</li>
                <li>The following command will read all the records from a given table:
                    <code>
                        SELECT * FROM TableName
                    </code>
                </li>
                <li>A program uses an SQL database in a similar way to a stream. It creates an object that represents a
                    connection to the database and sends SQL commands to it.</li>
                <li>The DbConnection is an abstract class that represents a connection to a database and describes
                    behaviours of the connection in the same way that the Stream class is also abstract and describes
                    the behaviours of streams.</li>
                <li>The SqlConnection class is a child of the DbConnection class and represents the implementation of a
                    connection to a SQL database.</li>
                <li>The SqlConnection constructor needs a connection string that identifies the datavase that is to be
                    opened.</li>
                <li>A connection string contains a number of items expressed as name-value pairs. For a server on a
                    remote machine the string will contain the address of the server, the port on which the server is
                    listening and a username/password pair that can authenticate the connection.</li>
                <li>In this example I connect to a database, create an SQL query, execute it and read and print the
                    information:
                    <code>
                        static void Main(string[] args)
                        {
                        string connectionString = "Server=(localdb)\\mssqllocaldb;" +
                        "Database=DatabaseName;" +
                        "Trusted_Connection=True;MultipleActiveResultSets=true";

                        using (SqlConnection connection = new SqlConnection(connectionString))
                        {
                        connection.Open();
                        SqlCommand command = new SqlCommand("SELECT * FROM TableName", connection);
                        SqlReader reader = command.ExecuteReader();
                        while (reader.read())
                        {
                        string artist = reader["Artist"].ToString();
                        string title = reader["Title"].ToString();

                        Console.WriteList("Artist: {0} Title: {1}", artist, title);
                        }
                        }
                        Console.ReadKey();
                        }
                    </code>
                </li>
                <li>It is important that a connection string is not hard-coded. Otherwise, anyone obtaining the source
                    code of the program can view the connection string and will get accdess to the database.</li>
                <li>Anyone obtaining the compiled version of the program can use a tool such as ildasm to view the MSIL
                    code and extract the connection.</li>
                <li>You would also have to change the code, recompile it, and publish it, if you want to change the
                    connection string.</li>
            </ul>
            <h4>Connection String Management in ASP.NET</h4>
            <ul>
                <li>The database connection strings in ASP.NET applications are stored in the configuration files.
                    Usually, this file is the web.config, app.config, or appsettings.json file.</li>
                <li>The ConnectionStrings element in the settings file contains the connection strings for all the data
                    contexts used in the program.</li>
                <li>The setting information in a solution can contain the descriptions of environments that are to be
                    used for development and production deployments of an application.</li>
                <li>The setting information to be used is when a server is started and determined by an environment
                    variable on the computer that is tested when the program starts running. There are 2 contexts in
                    which the word environment is being used:
                    <ul>
                        <li>An ASP applicaiton environment determines the settings for logging, tracing, and debugging,
                            and the database connection string that will be in force when the ASP application runs on a
                            machine. A developer can also create their own settings values that can be used to give them
                            more control over a particular environment.</li>
                        <li>An environment variable is a value that is maintained by the OS and can be used by processes
                            running on the machine. Environment variables managed by Windows 10 include the name of the
                            machine and the file paths to be used to search for programs. The system environment
                            variable ASPNETCORE_ENVIRONMENT can be set to values that determine which environment an ASP
                            application will select when it starts running.</li>
                    </ul>
                </li>
                <li>In older ASP.NET applications the SQL settings are held in the web.config file, which is part of the
                    solution. Developers then use XML transformations to override settings in the file to allow
                    different SQl servers to be selected.</li>
            </ul>
            <h4>SQL Query Operation</h4>
            <ul>
                <li>A program can make a query of a database by creating an SqlCommand instance. The constructor for it
                    takes an SQL command in the form of a string and a database connection.</li>
                <li>In this example the query is executed as a reader command:
                    <code>
                        SqlCommand command = new SqlCommand("SELECT * FROM TableName", connection);
                        SqlCommand command = ne SqlCommand("SELECT * FROM TableName", connection);
                    </code>
                </li>
                <li>The SqlReader provides methods that can be used to move through the results returned by the query.
                    It is only possible to move forward through the results.</li>
                <li>The Read method returns false when there are no more results.</li>
                <li>Individual items in the element can be accessed using their name:
                    <code>
                        while(reader.read())
                        {
                        string artist = reader["Artist"].ToString();
                        string title = reader["Title"].ToString();

                        Console.WriteLine("Artist: {0} Title: {1}", artist, title);
                        }
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Update Data In A Database</h3>
            <ul>
                <li>An SQL UPDATE command will update the contents of a database.</li>
                <li>Specific records in a table can be targeted by identifying them with the WHERE clause.</li>
                <li>
                    <code>
                        using (SqlConnection connection = new SqlConnection(connectionString))
                        {
                        connection.Open();
                        dumpDatabase(connection);
                        SqlCommand command = new SqlCommand("UPDATE TableName SET FieldName='newValue' WHERE ID IN
                        (1,4,5);", connection);
                        int result = command.ExecuteNonQuery();
                        Console.WRiteLine("Number of entries updated: {0}", result);
                        dumpDatabase(connection);
                        }
                    </code>
                </li>
            </ul>
            <h4>SQL Injection and Database Commands</h4>
            <ul>
                <li>You can allow a user to enter values which can be used in the SQL query but this is very dangerous. They could easily delete data with SQL injecton.</li>
                <li>SQL injection is where a malicious user injects SQL commands into the code, often via input fields whose values are used to construct an SQL command.</li>
                <li>You should never construct SQL commands directly from user input. You must use parameterized SQL statements instead.</li>
                <li>This example shows how to use parameterized SQL statements:
                    <code>
                        string sqlCommandText = "UPDATE TableName SET FieldNameA=@newValue WHERE FieldNameB=@searchValue";

                        SqlCommand command = new SqlCommand(sqlCommandText, connection);
                        command.Parameters.AddWithValue("@newValue", newValue);
                        command.Parameters.AddWithValue("@searchValue", searchValue);
                    </code>
                </li>
            </ul>
            <h4>Asynchronous Database Access</h4>
            <ul>
                <li>There are asynchronous versions of all the methods used above.</li>
                <li>These methods used in conjunction with the async/await mechanisms allow a program to run database queries asynchronously.</li>
                <li>This is particularly important if your program is interacting with the user via a windowed interface.</li>
                <li>The dumpDatabase nethod uses asynchronous database commands to create a listing of the contents of a database. It is part of a WPF (Windows Presentation Foundation) application that also allows database editing.
                    <code>
                        async Task &lt;string&gt; dumpDatabase(SqlConnection connection)
                        {
                            SqlCommand command = new SqlCommand("SELECT * FROM MusicTrack", connection);
                            SqlDataReader reader = await command.ExecuteReaderAsync();
                            StringBuilder databaseList = new StringBuilder();
                            while(await reader.ReadAsync())
                            {
                                string id = reader["ID"].ToString();
                                string artist = reader["Artist"].ToString();
                                string title = reader["Title"].ToString();

                                string row = string.Format("ID: {0} Artist: {1} Title: {2}", id, artist, title);
                                databaseList.AppendLine(row);
                            }
                            return databaseList.ToString();
                        }
                    </code>
                </li>
            </ul>
            <h4>Using SQL in ASP Applications</h4>
            <ul>
                <li>You won't find any SQL commands in the code that implement the controller classes for ASP applications.</li>
                <li>This is due to database updates in ASP applications being performed using an Update method that accepts a modified instance of the class to be updated.</li>
                <li>In this example the code updates the database and catches any exceptions that may be thrown:
                    <code>
                        try
                        {
                            _context.Update(record); // Update the database context with the edited track.
                            await _context.SaveChangesAsync(); // Save all the changes.
                        }
                        catch(DbUpdateConcurrencyException)
                        {
                            // Deal with exceptions.
                        }
                    </code>
                </li>
                <li>ASP applications use embedded C# code in the web page (Razor) which iterates through the database contents and presents a view of the data.</li>
                <li>In this example is the index.cshtml file for a MusicTrack:
                    <code>
                        &lt;tr&gt;                      
                        &lt;td&gt;
                            @Html.DisplayFor(modelItem => item.Artist)
                        &lt;/td&gt;                      
                        &lt;td&gt;
                            @Html.DisplayFor(modelItem => item.Title)
                        &lt;/td&gt;                      
                        &lt;td&gt;
                            @Html.DisplayFor(modelItem => item.Length)
                        &lt;/td&gt;                      
                        &lt;td&gt;
                            &lt;a asp-action="Edit" asp-route-id="@item.ID"&gt;Edit&lt;/a&gt; |
                            &lt;a asp-action="Details" asp-route-id="@item.ID"&gt;Details&lt;/a&gt; |
                            &lt;a asp-action="Delete" asp-route-id="@item.ID"&gt;Delete&lt;/a&gt;
                        &lt;/td&gt;
                        &lt;/tr&gt;
                    </code>
                </li>
        </div>
        <div>
            <h3>Consume JSON and XML Data</h3>
            <h4>Consume JSON Data</h4>
            <ul>
                <li>JSON (JavaScript object Notation) is a means by which applications can exchange data.</li>
                <li>A JSON document is a plain text file that contains a structured collection of and value pairs.</li>
                <li>JSON files can be read and written using the Newtonsoft.Json library.</li>
                <li>In this example the program consumes a JSON feed provided by NASA. It's updated every daya with new pictures or videos from the NASA archives:
                    <code>
                        public class ImageOfDaya
                        {
                            public string date {get; set;}
                            public string explanation {get; set;}
                            public string hdurl {get; set;}
                            public string media_type {get; set;}
                            public string service_version {get; set;}
                            public string title {get; set;}
                            public string url {get; set;}
                        }

                        async Task&lt;ImageOfDay&gt; GetImageOfDay(String imageUrl)
                        {
                            string NASAJson = await readWebpage(imageUrl);
                            ImageOfDay result = JsonConvert.DeserializeObject&lt;ImageOfDay&gt;(NASAJson);
                            return result;
                        }
                    </code>
                </li>
                <li>For this to work the ImageOfDay class had to be created which exactly matches the object described in the JSON feed from NASA.</li>
                <li>This can be done using http://json2csharp.com which accepts a web address that returns a JSON document and then automatically generates a C# class as described by the doucment.</li>
                <li>In this example the code displays the image when the user clicks a button to perform the load. In this case it'll always display the same image but could easily be updated to display the image for a particular day:
                    <code>
                        private async void LoadButtonClickedObject(object sender, RoutedEventArgs e)
                        {
                            try
                            {
                                ImageOfDay imageOfDay = await getImageOfDay("https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&date=2018-05-29");

                                if(imageOfDay.media_type != "image")
                                {
                                    MessageBox.Show("It is not an image today");
                                    return;
                                }

                                DescriptionTextBlock.Text = imageOfDay.explanation;

                                await displayUrl(imageOfDay.url);
                            }
                            catch (Exception ex)
                            {
                                MessageBox.Show("Fetch failed: {0}", ex.Message);
                            }
                        }
                    </code>
                </li>
            </ul>
            <h4>Consume XML Data</h4>
            <ul>
                <li>XML is slightly more expressive than JSON, but XML documents are larger than equivalent JSON documents, and this, along with the ease of JSON, has led to JSON replacing XML. However, a lot of information is still expressed ussing XML.</li>
                <li>The System.XML namespace contains a set of classes for working with XML documents. The XMLTextReader class works through a stream of text and decodes each XML element in turn:
                    <code>
                        using (StringReader stringReader = new StringReader(XMLDocument))
                        {
                            XmlTextReader reader = new XmlTextReader(stringReader);

                            while (reader.Read())
                            {
                                string description = string.Format("Type:{0} Name:{1} Value:{2}",
                                reader.NodeType.ToString(),
                                reader.Name,
                                reader.Value);
                                Console.WriteLine(description);
                            }
                        }
                    </code>
                </li>
            </ul>
            <h4>XML Documents</h4>
            <ul>
                <li>It is possible to read information from an XML document by decoding each individual element, but this can be hard work to code.</li>
                <li>An easier approach is to use an XMLDocument instance. This creates a DOM (Document Object Model) in memory from which data can be extracted.</li>
                <li>An advantage of a DOM is that a program can change elements in the DOM and then write out a modified copy of the document incorporating the change:
                    <code>
                        XmlDocument doc = new XmlDocument();
                        doc.LoadXml(XMLDocument);

                        System.Xml.XmlElement rootElement = doc.DocumentElement;
                        // Make sure it is the right element.
                        if (rooElement.Name != "MusicTrack")
                        {
                            Console.WriteLine("Not a music track");
                        }
                        elements
                        {
                            string artist = rootElement["Artist"].FirstChild.Value;
                            string title = rootElement["Title"].FirstChild.Value;
                            Console.WriteLine("Arist:{0} Title:{1}", artist, title);
                        }
                    </code>
                </li>
                <li>An XmlDocument contains a hierarchy of items with a rootElement object at the top of the hierarchy.</li>
                <li>These items can be accessed in an element by using a string indexer that contains the name of the required item.</li>
            </ul>
        </div>
        <div>
            <h3>Retrieve Data by Using Windows Communication Foundation (WCF)</h3>
            <ul>
                <li>The NASA image reader works by converting a response from a server into an instance of a class that contains a description of the image and the web address from which the image can be downloaded.</li>
                <li>To read information provided by the NASA server, a client program contains a C# class that matches the JSON document that is received from the server.</li>
                <li>A client of a web service also uses an instance of an object to interact with a server. However, in this case, the client can call methods on the object to read data and also update information on the server.</li>
                <li>The object that is created is a "proxy object". A call to a method of the proxy object will cause a request to be create that is sent to the service on the server.</li>
                <li>When the server receives the request, it will then call the method in a server object. The result which is returned by the method is packaged up into another network message, which is sent back to the client and then sends the return value back to the calling software.</li>
                <li>The service also exposes a description of the methods that it provides. These are used by the development tool to actually create the proxy object in the client program. Meaning you can easily create a client application.</li>
            </ul>
            <h4>Create a Web Service</h4>
            <ul>
                <li>As an example, we'll create a 'Joke of the Day' service. It'll return a string containing a joke on request from the client. The user will be able to select the "strength" of the joke, ranging from 0 to 2 where 0 is mildly amusing and 2 is a guaranteed ROFL experience.</li>
                <li>The application is made up of 2 parts: the server program that exports the service, and the client program that uses it.</li>
                <li>The server is created as a WCF (Windows Communication Foundation) Service application.</li>
                <li>The client will be an application that connects to the service and requests a joke.</li>
                <li>The attributes [ServiceContract] and [OperationContract] denote that the interface and method are to be exposed as services.</li>
                <li>
                    <code>
                        using System.ServiceModel;

                        namespace JokeOfTheDay
                        {
                        [ServiceContract]
                        public interface IJokeOfTheDayService
                        {
                            [OperationContract]
                            string GetJoke(int jokeStrength);
                        }
                        }
                    </code>
                </li>
                <li>Once you have the interface you now need a class that implements the method:
                    <code>
                        public class JokeOfTheDayService : IJokeOfTheDayService
                        {
                            public string GetJoke(int jokeStrength)
                            {
                                string result = "Invalid strength";
                                switch(jokeStrength)
                                {
                                    case 0:
                                    result = "Knock knock. Who's there? Oh, you've heard it.";
                                    break;
                                    case 1:
                                    result = "What's green and hairy and goes up and down? A gooseberry in a lift.";
                                    break;
                                    case 2:
                                    result = "A horse walks into a bar and the barman asks 'Why the long face?'.";
                                    break;
                                }
                                return result;
                            }
                        }
                    </code>
                </li>
                <li>If you create a service you can use the WCF Test Client to inboke the methods and view the results.</li>
                <li>You can also view the service description in a browser. This gives you a link to the service description, as well as some sample code that shows how to use it.</li>
            </ul>
            <h4>Create a Web Client</h4>
            <ul>
                <li>The client application can run on any machine that has a network connection and wants to consume the service.</li>
                <li>The client application needs to contain a connection to the JokeOfTheDayService which is added to the client Visual Studio project like any other references.</li>
                <li>Once done, you'll see a panel that displays the JokeOfTheDayService only provides one method and you can also change the namespace used to access it on the client.</li>
                <li>The client must now create a proxy object that will be used to invoke the methods in the service:
                    <code>
                        using System;
                        using JokeClient.JokeService;

                        namespace JokeClient
                        {
                            class program
                            {
                                static void Main(string[] args)
                                {
                                    using (JokeOfTheDayServiceClient jokeClient = new JokeOfTheDayServiceClient())
                                    {
                                        Console.WriteLine(jokeClient.GetJoke(1));
                                    }
                                    Console.ReadKey();
                                }
                            }
                        }
                    </code>
                </li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-3">Skill 4.3: Query and Manipulate Data and Objects by Using LINQ</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Query data by using operators, including projection, join, group, take, skip, and aggregate</li>
            <li>Create method-base LINQ queries</li>
            <li>Query data by using query comprehension syntax</li>
            <li>Select data by using anonymous types</li>
            <li>Force execution of a query</li>
            <li>Read, filter, create, and modify data structures by using LINQ to XML</li>
        </ul>
        <div>
            <h3>Query Data by Using Operators, Including Projection, Join, Group, Take, Skip, and Aggregate</h3>
            <h4>Use an Object Initializer</h4>
            <ul>
                <li>Object initializer syntax is used to create new instances of record objects and to initialize thei values at the same time.</li>
                <li>This is a very useful C# feature that allows you to initialize objects when they are created without the need to create a consturctor method in the class being initialized.</li>
                <li>In this example the statement creates and initializes a new MusicTrack instance where the braces delimit the items that initialize the instance:
                    <code>
                        MusicTrack newTrack = MusicTrack
                        {
                            Artist = "Rob Miles",
                            Title = "My Way",
                            Length = 150
                        };
                    </code>
                </li>
                <li>Any properties not initialized are set to their default values (0 for numeric values and null for strings).</li>
                <li>Properties initialized this way must be made public members of the class.</li>
            </ul>
            <h4>Use a LINQ Operator</h4>
            <ul>
                <li>In this xample, the first statement uses a LINQ query to create an enumerable collection of MusicTracks, which is then enumerated by the foreach construction to print the results:
                    <code>
                        IEnumberable&lt;MusicTrack&gt; selectedTracks = from track in musicTracks where track.Arist.Name == "Rob Miles" select track;
                        foreach (MusicTrack track in selectedTracks)
                        {
                            Console.WriteLine("Artist:{0} Title:{1}", track.Artist.Name, track.Title);
                        }
                    </code>
                </li>
            </ul>
            <h4>Use the var Keyword with LINQ</h4>
            <ul>
                <li>C# is statically typed. Meaning, the type of objects in a program is determined at compile time and the compiler rejects any actions that are not valid.</li>
                <li>This means that the following code fails to compile because the compiler will not allow strings to be subtracted from numbers:
                    <code>
                        string name = "Rob Miles";
                        int age = 21;
                        int silly = age - name;
                    </code>
                </li>
                <li>This increases our confidence in our programs being correct when they run, but does involve going through extra effort to give each variable a type when you declare it.</li>
                <li>The above code can be simplified by using the car keyword to tell the compiler to infer the type of variable being created from the context in which the variable is used:
                    <code>
                        var name = "Rob Miles";
                    </code>
                </li>
                <li>This does not mean that the compiler cannot detect compilation errors. The example earlier will still fail to compile.</li>
                <li>The var keyword is especially useful when using LINQ as the result of a simple LINQ query is an enumerable colection of the type of data element held in the data source:
                    <code>
                        var selectedTracks = from track in musicTracks where track.Arist.Name == "Rob Miles" select track;
                    </code>
                </li>
                <li>There are some situations where you won't know the type of a variable when writing the code. These are called anonymous types and the only way to refer to these is by use of variables of type var.</li>
                <li>You can use var everywhere in your code but you won't be popular with other devs as they'll have to infer the type of variable by diging through the code. When you do use it, make sure the type can be inferred easily by the variable name.</li>
            </ul>
            <h4>LINQ Projection</h4>
            <ul>
                <li>The select operation in LINQ can be used to produce a filtered version of a data source.</li>
                <li>Projection can be used to ask a query to "project" the data in the class onto new instaces of a class created just to hold the data returned by the query.</li>
                <li>In this example the query is asked to create a new instance of the TrackDetails class to hold the result of each query.
                    <code>
                        class TrackDetails
                        {
                            public string ArtistName;
                            public string Title;
                        }
                        
                        var selectedTracks = from track in musicTracks 
                            where track.Arist.Name == "Rob Miles" 
                            select new TrackDetails
                            {
                                ArtistName = track.Artist.Name,
                                track.Title
                            };

                    </code>
                </li>
            </ul>
            <h4>Anonymous Types</h4>
            <ul>
                <li>You can remove the need to create a class to hold the result of a search query by making the query return results of an anonymous type:
                    <code>
                        var selectedTracks = from track in musicTracks 
                            where track.Arist.Name == "Rob Miles" 
                            select new // Project type name missing from here.
                            {
                                ArtistName = track.Artist.Name,
                                track.Title
                            };
                    </code>
                </li>
                <li>Instances of the new type are initialized using the object initializer syntax.</li>
                <li>The item that is returned by this query is an enumerable collection of instances of a type that has no name. It is anonymous. You have to use a var reference to refer to the query result.</li>
                <li>You can iterate through the collection in this result as your would any other, but each item must also be referred to using a var:
                    <code>
                        foreach (var item in selectedTracks)
                        {
                            console.WriteLine("Artist:{0} Title:{1}", item.ArtistName.Name, item.Title);
                        }
                    </code>
                </li>
            </ul>
            <h4>LINQ Join</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>LINQ Group</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>LINQ Take and Skip</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>LINQ Aggregate Commands</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
        <div>
            <h3>Create Method-base LINQ Queries</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
        <div>
            <h3>Query Data by Using Query Comprehension Syntax</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
        <div>
            <h3>Select Data by Using Anonymous Types</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
        <div>
            <h3>Force Execution of a Query</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
        <div>
            <h3>Read, Filter, Create, and Modify Data Structures by Using LINQ to XML</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>Sample XML Document</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>Read XML with LINQ to XML and XDocument</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>Filter XML Data with LINQ to XML</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>Create XMl with LINQ to XML</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>Modify Data with LINQ to XML</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-4">Skill 4.4: Serialize and Deserialize Data by Using Binary and Custom Serialization, and XML,
            JSON and Data Contract Serializer</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-5">Skill 4.5: Store Data in and Retrieve Data from Collections</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="qa-4">Thought Experiments</h2>
        <div>
            <h3>HEADING</h3>
            <p>DESCRIPTION</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">QUESTION</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
    </div>
</div>