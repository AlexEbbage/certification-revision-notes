<div>
    <h1 id="chapter-4">Chapter 4: Implement Data Access</h1>
    <p>Skills covered in this chapter are:</p>
    <ul>
        <li><a href="#skill-4-1">Skill 4.1: Perform I/O Operations</a></li>
        <li><a href="#skill-4-2">Skill 4.2: Consume Data</a></li>
        <li><a href="#skill-4-3">Skill 4.3: Query and Manipulate Data and Objects by Using LINQ</a></li>
        <li><a href="#skill-4-4">Skill 4.4: Serialize and Deserialize Data by Using Binary and Custom Serialization, and
                XML, JSON and Data Contract Serializer</a></li>
        <li><a href="#skill-4-5">Skill 4.5: Store Data in and Retrieve Data from Collections</a></li>
        <li><a href="#qa-4">Thought Experiments</a></li>
    </ul>
    <div>
        <h2 id="skill-4-1">Skill 4.1: Perform I/O Operations</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Read and write files and streams</li>
            <li>Read and write from the network by using classes in the System.NET namespace</li>
            <li>Implement asynchronous I/O operations</li>
        </ul>
        <div>
            <h3>Read and Write Files and Streams</h3>
            <ul>
                <li>A stream is a software object that represents a stream of data.</li>
                <li>The .NET framework provides a Stream class that serves as the parent type to a range of classes that
                    can be used to read and write data.</li>
                <li>There are 3 ways that a program can interact with a stream:
                    <ul>
                        <li>Write a sequence of bytes to a stream</li>
                        <li>Read a sequence of bytes from a stream</li>
                        <li>Position the "file pointer" in a stream</li>
                    </ul>
                </li>
                <li>File Pointer: Position in the stream where the next read or write operation will take place.</li>
                <li>Seek Method: Provided by the stream to set the file pointer position.</li>
                <li>The Stream class is abstract and serves as a template for streams that connect to actual storage
                    resources.</li>
                <li>Any object that can work with a Stream can work with any objects that behave like a stream.</li>
                <li>System.IO.Stream is the base type to 5 types: BufferedStream, FileStream, MemoryStream, PipeStream,
                    and NetworkStream.</li>
                <li>Each base class contains the Stream behaviours that allow data to be transferred. However, each type
                    is created differently. <i>e.g. A FileStream must specify the path to the file, and a Memory Stream
                        must specify the buffer in memory.</i></li>
            </ul>
            <h4>Use FileStream</h4>
            <ul>
                <li>The FileStream object provides a stream instance connected to a file which converts calls into the
                    stream into commands for the filesystem on the computer running the program.</li>
                <li>The file system provides the interface to the physical device performing the data storage for the
                    computer.</li>
                <li>A call to the stream object's Write method will generate a request to the file system to write the
                    data to the storage.</li>
                <li>
                    <code>
                        static void Main(string[] args){
                        // Writing to a files
                        FileStream outputStream = new FileStream("Output.txt", FileMode.OpenOrCreate, FileAccess.Write);
                        string outputMessageString = "Hello world";
                        byte[] outputMessageBytes = Encoding.UTF8.GetBytes(outputMessageString);
                        outputStream.Write(outputMessageBytes, 0, outputMessageBytes.Length);
                        outputStream.Close();

                        // Reading from files
                        FileStream inputStream = new FileStream("Output.txt", FileMode.Open, FileAccess.Read);
                        long fileLength = inputStream.Length;
                        byte[] readBytes = new byte[fileLength];
                        inputStream.Read(readBytes, 0, (int)fileLength);
                        string readString = Encoding.UTF8.GetString(readBytes);
                        inputStream.Close();
                        Console.WriteLine("Read message: {0}", readString);

                        Console.ReadKey();
                        }
                    </code>
                </li>
            </ul>
            <h4>Control File Use with FileMode and FileAccess</h4>
            <ul>
                <li>A stream can be associated with reading, writing, or updating a file.</li>
                <li>The base Stream class provides properties that a program can use to determine the abilities of a
                    given stream instance.</li>
                <li>The FileMode enumeration is used in the constructor of a FileStream to indicate how the file is to
                    be opened:
                    <ul>
                        <li><b>FileMode.Append:</b> Open a file for appending to the end. If the file exists, move the
                            seek position to the end of this file. If not, create it. Only useable if the file is being
                            opened for writing.</li>
                        <li><b>FileMode.Create:</b> Create a file for writing. If it exists, it is overwritten.</li>
                        <li><b>FileMode.CreateNew:</b> Create a file for writing. If it exists, an exception is thrown.
                        </li>
                        <li><b>FileMode.Open:</b> Open an existing file. If it doesn't exist, an exception is thrown.
                            The mode can be used for reading or writing.</li>
                        <li><b>FileMode.OpenOrCreate:</b> Open a file for reading or writing. If it doesn't exist, an
                            empty file is created. The mode can be used for reading or writing.</li>
                        <li><b>FileMode.Truncate:</b> Open a file for writing and remove any existing contents.</li>
                    </ul>
                </li>
                <li>The FileAccess enumeration is used to indicate how the file is to be used:
                    <ul>
                        <li><b>FileMode.Read:</b> Open a file for writing.</li>
                        <li><b>FileMode.ReadWrite:</b> Open a file for reading or writing.</li>
                        <li><b>FileMode.Write:</b> Open a file for writing.</li>
                    </ul>
                </li>
            </ul>
            <h4>Convert Text to Binary Data with Unicode</h4>
            <ul>
                <li>The System.Text namespace has the Encoding class which has a property, UTF8, which provides methods
                    that will encode and decode Unicode text.</li>
                <li>Unicode is a mapping of character symbols to number vaules. The UTF8 encoding maps Unicode
                    charaacters onto 8-bit calues that can be stored in arrays of bytes.</li>
                <li>Most text files are encoded using UTF8.</li>
                <li>The Encoding class also provides support for other encoding standaring including UTF32 and ASCII.
                </li>
                <li>The GetBytes encoding method takes a C# string and returns the bytes that represent that string in
                    the specified encoding.</li>
                <li>The GetString decoding method takes an array of bytes and returns the string that a buffer full of
                    bytes represents.</li>
            </ul>
            <h4>IDispose and FileStream Objects</h4>
            <ul>
                <li>The stream class implements IDisposable, meaning objects derived from the Stream type must also
                    implement the interface.</li>
                <li>This also means the using construction can be used to ensure that files are closed when they are no
                    longer required.</li>
            </ul>
            <h4>Work with Text Files</h4>
            <ul>
                <li>The filesystem makes no particular distinciton between text files and binary files.</li>
                <li>The TextWriter and TextReader classes are abstract stream classes which make it much easier to work
                    with text, and define a set of methods that can be used with text.</li>
                <li>The StreamWriter class extends the TextWriter class to allow us to write text to streams.
                    <code>
                        using (StreamWriter writeStream = new StreamWriter("Output.txt")){
                        writeStream.Write("Hello world!");
                        }

                        using (StreamReader readStream = new StreamReader("Output.txt")){
                        string readString = readStream.ReadToEnd();
                        Console.WriteLine("Text read: {0}", readString);
                        }
                    </code>
                </li>
            </ul>
            <h4>Chain Stream Together</h4>
            <ul>
                <li>The Stream class has a constructor that will accept another stream as a paramter, allowing the
                    creation of chains of streams.</li>
                <li>This example shhows how to use the GZipStream from the System.IO.Compression namespace in a chain of
                    streams that will save and load compressed text:
                    <code>
                        using (FileStream writeFile = new FileStream("CompressedText.zip", FileMode.OpenOrCreate,
                        FileAccess.Write))
                        {
                        using (GZipStream writeFileZip = new GZipStream(writeFile, CompressionMode.Compress))
                        {
                        using (StreamWriter writeFileText = new StreamWriter(writeFileZip))
                        {
                        writeFileText.Write("Hello world!");
                        }
                        }
                        }

                        using (FileStream readFile = new FileStream("CompressedText.zip", FileMode.Open,
                        FileAccess.Read))
                        {
                        using (GZipStream readFileZip = new GZipStream(readFile, CompressionMode.Decompress))
                        {
                        using (StreamReader readFileText = new StreamReader(readFileZip))
                        {
                        string readString = readFileText.ReadToEnd();
                        Console.WriteLine("Text read: {0}", readString);
                        }
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Use the File Class</h4>
            <ul>
                <li>The Files class is a helper class that makes it easier to work with files.</li>
                <li>It contains a set of static methods that can be used to append text to a file, copy a file, create a
                    file, delete a fil, move a file, open a file, read a file, and manage file security.</li>
            </ul>
            <h4>Handle Stream Exceptions</h4>
            <ul>
                <li>When creating applications that use streams you need to ensure that your code can deal with any
                    exceptions that might be thrown by a stream.</li>
                <li>An application may try to open a file that doesn't exist, or a given storage device may become full
                    during writing.</li>
                <li>It is possible that threads in multi-threaded applications can "fight" over files. If one thread
                    attempts to access a file already in use by another this will lead to exceptions being thrown.</li>
            </ul>
            <h4>Handle Stream Exceptions</h4>
            <ul>
                <li>When creating applications that use streams you need to ensure that your code can deal with any
                    exceptions that might be thrown by a stream.</li>
                <li>An application may try to open a file that doesn't exist, or a given storage device may become full
                    during writing.</li>
                <li>It is possible that threads in multi-threaded applications can "fight" over files. If one thread
                    attempts to access a file already in use by another this will lead to exceptions being thrown.</li>
            </ul>
            <h4>File Storage</h4>
            <ul>
                <li>A storage device can be devided into partitions. Each represents an area on the storage device that
                    can be used to store data.</li>
                <li>A partition on a storage device is exposed as a drive which, on the Windows OS, is represented by a
                    drive letter.</li>
                <li>The drive letter is assigned by the OS and is used as the root of an absolute path to a file on the
                    computer.</li>
                <li>The Disk Management application allows administrators to re-assign drive letter, combine multiple
                    physical drivers into a single logical driver, and attach virtual hard drives (VHD) created from
                    drive images.</li>
                <li>Each of the partitions on a physical storage device is formatted using a particular filing system
                    that manages the storage of files.</li>
                <li>The System.IO namespace provides the DriveInfo class which can be used to obtain information about
                    the drivers attached to a system.</li>
            </ul>
            <h4>Use FileInfo</h4>
            <ul>
                <li>A file system maintains information about each file it stores. Including the name, permissions,
                    dates for creation and modification, and the physical location on the storage device.</li>
                <li>It also maintains attribute information about each file. Attribute information is held as a single
                    value with different bits in the value indicating different attributes.</li>
                <li>Logical operators can be used to work with these values and to assign different attributes to a
                    file.</li>
                <li>The available attributes are as follows:
                    <ul>
                        <li><b>FileAttributes.Archive:</b> The file has not been backed up yet. The attribute will be
                            cleared when/if the file is backed up.</li>
                        <li><b>FileAttributes.Compressed:</b> The file is compressed. This is not something that our
                            program should change.</li>
                        <li><b>FileAttributes.Directory:</b> The file is a directory. This is not something that our
                            prgram should change.</li>
                        <li><b>FileAttributes.Hidden:</b> This file will not appear in an ordinary directory listing.
                        </li>
                        <li><b>FileAttributes.Normal:</b> This is a normal file with no special attributes. This
                            attribute is only valid when there are no other attributes assigned to the file.</li>
                        <li><b>FileAttributes.ReadOnly:</b> The file cannot be written.</li>
                        <li><b>FileAttributes.System:</b> The file is part of the OS and is used by it.</li>
                        <li><b>FileAttributes.Temporary:</b> The file is a temporary file that will not be required when
                            the application has finished. The file system will attempt to keep this file in memory to
                            improve performance.</li>
                    </ul>
                </li>
                <li>This information is exposed in a C# program via the FileInfo class.</li>
                <li>You can use a FileInfo instance to open a file for reading and writing, moving a file, renaming a
                    file, and also modifying the security settings of a file.</li>
                <li>Some of the functions provided by FileInfo are diplicates of those provided by the File class.</li>
                <li>The File class is most useful when you want to perform an action on a single file, and FileInfo when
                    working with a large number of files.</li>
            </ul>
            <h4>Use the Directory and DirectoryInfo Classes</h4>
            <ul>
                <li>A file system can create files that contain collections of file information items called directories
                    or folders.</li>
                <li>Directories can contain directory information about child directories, which allows a user to nest
                    directories to create tree structures.</li>
                <li>As with files, there are 2 way to work with directories: the Directory class and the DirectoryInfo
                    class.</li>
                <li>The Directory class is static and provides methods that can enumerate the contents of directories
                    and to create and manipulate directories.</li>
            </ul>
            <h4>Files and Paths</h4>
            <ul>
                <li>A path defines the location of a file on a storage device. They can be relative or absolute.</li>
                <li>A relative path specifies the location of a file relative to the folder in which the program is
                    presently running. They can specify a file in a parent directory, or a file in a directory in
                    another part of the tree.</li>
                <li>The period "." character means the current directory and a double period ".." means the directory
                    above the current one.</li>
                <li>The "@" character can be placed at the start of a string to mark it as a verbatim string. This means
                    that any escape character will be ignored making it useful because otherwise backslash characters
                    might be interpreted as escape characters.</li>
                <li>An absolute path includes the drive letter and identifies all the sub-directories in the path to the
                    file.</li>
                <li>The Path class provides methods to remove filenames from full paths, change the extension on a
                    filename, and combine filenames and directory paths.</li>
                <li>The Path class is very useful and should always be used in preference to manually working with path
                    string.</li>
                <li>It also provides methods that can generate temporary filenames.</li>
            </ul>
            <h4>Searching for Files</h4>
            <ul>
                <li>The DirectoryInfo class provides a method called GetFiles that can be used to get a collection of
                    FileInfo items that describe the files in a directory.</li>
                <li>One overload of GetFiles can accept a search string. An asterisk "*" character in the search string
                    represents any number of characters and the question mark "?" character can repreent a single
                    character.</li>
                <li>Recursion can be used to retrieve the files of nested directories, and nested directories within
                    those directories.</li>
            </ul>
        </div>
        <div>
            <h3>Read and Write from the Network by Using Classes in the System.NET Namespace</h3>
            <ul>
                <li>.NET Framework provides a range of application programming interfaces that cn interact with a TCP/IP
                    (Transmission Control Protcol/Internet Protocol) network.</li>
                <li>C# programs can create network socket objects that can communicate over the network by sending
                    unacknowledged datagrams using UDP (User Datagram Protocol) or creating managed connection using TCP
                    (Transmission Control Protocol).</li>
                <li>Classes in the System.Net namespace allow a porgram to communicate with servers using the HTTP
                    (HyperText Transport Protocol). This protocol operates on top of a TCP/IP connection.</li>
                <li>An HTTP client, for example a web browser, creates a TCP connection to a server an makes a request
                    for data by sending the HTTP GET command. The server will then respond with a page of information
                    and the TCP connection will close.</li>
                <li>Information returned from the server will be formatted using HTML (HyperText Markup Language) and
                    rendered by the browser.</li>
                <li>In the case of an ASP (Active Server Pages) application the HTMl document may be produced
                    dynamically by software, rather than being loaded from a file stored on the server.</li>
                <li>HTTP was originally used for the sharing of human-readable web pages. However, now an HTTP request
                    can return an XML or JSON formatted document that describes data in an application.</li>
                <li>The REST (REpresentational State Transfer) architecture uses the GET, PUT, POST and DELETE
                    operations of HTTP to allow a client to request a server to perform functions in a client-server
                    application.</li>
                <li>The fundamental operation that is used to communicate with these and other servers is the sending of
                    a "web request" to a server to perform an HTML command on the server.</li>
            </ul>
            <h4>WebRequest</h4>
            <ul>
                <li>The WebRequest class is an abstract base class that specifies the behaviours of a web request. it
                    exposes a static factory method called Create, which is given a URI (Universal Resource Identifier)
                    string that specifies the resource that is to be used.</li>
                <li>The Create method inspects the URI and returns a child of the WebRequest class that matches that
                    resource, these are: HttpWebRequest, FtpWebRequest, and FileWebRequest.</li>
                <li>In the case of a website, a URI string will start with "http" or "https" and the Create method will
                    return an HttpWebRequest instance.</li>
                <li>The GetResponse method on an HttpWebRequest returns a WebResponse instance that describes the
                    response from the server.</li>
                <li>To read the text from a webpage you must use the GetResponseStream method on the response.</li>
                <li>Using WebRequest instances to read web pages works, but is rather complicated. It does have the
                    advantage that a program can set a wide range of properties on the web request to tailor it to
                    particular server requirements.</li>
                <li>
                    <code>
                        WebRequest webRequest = WebRequest.Create("https://microsoft.com");
                        WebResponse webResponse = webRequest.GetResponse();

                        using (StreamReader responseReader = new StreamReader(webResponse.GetResponseStream()))
                        {
                        string siteText = responseReader.ReadToEnd();
                        Console.WriteLine(siteText);
                        }
                    </code>
                </li>
            </ul>
            <h4>WebClient</h4>
            <ul>
                <li>The WebClient class provides a simpler and quicker way of reading the text from a web server. </li>
                <li>There is no need to create a stream to read the page contents and there is no need to deal with the
                    response to the web request before you cna obtain the reply from the server.</li>
                <li>
                    <code>
                        WebClient client = new WebClient();
                        string siteText = client.DownloadString("https://www.microsoft.com");
                        Console.WriteLine(siteText);
                    </code>
                </li>
                <li>The WebClient also provides methods that can be used to read from the server asynchronously.
                    <code>
                        async Task&lt;string&gt; readWebpage(string uri)
                        {
                        WebClient client = new WebClient();
                        return await client.DownloadStringTaskAsync(uri);
                        }
                    </code>
                </li>
            </ul>
            <h4>HttpClient</h4>
            <ul>
                <li>The HttpClient is important because it is the way Windows Universal Applications download the
                    contents of a website.</li>
                <li>Unlike the WebRequest and the WebClient classes, an HttpClient only provides asynchronous methods,
                    but can be used in a very similar manner to the WebClient.</li>
                <li>
                    <code>
                        async Task&lt;string&gt; readWebpage(string uri)
                        {
                        HttpClient client = new HttpClient();
                        return await client.GetStringAsync(uri);
                        }
                    </code>
                </li>
            </ul>
            <h4>Exception Handling</h4>
            <ul>
                <li>As with file handling, loading information from the Internet is prone to error. Network connectons
                    may be broken or servers may be unavailable.</li>
                <li>This means web request code should be enclosed in appropriate exception handlers.</li>
            </ul>
        </div>
        <div>
            <h3>Implement Asynchronous I/O Operations</h3>
            <ul>
                <li>When a user has to wait for a synchronous file action to perform it may lead to a very poor user
                    experience.</li>
                <li>File operations provided by the File class do not have any asynchronous versions, so the FileStream
                    class should be used instead.
                    <code>
                        async Task WriteBytesAsync(string filename, byte[] items)
                        {
                        using (FileStream outStream = new FileStream(filename, FileMode.OpenOrCreate, FileAccess.Write))
                        {
                        await outStream.WriteAsync(items, 0, items.Length);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Handling Exceptions in Asynchronous Methods</h4>
            <ul>
                <li>If any exceptions are thrown by the asynchronous file write method they must be caught and a message
                    displayed for the user.</li>
                <li>This will only happen if the WriteBytesAsync method returns a Task object that is awaited when the
                    WriteBytesAsync method is called.
                    <code>
                        private async void StartTaskButton_Click(object sender, RoutedEventArgs e)
                        {
                        byte[] data = new byte[100];

                        try
                        {
                        // This filename contains an invalid character.
                        await WriteBytesAsynctask("demo:.dat", data);
                        }
                        catch (Exception ex)
                        {
                        MessageBox.Show(ex.Message, "File write failed");
                        }
                        }
                    </code>
                </li>
                <li>The only asynchronous methods that should return void are the actual event handlers for the windows
                    controls. Other asynchronous methods must return either a result or a Task, so that any thrown
                    exceptions can be dealt with correctly.</li>
            </ul>
        </div>
        <div>
            <h3>Implement Asynchronous I/O Operations</h3>
            <ul>
                <li>When a user has to wait for a synchronous file action to perform it may lead to a very poor user
                    experience.</li>
                <li>File operations provided by the File class do not have any asynchronous versions, so the FileStream
                    class should be used instead.
                    <code>
                        async Task WriteBytesAsync(string filename, byte[] items)
                        {
                        using (FileStream outStream = new FileStream(filename, FileMode.OpenOrCreate, FileAccess.Write))
                        {
                        await outStream.WriteAsync(items, 0, items.Length);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Handling Exceptions in Asynchronous Methods</h4>
            <ul>
                <li>If any exceptions are thrown by the asynchronous file write method they must be caught and a message
                    displayed for the user.</li>
                <li>This will only happen if the WriteBytesAsync method returns a Task object that is awaited when the
                    WriteBytesAsync method is called.
                    <code>
                        private async void StartTaskButton_Click(object sender, RoutedEventArgs e)
                        {
                        byte[] data = new byte[100];

                        try
                        {
                        // This filename contains an invalid character.
                        await WriteBytesAsynctask("demo:.dat", data);
                        }
                        catch (Exception ex)
                        {
                        MessageBox.Show(ex.Message, "File write failed");
                        }
                        }
                    </code>
                </li>
                <li>The only asynchronous methods that should return void are the actual event handlers for the windows
                    controls. Other asynchronous methods must return either a result or a Task, so that any thrown
                    exceptions can be dealt with correctly.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-2">Skill 4.2: Consume Data</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Retrieve data from a database</li>
            <li>Update date in a database</li>
            <li>Consume JSON and XMl data</li>
            <li>Retrieve data by using web Windows Communication Foundation (WCF)</li>
        </ul>
        <div>
            <h3>Retrieve Data from a Database</h3>
            <h4>Data in a Database</h4>
            <ul>
                <li>The following class contains data members and an integer ID value, which will be used by the
                    database to allow it to uniquely identify each record.
                    <code>
                        public class MusicTrack
                        {
                        public int ID {get; set;}
                        public string Artist {get; set;}
                        public string Title {get; set;}
                        public int Length {get; set;}
                        }
                    </code>
                </li>
                <li>The Entity Framework toolchain uses the class definnition to produce a table in a database that has
                    the required data storage.</li>
                <li>From a data design point of view, a table in a database can be considered as a collection of
                    objects.</li>
            </ul>
            <h4>Read with SQL</h4>
            <ul>
                <li>A database is managed by a server process that accepts commands and acts on them. These commands are
                    given in the SQL (Structured Query Language) format.</li>
                <li>SQL dates back to the 1970's and is called a domain specific language because it is used solely for
                    expressing commands to control a database.</li>
                <li>The asterisk "*" character in SQL is a wildcard that matches all the entries in the table.</li>
                <li>The following command will read all the records from a given table:
                    <code>
                        SELECT * FROM TableName
                    </code>
                </li>
                <li>A program uses an SQL database in a similar way to a stream. It creates an object that represents a
                    connection to the database and sends SQL commands to it.</li>
                <li>The DbConnection is an abstract class that represents a connection to a database and describes
                    behaviours of the connection in the same way that the Stream class is also abstract and describes
                    the behaviours of streams.</li>
                <li>The SqlConnection class is a child of the DbConnection class and represents the implementation of a
                    connection to a SQL database.</li>
                <li>The SqlConnection constructor needs a connection string that identifies the datavase that is to be
                    opened.</li>
                <li>A connection string contains a number of items expressed as name-value pairs. For a server on a
                    remote machine the string will contain the address of the server, the port on which the server is
                    listening and a username/password pair that can authenticate the connection.</li>
                <li>In this example I connect to a database, create an SQL query, execute it and read and print the
                    information:
                    <code>
                        static void Main(string[] args)
                        {
                        string connectionString = "Server=(localdb)\\mssqllocaldb;" +
                        "Database=DatabaseName;" +
                        "Trusted_Connection=True;MultipleActiveResultSets=true";

                        using (SqlConnection connection = new SqlConnection(connectionString))
                        {
                        connection.Open();
                        SqlCommand command = new SqlCommand("SELECT * FROM TableName", connection);
                        SqlReader reader = command.ExecuteReader();
                        while (reader.read())
                        {
                        string artist = reader["Artist"].ToString();
                        string title = reader["Title"].ToString();

                        Console.WriteList("Artist: {0} Title: {1}", artist, title);
                        }
                        }
                        Console.ReadKey();
                        }
                    </code>
                </li>
                <li>It is important that a connection string is not hard-coded. Otherwise, anyone obtaining the source
                    code of the program can view the connection string and will get accdess to the database.</li>
                <li>Anyone obtaining the compiled version of the program can use a tool such as ildasm to view the MSIL
                    code and extract the connection.</li>
                <li>You would also have to change the code, recompile it, and publish it, if you want to change the
                    connection string.</li>
            </ul>
            <h4>Connection String Management in ASP.NET</h4>
            <ul>
                <li>The database connection strings in ASP.NET applications are stored in the configuration files.
                    Usually, this file is the web.config, app.config, or appsettings.json file.</li>
                <li>The ConnectionStrings element in the settings file contains the connection strings for all the data
                    contexts used in the program.</li>
                <li>The setting information in a solution can contain the descriptions of environments that are to be
                    used for development and production deployments of an application.</li>
                <li>The setting information to be used is when a server is started and determined by an environment
                    variable on the computer that is tested when the program starts running. There are 2 contexts in
                    which the word environment is being used:
                    <ul>
                        <li>An ASP applicaiton environment determines the settings for logging, tracing, and debugging,
                            and the database connection string that will be in force when the ASP application runs on a
                            machine. A developer can also create their own settings values that can be used to give them
                            more control over a particular environment.</li>
                        <li>An environment variable is a value that is maintained by the OS and can be used by processes
                            running on the machine. Environment variables managed by Windows 10 include the name of the
                            machine and the file paths to be used to search for programs. The system environment
                            variable ASPNETCORE_ENVIRONMENT can be set to values that determine which environment an ASP
                            application will select when it starts running.</li>
                    </ul>
                </li>
                <li>In older ASP.NET applications the SQL settings are held in the web.config file, which is part of the
                    solution. Developers then use XML transformations to override settings in the file to allow
                    different SQl servers to be selected.</li>
            </ul>
            <h4>SQL Query Operation</h4>
            <ul>
                <li>A program can make a query of a database by creating an SqlCommand instance. The constructor for it
                    takes an SQL command in the form of a string and a database connection.</li>
                <li>In this example the query is executed as a reader command:
                    <code>
                        SqlCommand command = new SqlCommand("SELECT * FROM TableName", connection);
                        SqlCommand command = ne SqlCommand("SELECT * FROM TableName", connection);
                    </code>
                </li>
                <li>The SqlReader provides methods that can be used to move through the results returned by the query.
                    It is only possible to move forward through the results.</li>
                <li>The Read method returns false when there are no more results.</li>
                <li>Individual items in the element can be accessed using their name:
                    <code>
                        while(reader.read())
                        {
                        string artist = reader["Artist"].ToString();
                        string title = reader["Title"].ToString();

                        Console.WriteLine("Artist: {0} Title: {1}", artist, title);
                        }
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Update Data In A Database</h3>
            <ul>
                <li>An SQL UPDATE command will update the contents of a database.</li>
                <li>Specific records in a table can be targeted by identifying them with the WHERE clause.</li>
                <li>
                    <code>
                        using (SqlConnection connection = new SqlConnection(connectionString))
                        {
                        connection.Open();
                        dumpDatabase(connection);
                        SqlCommand command = new SqlCommand("UPDATE TableName SET FieldName='newValue' WHERE ID IN
                        (1,4,5);", connection);
                        int result = command.ExecuteNonQuery();
                        Console.WRiteLine("Number of entries updated: {0}", result);
                        dumpDatabase(connection);
                        }
                    </code>
                </li>
            </ul>
            <h4>SQL Injection and Database Commands</h4>
            <ul>
                <li>You can allow a user to enter values which can be used in the SQL query but this is very dangerous.
                    They could easily delete data with SQL injecton.</li>
                <li>SQL injection is where a malicious user injects SQL commands into the code, often via input fields
                    whose values are used to construct an SQL command.</li>
                <li>You should never construct SQL commands directly from user input. You must use parameterized SQL
                    statements instead.</li>
                <li>This example shows how to use parameterized SQL statements:
                    <code>
                        string sqlCommandText = "UPDATE TableName SET FieldNameA=@newValue WHERE
                        FieldNameB=@searchValue";

                        SqlCommand command = new SqlCommand(sqlCommandText, connection);
                        command.Parameters.AddWithValue("@newValue", newValue);
                        command.Parameters.AddWithValue("@searchValue", searchValue);
                    </code>
                </li>
            </ul>
            <h4>Asynchronous Database Access</h4>
            <ul>
                <li>There are asynchronous versions of all the methods used above.</li>
                <li>These methods used in conjunction with the async/await mechanisms allow a program to run database
                    queries asynchronously.</li>
                <li>This is particularly important if your program is interacting with the user via a windowed
                    interface.</li>
                <li>The dumpDatabase nethod uses asynchronous database commands to create a listing of the contents of a
                    database. It is part of a WPF (Windows Presentation Foundation) application that also allows
                    database editing.
                    <code>
                        async Task &lt;string&gt; dumpDatabase(SqlConnection connection)
                        {
                        SqlCommand command = new SqlCommand("SELECT * FROM MusicTrack", connection);
                        SqlDataReader reader = await command.ExecuteReaderAsync();
                        StringBuilder databaseList = new StringBuilder();
                        while(await reader.ReadAsync())
                        {
                        string id = reader["ID"].ToString();
                        string artist = reader["Artist"].ToString();
                        string title = reader["Title"].ToString();

                        string row = string.Format("ID: {0} Artist: {1} Title: {2}", id, artist, title);
                        databaseList.AppendLine(row);
                        }
                        return databaseList.ToString();
                        }
                    </code>
                </li>
            </ul>
            <h4>Using SQL in ASP Applications</h4>
            <ul>
                <li>You won't find any SQL commands in the code that implement the controller classes for ASP
                    applications.</li>
                <li>This is due to database updates in ASP applications being performed using an Update method that
                    accepts a modified instance of the class to be updated.</li>
                <li>In this example the code updates the database and catches any exceptions that may be thrown:
                    <code>
                        try
                        {
                        _context.Update(record); // Update the database context with the edited track.
                        await _context.SaveChangesAsync(); // Save all the changes.
                        }
                        catch(DbUpdateConcurrencyException)
                        {
                        // Deal with exceptions.
                        }
                    </code>
                </li>
                <li>ASP applications use embedded C# code in the web page (Razor) which iterates through the database
                    contents and presents a view of the data.</li>
                <li>In this example is the index.cshtml file for a MusicTrack:
                    <code>
                        &lt;tr&gt;
                        &lt;td&gt;
                        @Html.DisplayFor(modelItem => item.Artist)
                        &lt;/td&gt;
                        &lt;td&gt;
                        @Html.DisplayFor(modelItem => item.Title)
                        &lt;/td&gt;
                        &lt;td&gt;
                        @Html.DisplayFor(modelItem => item.Length)
                        &lt;/td&gt;
                        &lt;td&gt;
                        &lt;a asp-action="Edit" asp-route-id="@item.ID"&gt;Edit&lt;/a&gt; |
                        &lt;a asp-action="Details" asp-route-id="@item.ID"&gt;Details&lt;/a&gt; |
                        &lt;a asp-action="Delete" asp-route-id="@item.ID"&gt;Delete&lt;/a&gt;
                        &lt;/td&gt;
                        &lt;/tr&gt;
                    </code>
                </li>
        </div>
        <div>
            <h3>Consume JSON and XML Data</h3>
            <h4>Consume JSON Data</h4>
            <ul>
                <li>JSON (JavaScript object Notation) is a means by which applications can exchange data.</li>
                <li>A JSON document is a plain text file that contains a structured collection of and value pairs.</li>
                <li>JSON files can be read and written using the Newtonsoft.Json library.</li>
                <li>In this example the program consumes a JSON feed provided by NASA. It's updated every daya with new
                    pictures or videos from the NASA archives:
                    <code>
                        public class ImageOfDaya
                        {
                        public string date {get; set;}
                        public string explanation {get; set;}
                        public string hdurl {get; set;}
                        public string media_type {get; set;}
                        public string service_version {get; set;}
                        public string title {get; set;}
                        public string url {get; set;}
                        }

                        async Task&lt;ImageOfDay&gt; GetImageOfDay(String imageUrl)
                        {
                        string NASAJson = await readWebpage(imageUrl);
                        ImageOfDay result = JsonConvert.DeserializeObject&lt;ImageOfDay&gt;(NASAJson);
                        return result;
                        }
                    </code>
                </li>
                <li>For this to work the ImageOfDay class had to be created which exactly matches the object described
                    in the JSON feed from NASA.</li>
                <li>This can be done using http://json2csharp.com which accepts a web address that returns a JSON
                    document and then automatically generates a C# class as described by the doucment.</li>
                <li>In this example the code displays the image when the user clicks a button to perform the load. In
                    this case it'll always display the same image but could easily be updated to display the image for a
                    particular day:
                    <code>
                        private async void LoadButtonClickedObject(object sender, RoutedEventArgs e)
                        {
                        try
                        {
                        ImageOfDay imageOfDay = await
                        getImageOfDay("https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&date=2018-05-29");

                        if(imageOfDay.media_type != "image")
                        {
                        MessageBox.Show("It is not an image today");
                        return;
                        }

                        DescriptionTextBlock.Text = imageOfDay.explanation;

                        await displayUrl(imageOfDay.url);
                        }
                        catch (Exception ex)
                        {
                        MessageBox.Show("Fetch failed: {0}", ex.Message);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Consume XML Data</h4>
            <ul>
                <li>XML is slightly more expressive than JSON, but XML documents are larger than equivalent JSON
                    documents, and this, along with the ease of JSON, has led to JSON replacing XML. However, a lot of
                    information is still expressed ussing XML.</li>
                <li>The System.XML namespace contains a set of classes for working with XML documents. The XMLTextReader
                    class works through a stream of text and decodes each XML element in turn:
                    <code>
                        using (StringReader stringReader = new StringReader(XMLDocument))
                        {
                        XmlTextReader reader = new XmlTextReader(stringReader);

                        while (reader.Read())
                        {
                        string description = string.Format("Type:{0} Name:{1} Value:{2}",
                        reader.NodeType.ToString(),
                        reader.Name,
                        reader.Value);
                        Console.WriteLine(description);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>XML Documents</h4>
            <ul>
                <li>It is possible to read information from an XML document by decoding each individual element, but
                    this can be hard work to code.</li>
                <li>An easier approach is to use an XMLDocument instance. This creates a DOM (Document Object Model) in
                    memory from which data can be extracted.</li>
                <li>An advantage of a DOM is that a program can change elements in the DOM and then write out a modified
                    copy of the document incorporating the change:
                    <code>
                        XmlDocument doc = new XmlDocument();
                        doc.LoadXml(XMLDocument);

                        System.Xml.XmlElement rootElement = doc.DocumentElement;
                        // Make sure it is the right element.
                        if (rooElement.Name != "MusicTrack")
                        {
                        Console.WriteLine("Not a music track");
                        }
                        elements
                        {
                        string artist = rootElement["Artist"].FirstChild.Value;
                        string title = rootElement["Title"].FirstChild.Value;
                        Console.WriteLine("Arist:{0} Title:{1}", artist, title);
                        }
                    </code>
                </li>
                <li>An XmlDocument contains a hierarchy of items with a rootElement object at the top of the hierarchy.
                </li>
                <li>These items can be accessed in an element by using a string indexer that contains the name of the
                    required item.</li>
            </ul>
        </div>
        <div>
            <h3>Retrieve Data by Using Windows Communication Foundation (WCF)</h3>
            <ul>
                <li>The NASA image reader works by converting a response from a server into an instance of a class that
                    contains a description of the image and the web address from which the image can be downloaded.</li>
                <li>To read information provided by the NASA server, a client program contains a C# class that matches
                    the JSON document that is received from the server.</li>
                <li>A client of a web service also uses an instance of an object to interact with a server. However, in
                    this case, the client can call methods on the object to read data and also update information on the
                    server.</li>
                <li>The object that is created is a "proxy object". A call to a method of the proxy object will cause a
                    request to be create that is sent to the service on the server.</li>
                <li>When the server receives the request, it will then call the method in a server object. The result
                    which is returned by the method is packaged up into another network message, which is sent back to
                    the client and then sends the return value back to the calling software.</li>
                <li>The service also exposes a description of the methods that it provides. These are used by the
                    development tool to actually create the proxy object in the client program. Meaning you can easily
                    create a client application.</li>
            </ul>
            <h4>Create a Web Service</h4>
            <ul>
                <li>As an example, we'll create a 'Joke of the Day' service. It'll return a string containing a joke on
                    request from the client. The user will be able to select the "strength" of the joke, ranging from 0
                    to 2 where 0 is mildly amusing and 2 is a guaranteed ROFL experience.</li>
                <li>The application is made up of 2 parts: the server program that exports the service, and the client
                    program that uses it.</li>
                <li>The server is created as a WCF (Windows Communication Foundation) Service application.</li>
                <li>The client will be an application that connects to the service and requests a joke.</li>
                <li>The attributes [ServiceContract] and [OperationContract] denote that the interface and method are to
                    be exposed as services.</li>
                <li>
                    <code>
                        using System.ServiceModel;

                        namespace JokeOfTheDay
                        {
                        [ServiceContract]
                        public interface IJokeOfTheDayService
                        {
                        [OperationContract]
                        string GetJoke(int jokeStrength);
                        }
                        }
                    </code>
                </li>
                <li>Once you have the interface you now need a class that implements the method:
                    <code>
                        public class JokeOfTheDayService : IJokeOfTheDayService
                        {
                        public string GetJoke(int jokeStrength)
                        {
                        string result = "Invalid strength";
                        switch(jokeStrength)
                        {
                        case 0:
                        result = "Knock knock. Who's there? Oh, you've heard it.";
                        break;
                        case 1:
                        result = "What's green and hairy and goes up and down? A gooseberry in a lift.";
                        break;
                        case 2:
                        result = "A horse walks into a bar and the barman asks 'Why the long face?'.";
                        break;
                        }
                        return result;
                        }
                        }
                    </code>
                </li>
                <li>If you create a service you can use the WCF Test Client to inboke the methods and view the results.
                </li>
                <li>You can also view the service description in a browser. This gives you a link to the service
                    description, as well as some sample code that shows how to use it.</li>
            </ul>
            <h4>Create a Web Client</h4>
            <ul>
                <li>The client application can run on any machine that has a network connection and wants to consume the
                    service.</li>
                <li>The client application needs to contain a connection to the JokeOfTheDayService which is added to
                    the client Visual Studio project like any other references.</li>
                <li>Once done, you'll see a panel that displays the JokeOfTheDayService only provides one method and you
                    can also change the namespace used to access it on the client.</li>
                <li>The client must now create a proxy object that will be used to invoke the methods in the service:
                    <code>
                        using System;
                        using JokeClient.JokeService;

                        namespace JokeClient
                        {
                        class program
                        {
                        static void Main(string[] args)
                        {
                        using (JokeOfTheDayServiceClient jokeClient = new JokeOfTheDayServiceClient())
                        {
                        Console.WriteLine(jokeClient.GetJoke(1));
                        }
                        Console.ReadKey();
                        }
                        }
                        }
                    </code>
                </li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-3">Skill 4.3: Query and Manipulate Data and Objects by Using LINQ</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Query data by using operators, including projection, join, group, take, skip, and aggregate</li>
            <li>Create method-base LINQ queries</li>
            <li>Query data by using query comprehension syntax</li>
            <li>Select data by using anonymous types</li>
            <li>Force execution of a query</li>
            <li>Read, filter, create, and modify data structures by using LINQ to XML</li>
        </ul>
        <div>
            <h3>Query Data by Using Operators, Including Projection, Join, Group, Take, Skip, and Aggregate</h3>
            <h4>Use an Object Initializer</h4>
            <ul>
                <li>Object initializer syntax is used to create new instances of record objects and to initialize thei
                    values at the same time.</li>
                <li>This is a very useful C# feature that allows you to initialize objects when they are created without
                    the need to create a consturctor method in the class being initialized.</li>
                <li>In this example the statement creates and initializes a new MusicTrack instance where the braces
                    delimit the items that initialize the instance:
                    <code>
                        MusicTrack newTrack = MusicTrack
                        {
                        Artist = "Rob Miles",
                        Title = "My Way",
                        Length = 150
                        };
                    </code>
                </li>
                <li>Any properties not initialized are set to their default values (0 for numeric values and null for
                    strings).</li>
                <li>Properties initialized this way must be made public members of the class.</li>
            </ul>
            <h4>Use a LINQ Operator</h4>
            <ul>
                <li>In this xample, the first statement uses a LINQ query to create an enumerable collection of
                    MusicTracks, which is then enumerated by the foreach construction to print the results:
                    <code>
                        IEnumberable&lt;MusicTrack&gt; selectedTracks = from track in musicTracks where track.Arist.Name
                        == "Rob Miles" select track;
                        foreach (MusicTrack track in selectedTracks)
                        {
                        Console.WriteLine("Artist:{0} Title:{1}", track.Artist.Name, track.Title);
                        }
                    </code>
                </li>
            </ul>
            <h4>Use the var Keyword with LINQ</h4>
            <ul>
                <li>C# is statically typed. Meaning, the type of objects in a program is determined at compile time and
                    the compiler rejects any actions that are not valid.</li>
                <li>This means that the following code fails to compile because the compiler will not allow strings to
                    be subtracted from numbers:
                    <code>
                        string name = "Rob Miles";
                        int age = 21;
                        int silly = age - name;
                    </code>
                </li>
                <li>This increases our confidence in our programs being correct when they run, but does involve going
                    through extra effort to give each variable a type when you declare it.</li>
                <li>The above code can be simplified by using the car keyword to tell the compiler to infer the type of
                    variable being created from the context in which the variable is used:
                    <code>
                        var name = "Rob Miles";
                    </code>
                </li>
                <li>This does not mean that the compiler cannot detect compilation errors. The example earlier will
                    still fail to compile.</li>
                <li>The var keyword is especially useful when using LINQ as the result of a simple LINQ query is an
                    enumerable colection of the type of data element held in the data source:
                    <code>
                        var selectedTracks = from track in musicTracks where track.Arist.Name == "Rob Miles" select
                        track;
                    </code>
                </li>
                <li>There are some situations where you won't know the type of a variable when writing the code. These
                    are called anonymous types and the only way to refer to these is by use of variables of type var.
                </li>
                <li>You can use var everywhere in your code but you won't be popular with other devs as they'll have to
                    infer the type of variable by diging through the code. When you do use it, make sure the type can be
                    inferred easily by the variable name.</li>
            </ul>
            <h4>LINQ Projection</h4>
            <ul>
                <li>The select operation in LINQ can be used to produce a filtered version of a data source.</li>
                <li>Projection can be used to ask a query to "project" the data in the class onto new instaces of a
                    class created just to hold the data returned by the query.</li>
                <li>In this example the query is asked to create a new instance of the TrackDetails class to hold the
                    result of each query.
                    <code>
                        class TrackDetails
                        {
                        public string ArtistName;
                        public string Title;
                        }

                        var selectedTracks = from track in musicTracks
                        where track.Arist.Name == "Rob Miles"
                        select new TrackDetails
                        {
                        ArtistName = track.Artist.Name,
                        track.Title
                        };

                    </code>
                </li>
            </ul>
            <h4>Anonymous Types</h4>
            <ul>
                <li>You can remove the need to create a class to hold the result of a search query by making the query
                    return results of an anonymous type:
                    <code>
                        var selectedTracks = from track in musicTracks
                        where track.Arist.Name == "Rob Miles"
                        select new // Project type name missing from here.
                        {
                        ArtistName = track.Artist.Name,
                        track.Title
                        };
                    </code>
                </li>
                <li>Instances of the new type are initialized using the object initializer syntax.</li>
                <li>The item that is returned by this query is an enumerable collection of instances of a type that has
                    no name. It is anonymous. You have to use a var reference to refer to the query result.</li>
                <li>You can iterate through the collection in this result as your would any other, but each item must
                    also be referred to using a var:
                    <code>
                        foreach (var item in selectedTracks)
                        {
                        console.WriteLine("Artist:{0} Title:{1}", item.ArtistName.Name, item.Title);
                        }
                    </code>
                </li>
            </ul>
            <h4>LINQ Join</h4>
            <ul>
                <li>The MusicTrack and Artist classes used in prior examples use C# references to implement the
                    associations between the objects in the system.</li>
                <li>If you store your data in a database, you will not be able to store the associations in this way.
                </li>
                <li>Instead, each item in the database will have a unique ID (its primary key) and objects referring to
                    this object will contain this ID value (a foreign key).</li>
                <li>Rather than a reference to an Artist instance the MusicTrack now contains an ArtistID field that
                    identifies the artist associated with that track.</li>
                <li>This design makes it slightly more difficult to search for tracks by a particular artist. The
                    progrma needs to find the ID value for the artist with the name being searched for an then search
                    for an tracks with that value of artist ID.</li>
                <li>Fortunately, LINQ provides a join operator that can be used to join the output of on LINQ query to
                    the input of another:
                    <code>
                        var artistTracks = from artist in artists where artist.Name == "Rob Miles"
                        join track in musicTracks on artist.ID equals track.ArtistID
                        select new
                        {
                        ArtistName = artist.Name,
                        track.Title
                        };
                    </code>
                </li>
            </ul>
            <h4>LINQ Group</h4>
            <ul>
                <li>Another useful LINQ feature is the ability to group the results of a query to create a summary
                    output. Such as a query to tell how many tracks there are by each artist in the music collection.
                </li>
                <li>The group action is given the data item to group by and the property by which it is to be grouped.
                </li>
                <li>The artistTrackSummary contains an entry for each different artist. Each of the items i the summary
                    has a Key property, which is th value that item is "grouped" around:
                    <code>
                        var artistTracks = from track in musicTracks
                        group track by track.ArtistID
                        into artistTrackSummary
                        select new
                        {
                        ID = artistTrackSummary.Key,
                        Count = artistTrackSummary.Count()
                        };

                        foreach (var item in artistSummary)
                        {
                        Console.WriteLine("Artist:{0} Tracks recorded:{1}", item.ID, item.Count);
                        }
                    </code>
                </li>
                <li>The issue with this query is that rather than the name of the Artist in displays their ID. This can
                    be resolved with the use of a join operation:
                    <code>
                        var artistTracks = from track in musicTracks
                        join artist in artists on track.ArtistID equals artist.ID
                        group track by artist.Name
                        into artistTrackSummary
                        select new
                        {
                        ID = artistTrackSummary.Key,
                        Count = artistTrackSummary.Count()
                        };
                    </code>
                </li>
            </ul>
            <h4>LINQ Take and Skip</h4>
            <ul>
                <li>A LINQ query will normally return all of the items that it finds. However, this might be more items
                    than your program wants.</li>
                <li>You might want to show the user the output one page at a time. You can use take to tell the query to
                    take a particular number of items and the skip to tell a query to skip a particular number of items
                    in the result before taking the requested number.</li>
                <li>In this example the program displays all of the music tracks ten items at a time:
                    <code>
                        int pageNo = 0;
                        int pageSize = 10;

                        while(true)
                        {
                        // Get the track information.
                        var trackList = from musicTrack in musicTracks.Skip(pageNo*pageSize).Take(pageSize)
                        join artist in artists on musicTrack.ArtistID equals artist.ID
                        select newTrack
                        {
                        ArtistName = artist.Name,
                        Title = musicTrack.title
                        };

                        // Quit if we reached the end of the data.
                        if (trackList.Count() == 0)
                        break;

                        // Display the query result.
                        foreach (var item in trackList)
                        {
                        Console.WriteLine("Artist:{0} Title:{1}", item.ArtistName, item.Title);
                        }

                        Console.WriteLine("Press any key to continue!");
                        Console.ReadKey();

                        // Move on to the next page.
                        pageNo++;
                        }
                    </code>
                </li>
            </ul>
            <h4>LINQ Aggregate Commands</h4>
            <ul>
                <li>In the context of LINQ commands, the word aggregate means "bring together a number of related values
                    to create a single result".</li>
                <li>You can use aggregate operators on the results produced by group operations. </li>
                <li>In this example the Sum operator is used to get the length of all tracks assigned to an artist:
                    <code>
                        var artistSummary = from track in musicTracks]
                        join artist in artists on track.ArtistID equals artist.ID
                        group track by artist.Name
                        into artistTrackSummary
                        select new
                        {
                        ID = artistTrackSummary.Key,
                        Length = artistTrackSummary.Sum(x => x.Length)
                        };
                    </code>
                </li>
                <li>The Average, Max, and Min operations can also be used to generate other items of aggregate
                    information.</li>
                <li>You can also create your own Aggregate behaviour that will be called on each successive item in the
                    group and will generate a single aggregate result.</li>
            </ul>
        </div>
        <div>
            <h3>Create Method-base LINQ Queries</h3>
            <ul>
                <li>The first LINQ query we looked at was this:
                    <code>
                        IEnumberable&lt;MusicTrack&gt; selectedTracks = from track in musicTracks where track.Arist.Name
                        == "Rob Miles" select track;
                    </code>
                </li>
                <li>The query statements uses query comprehension syntax, which includes the operators from, in, where,
                    and select.</li>
                <li>The compiler uses these to generate a call to the Where method on the MusicTracks collections.</li>
                <li>This query can also be written using the Where method which accepts a lambda expression as a
                    parameter:
                    <code>
                        IEnumberable&lt;MusicTrack&gt; selectedTracks = musicTracks.Where(track => track.Artist.Name ==
                        "Rob Miles");
                    </code>
                </li>
                <li>Programs can use the LINQ query methods on data collections such as lists and arrays, and also on
                    database connections.</li>
                <li>The methods that implement LINQ query behaviours are not added to the classes that use them.
                    Instead, they are implemented as extension methods.</li>
            </ul>
        </div>
        <div>
            <h3>Query Data by Using Query Comprehension Syntax</h3>
            <ul>
                <li>The phrase "query comprehension syntax" refers to the way that you can build LINQ queries using the
                    C# operators provided specifically for expressing data queries.</li>
                <li>The intention is to make the C# statements that strong resemble the SQL queries that peform the same
                    function to make it easier for develoeprs familiar with SQL syntax to use LINQ.</li>
                <li>The LINQPad application that allows programmers to create LINQ queries and view the SQL and
                    method-based implementations.</li>
                <li>The standard edition is a very powerful resource for develoeprs and can be downloaded for free from
                    http://www.linqpad.net/.</li>
            </ul>
        </div>
        <div>
            <h3>Select Data by Using Anonymous Types</h3>
            <ul>
                <li>You can also create anonymous type instances in method-based SQL queries.</li>
                <li>In this example an intermediate anonymous class is used to implement the join between the two
                    queries and generates objects that contains artist and track information:
                    <code>
                        var artistSummary = MusicTracks.Join(
                        Artists,
                        track => track.ArtistID,
                        artist => artist.ID,
                        (track, artist) =>
                        new
                        {
                        track = track,
                        artist = artist
                        }
                        )
                        .GroupBy(
                        temp0 => temp0.artist.Name,
                        temp0 => temp0.track
                        )
                        .Select(
                        artistTrackSummary =>
                        new
                        {
                        ID = artistTrackSummary.Key,
                        Length = artistTracks.Sum(x => x.Length)
                        }
                        );
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Force Execution of a Query</h3>
            <ul>
                <li>The result of a LINQ query is an item that can be iterated.</li>
                <li>In previous examples we've used the foreach construction to display the results from queries.</li>
                <li>The actual evaluation of a LINQ query normally only takes place when a program starts to extract
                    results from the query. this is called deferred execution.</li>
                <li>If you want to force the execution of a query you can use the ToArray() method:
                    <code>
                        var artistTracksQuery = from artist in artists
                        where artist.Name == "Rob Miles"
                        join track in musicTracks on artist.ID equals track.ArtistID
                        select new
                        {
                        ArtistName = artist.Name,
                        Title = track.Title
                        };

                        var artistTrackResult = artistTracksQuery.ToArray();

                        foreach (var item in artistTrackResult)
                        {
                        Console.WriteLine("Artist:{0} Title:{1}", item.ArtistName, item.Title);
                        }
                    </code>
                </li>
                <li>A query result also provides ToList and ToDictionary methods that will force the execution of the
                    query and generate an immediate result of that type.</li>
                <li>If a query returns a singleton value (the result of an aggregation operation such as sum or count)
                    it will be immediately evaluated.</li>
            </ul>
        </div>

        <div>
            <h3>Read, Filter, Create, and Modify Data Structures by Using LINQ to XML</h3>
            <h4>Read XML with LINQ to XML and XDocument</h4>
            <ul>
                <li>The XMLDocument class has be superseded in later versions of .NET (3.5 onwwards) by the XDocument
                    class, which allows the use of LINQ queries to parse XML files.</li>
                <li>A program can create an XDocument instance that represents the earlier document by using the Parse
                    method provided by the XDocument class:
                    <code>
                        XDocument musicTracksDocument = XDocument.Parse(XMLText);
                    </code>
                </li>
                <li>The format of LINQ queries is slightly different when working with XML because the source of the
                    query is a filtered set of XML entries from the source document.</li>
                <li>The result of the query is an enumeration of XElement items that have been extracted from the
                    document.</li>
                <li>The XElement class is a development of the XMLElement class that includes XML behaviours.</li>
                <li>
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks = from track in
                        musicTracksDocument.Descendants("MusicTrack") select track;

                        foreach (XElement item in selectedTracks)
                        {
                        Console.WriteLine("Artist:{0} Title:{1}", item.Element("Artist").FirstNode,
                        item.Element("Title").FirstNode);
                        }
                    </code>
                </li>
            </ul>
            <h4>Filter XML Data with LINQ to XML</h4>
            <ul>
                <li>A program can perform filtering in the query by adding a where operator, just as with the LINQ
                    before:
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks = from track in
                        musicTracksDocument.Descendants("MusicTrack")
                        where (string) track.Element("Artist") == "Rob Miles"
                        select track;
                    </code>
                </li>
                <li>It is also possible to express the same query in a method-based form:
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks =
                        musicTracksDocument.Descendants("MusicTrack").Where(element => (string)element.Element("Artist")
                        == "Rob Miles");
                    </code>
                </li>
            </ul>
            <h4>Create XMl with LINQ to XML</h4>
            <ul>
                <li>The LINQ to XML features include very easy ways to create XML documents. Note the arragements of the
                    constructor calls to each XElement item mirror the structure of the document:
                    <code>
                        XElement musicTracks = new XElement("MusicTracks",
                        new List&lt;XElement&gt;
                        {
                        new XElement("MusicTrack",
                        new XElement("Artist", "Rob Miles"),
                        new XElement("Title", "My Way")),
                        new XElement("MusicTrack",
                        new XElement("Artist", "Immy Brown"),
                        new XElement("Title", "Her Way"))
                        }
                        );
                    </code>
                </li>
            </ul>
            <h4>Modify Data with LINQ to XML</h4>
            <ul>
                <li>The XElement class provides methods that can be used to modify the contents of a given XML element.
                </li>
                <li>In this example all the records with a particular title are found and updated to show the correct
                    title:
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks = from track in
                        musicTracksDocument.Descendants("MusicTrack"
                        where track.Element("Title") == "my Way"
                        select track;

                        foreach (XElement item in selectedTracks)
                        {
                        item.Element("Title").FirstNode.ReplaceWith("My Way");
                        }
                    </code>
                </li>
                <li>As with when creating a new XML document, an XElement can contain a collection of other elements to
                    build the tree structure of an XML document.</li>
                <li>You can programatically add and remove elements to change the structure of the XML document:
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks = from track in
                        musicTracksDocument.Descendants("MusicTrack"
                        where track.Element("Style") == null
                        select track;

                        foreach (XElement item in selectedTracks)
                        {
                        item.Add(new XElement("Style", "Pop"));
                        }
                    </code>
                </li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-4">Skill 4.4: Serialize and Deserialize Data by Using Binary and Custom Serialization, and XML,
            JSON and Data Contract Serializer</h2>
        <ul>
            <li>Serialiation does not store any of the active elements in an object. The behaviours (methods) in a class
                are not stored when it is serialized.</li>
            <li>This means the application deserializing the data must have impementations of the classes that can be
                used to manipulate the data after it has been read.</li>
            <li>Serialization is a complex process. If a data strcture contains a graph of objects that have a large
                number of associations between them, the serialization process will have to persist each of these
                associations in the stored file.</li>
            <li>It is best used for transporting data between applicaitons. You can think of it as transferring the
                "value" ov an object from one place to another.</li>
            <li>Serialization can be used for persisting data, and a serialized stream can be directed into a file, but
                this is not normally how applications store their state.</li>
            <li>It can lead to problems if the structure or behaviour of the classes implementing the data storage
                changes during the lifetime of the application.</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>Use and manage versions with binary serialization</li>
            <li>Use custom serialization</li>
            <li>Use the XML and JSON serializers</li>
            <li>Use the data contract serializer</li>
        </ul>
        <div>
            <h3>Use and Manage Versions with Binary Serialization</h3>
            <h4>Use Binary Serialization</h4>
            <ul>
                <li>There are essentially 2 types of serialization a program can use: binary serialization and text
                    serialization.</li>
                <li>Binary serialization imposes its own format on the data that is being serialized, mapping the data
                    onto a stream of 8-bit values.</li>
                <li>The data in a stream created by a binary serializer can only be read by a corresponding binary
                    de-serializer. Binary serialization can provide a complete "snapshot" of the source data.</li>
                <li>Both public and private data in an object will be serialized, and the type of each data item is
                    preserved.</li>
                <li>Classes to be serialized by the binary serializer must be marked with the [Serializable] attribute:
                    <code>
                        [Serializable]
                        class Artist
                        {
                        public string Name {get; set;}
                        }
                    </code>
                </li>
                <li>The binary serialization classes are held in the System.Runtime.Serialization.Formatters.Binary
                    namespace.</li>
                <li>This example shows how binary serialization is performed:
                    <code>
                        MusicDataStore musicData = MusicDataStore.TestData();

                        BinaryFormatter formatter = new BinaryFormatter();
                        using (FileStream outputStream = new FileStream("MusicTracks.bin", FileMode.OpenOrCreate,
                        FileAccess.Write))
                        {
                        formatter.Serialize(outputStream, musicData);
                        }
                    </code>
                </li>
                <li>An instance of the BinaryFormatter class also provides a behaviour called Deserialize that accepts a
                    stream and returns an object that is has deserialized from that stream.</li>
                <li>In this example the code uses a cast to convert the object returned by the Deserialize method:
                    <code>
                        MusicDataStore inputData;

                        using (FileStream inputStream = new FileStream("MusicTracks.bin", FileMode.Open,
                        FileAccess.Read))
                        {
                        inputData = (MusicDataStore)formatter.Deserialize(inputStream);
                        }
                    </code>
                </li>
                <li>If there are data elements in a class that should not be stored, they can be marked with the
                    [NonSerialized] attribute:
                    <code>
                        [Serializable]
                        class Artist
                        {
                        public string Name {get; set;}
                        [NonSerialized]
                        int tempData;
                        }
                    </code>
                </li>
                <li>Binary serialization is the only serialization technique that serializes private data members by
                    default.</li>
                <li>However, once an object has serialized there is nothing to stop a devious programmer from working
                    with serialized data, perhaps viewing and tampering with the values inside it.</li>
                <li>A program should treat deserialized inputs with suspicion. Furthermore, any security sensitive
                    information in a class should be explicitly marked NonSerialized.</li>
                <li>Another way to improve security of a binary serialized file is to encrypt the stream before it is
                    stored, and decrypt it before deserialization.</li>
            </ul>
            <h4>Manage Versions with Binary Serialization</h4>
            <ul>
                <li>The OnDeserializing method can be used to set values of fields that might not be present in data
                    that is being read from a serialized document. This can be used to manage versions.</li>
                <li>Say you added a new field to a class, this causes a problem when the program tries to deserialize
                    old data without this information.</li>
                <li>You can address this by marking the new field with the [OptionalField] attribute and then setting a
                    default value for this element in the OnDeserializing method.</li>
                <li>The OnDeserializing method is performed during deserialization. The method is called before the data
                    for the object is deserialized and can set default values for fields:
                    <code>
                        [Serializable]
                        class MusicTrack
                        {
                        public string Artist {get; set;}
                        public string Title {get; set;}
                        public int Length {get; set;}

                        [OptionalField]
                        public string Style;

                        [OnDeserializing()]
                        internal void OnDeserializingMethod(StreamingContext context)
                        {
                        Style = "Unknown";
                        }
                        }
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Use Custom Serialization</h3>
            <ul>
                <li>Sometimes it might be necessary for code in a class to get control during the serialization process.
                    Perhaps for checking information, encryption to data elements, or custom compression of data.</li>
                <li>The first way to do this is to create your own implementation of the serialization process by making
                    a data class implement the ISerializable interface.</li>
                <li>A class that implements the ISerializable interface must contain a GetObjectData method which gets
                    called when an object is serialized.</li>
                <li>It takes data out of the object and places it into an object stream. The class must also contain a
                    constructor that will initialize an instance of the class from the serialized data source.</li>
                <li>GetObjectData has two parameters. The SerializationInfo parameter provides AddValue methods that can
                    be used to store named items in this serialization stream. The StreamingContext paramter provides
                    the serialization method with context about the serialization.
                    <code>
                        [Serializable]
                        class Artist : ISerializable
                        {
                        public string Name {get; set;}

                        protected Artist (SerializationInfo info, StreamingContext context)
                        {
                        Name = info.GetString("name");
                        }

                        protected Artist(){}

                        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
                        public void GetObjectData(SerializationInfo info, StreamingContext context)
                        {
                        info.AddValue("name", Name);
                        }
                        }
                    </code>
                </li>
                <li>The GetObjectData method must access private data in an object in order to store it. This can be
                    used to read the contents of private data in serialized objects. This is why the GetObjectData
                    method definition should be preceded by the security permission attribute.</li>
                <li>The second way of customizing the serialization process is to add methods that will be called during
                    serialization.</li>
                <li>The OnSerializing method is called before the serialization is performd and the OnSerialized method
                    is called when the serialization is completed.</li>
                <li>The same format of attributes is used for the deserialize methods. These methods allow code in a
                    class to customize the serialization process, but they don't have access to the serialization
                    stream, only the streaming context information.</li>
                <li>In the example below a message is displayed at each stage of the process:
                    <code>
                        [Serializable]
                        class Artist
                        {
                        [OnSerializing()]
                        internal void OnSerializingMethod(StreamingContext context)
                        {
                        Console.WriteLine("Called before the artist is serialized.");
                        }

                        [OnSerialized()]
                        internal void OnSerializedMethod(StreamingContext context)
                        {
                        Console.WriteLine("Called after the artist is serialized.");
                        }

                        [OnDeserializing()]
                        internal void OnDeserializingMethod(StreamingContext context)
                        {
                        Console.WriteLine("Called before the artist is deserialized.");
                        }

                        [OnDeserialized()]
                        internal void OnDeserializedMethod(StreamingContext context)
                        {
                        Console.WriteLine("Called after the artist is deserialized.");
                        }
                        }
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Use the XML and JSON Serializers</h3>
            <h4>Use the XML Serializer</h4>
            <ul>
                <li>When an XmlSerializer instance is create to perform serializaiton, the constructor must be given the
                    type of data being stored:
                    <code>
                        MusicDataStore musicData = MusicDataStore.TestData();

                        XmlSerializer formatter = new XmlSerializer(typeof(MusicDataStore));
                        using (FileStream outputStream = new FileStream("MusicTracks.xml", FileMode.OpenOrCreate,
                        FileAccess.Write))
                        {
                        formatter.Serialize(outputStream, musicData);
                        }

                        MusicDataStore inputData;

                        using (FileStream inputStream = new FileStream("MusicTracks.xml", FileMode.Open,
                        FileAccess.Read))
                        {
                        inputData = (MusicDataStore)formatter.Deserialize(inputStream);
                        }
                    </code>
                </li>
                <li>Xml Serialization is called a text serializer because the serialization process creates text
                    documents.</li>
                <li>The serialization process handles references to objects differently from binary serialization.</li>
                <li>If the data is serialized using binary serialization the references are preserved. While with XML
                    serialization, a copy of the reference type is stored in each element.</li>
                <li>When the XMl data is deserialized each MusicTrack instance will contain a reference to its own
                    Artist instance. If you want to preserve references you must use binary serialization.</li>
            </ul>
            <h4>Use the JSON Serializer</h4>
            <ul>
                <li>The JSON serialize ruses the JavaScript object Notaiton to store serialized data in a text file.
                </li>
            </ul>
        </div>
        <div>
            <h3>Use the Data Contract Serializer</h3>
            <ul>
                <li>The data contract serializer is provided as part of the Windows Communicaiton Framework (WCF).</li>
                <li>It is located in the System.Runtime.Serialization library. This is not included in the project by
                    default.</li>
                <li>It differs from the XML serializer in the following ways:
                    <ul>
                        <li>Data to be serialized is selected using an "opt in" mechanism, so only items marked with the
                            [DataMember] attribute will be serialized.</li>
                        <li>It is possible to serialize private class elements (although they will be public in XML text
                            produced by the serializer).</li>
                        <li>The XML serializer provides options that allow programmers to specify the order in which
                            items are serialized into the data file. These options are not present in the DataContract
                            serializer.</li>
                    </ul>
                </li>
                <li>The class here have been given the data contract attributes that are used to serialize the data in
                    them:
                    <code>
                        [DataContract]
                        public class Artist
                        {
                        [DataMember]
                        public int ID {get;set;}
                        [DataMember]
                        public string Name {get;set;}

                        [DataContract]
                        public class MusicTrack
                        {
                        [DataMember]
                        public int ID {get;set;}
                        [DataMember]
                        public int ArtistID {get;set;}
                        [DataMember]
                        public string Title {get;set;}
                        [DataMember]
                        public int Length {get;set;}
                        }
                        }
                    </code>
                </li>
                <li>Once the fields to be serialized have been specified they can be serialized using a
                    DataContractSerializer. Note that the methods to serialize and deserialize are called WriteObject
                    and ReadObject respectively:
                    <code>
                        MusicDataStore musicData = MusicDataStore.TestData();

                        DataContractSerializer formatter = new DataContractSerializer(typeof(MusicDataStore));

                        using (FileStream outputStream = new FileStream("MusicTracks.xml", FileMode.OpenOrCreate,
                        FileAccess.Write))
                        {
                        formatter.WriteObject(outputStream, musicData);
                        }

                        MusicDataStore inputData;

                        using (FileStream inputStream = new FileStream("MusicTracks.xml", FileMode.Open,
                        FileAccess.Read))
                        {
                        inputData = (MusicDataStore)formatter.ReadObject(inputStream);
                        }
                    </code>
                </li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-5">Skill 4.5: Store Data in and Retrieve Data from Collections</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Store and retrieve data by using dictionaries, arrays, list, sets, and queues</li>
            <li>Choose a collection type</li>
            <li>Initialize a collection</li>
            <li>Add and remove items from a collection</li>
            <li>Use typed vs. non-typed collections</li>
            <li>Implement custom collections</li>
            <li>Implement collection interfaces</li>
        </ul>
        <div>
            <h3>Store and Retrieve Data by Using Dictionaries, Arrays, Lists, Sets, and Queues</h3>
            <h4>Use an Array</h4>
            <ul>
                <li>An array is the simplest way to create a collection of items of a particular type.</li>
                <li>An array is assigned a size when it is created and the elements in the array are accessed using an
                    index or subscript value.</li>
                <li>An array instance is a C# object that is managed by reference. A program creates an array by
                    declaring the array variable and then makes the variable refer to an array instance.</li>
                <li>In this example an array variable that holds integer values, then it is made to refer to a new array
                    that contains 5 elements:
                    <code>
                        int[] intArray;
                        intArray = new int[5];

                        // These can also be combined.
                        int[] intArray = new int[5];
                    </code>
                </li>
                <li>An array of value types holds the values themselves within the array, whereas for an array of
                    reference types each element in the array holds a reference to the object.</li>
                <li>When an array is created, each element in the array is initialized to the default value for that
                    type. Numeric elements are initialized to 0, reference elements to null, and Boolean elements to
                    false.</li>
                <li>Arrays implement the IEnumerable interface, so can be enumerated using the foreach construction.
                </li>
                <li>Any array that uses a single index to access the elements in the array is called a one dimensional
                    array. It is analogous to a list of items. Arrays can have more than one dimension.</li>
                <li>In this example a variety of array behaviours are covered:
                    <code>
                        // Array of integers.
                        int[] intArray = new int[5];

                        int[0] = 99; // Put 99 in the first element.
                        int[4] = 100; // Put 100 in the last element.

                        // Use an index to work through the array.
                        for (int i = 0; i &lt; intArray.Length; i++)
                        {
                        Console.WriteLine(intArray[i]);
                        }

                        // Use an foreach to work through the array.
                        for (int intValue in intArray)
                        {
                        Console.WriteLine(intValue);
                        }

                        // Initialize a new aray.
                        intArray = new int[] { 1, 2, 3, 4 };

                        // Use an foreach to work through the array.
                        for (int intValue in intArray)
                        {
                        Console.WriteLine(intValue);
                        }
                    </code>
                </li>
            </ul>
            <h4>Multi-dimensional Arrays</h4>
            <ul>
                <li>An array with two dimensions is analogous to a table of data that is made up of rows and columns.
                </li>
                <li>An array with three dimensions is analohous to a book containg a number of pages, with a table on
                    each page.</li>
                <li>If you need an array with more than three dimensions, consider a different data arrangement.</li>
                <li>In this example a 2d array for a compass is created:
                    <code>
                        string [,] compass = new string [3,3];
                        {
                        { "NW", "N", "NE" },
                        { "W", "C", "E" },
                        { "SW", "S", "SE" }
                        };

                        Console.WriteLine(compass[0,0]); // Prints NW.
                        Console.WriteLine(compass[2,2]); // Prints SE.
                    </code>
                </li>
            </ul>
            <h4>Jagged Arrays</h4>
            <ul>
                <li>You can view a 2d array as an array of 1d arrays. A "jagged array" is a 2d array in which each of
                    the rows are a different length:
                    <code>
                        int[][] jaggedArray = new int[][];
                        {
                        new int[] { 1, 2, 3, 4 },
                        new int[] { 5, 6, 7 },
                        new int[] { 8, 9 },
                        new int[] { 10, 11, 12 }
                        };
                    </code>
                </li>
            </ul>
            <h4>Use an ArrayList</h4>
            <ul>
                <li>An array is limited by having to decide in advance the number of items it can hold. The size can't
                    be changed once it has been created.</li>
                <li>The ArrayList class was created to address this issue by storing a dynamic structure that grows as
                    more items are added to it.</li>
                <li>In this example an ArrayList is created, items are added, and then read:
                    <code>
                        ArrayList arrayList = new ArrayList();

                        arrayList.add(1);
                        arrayList.add(2);
                        arrayList.add(3);

                        for (int i = 0; i &lt; arrayList.Count; i++)
                        {
                        Console.WriteLine(arrayList[i]);
                        }
                    </code>
                </li>
                <li>The ArrayList provides an Add method that adds items to the end of the list, an Inserrt method to
                    insert items in a list, and a Remove method to remove items.</li>
                <li>Items in an ArrayList are managed by reference and the reference that is used is of type object.
                    Meaning that an ArrayList can hold references to any type of object. This can lead to programming
                    difficulties which are discussed later on.</li>
            </ul>
            <h4>Use a List</h4>
            <ul>
                <li>When a List is created the type of data that the list is to hold is specified using C# generic
                    notation.</li>
                <li>Only references of the specified type can be added to the list, and values obtained from the list
                    are of the specified type.</li>
                <li>In this example a list of names is created, added to, printed out and modified:
                    <code>
                        List&lt;string&gt; names = new List&lt;string&gt;();

                        names.Add("Rob Miles");
                        names.Add("Immy Brown");

                        for (int i = 0; i &lt; names.Count; i++)
                        {
                        Console.WriteLine(names[i]);
                        }

                        names[0] = "Fred Bloggs";
                        foreach (string name in names)
                        {
                        Console.WriteLine(name);
                        }
                    </code>
                </li>
                <li>The List type implements the ICollection and IList interfaces.</li>
            </ul>
            <h4>Use a Dictionary</h4>
            <ul>
                <li>A Dictionary allows you to access data using a key. This is analogous with an actual dictionary
                    where to look up the definition of a word, you find the word in a dictionary and read the
                    definition.</li>
                <li>In this example a dictionary of shapes is stored where the name is the key and the value is the
                    number of sides.
                    <code>
                        Dictionary&lt;string, int&gt; shapes = new Dictionary&lt;string, int&gt;();

                        shapes.Add("Circle", 1);
                        shapes.Add("Triangle", 3);

                        shapes["Square"] = 4;
                        shapes["Pentagon"] = 5;

                        Console.WriteLine(shapes["Square"]);

                        if (shapes.ContainsKey("Circle"))
                        {
                        Console.WriteLine($"Shape sides: {shapes["Circle"]});
                        }
                    </code>
                </li>
                <li>A dictionary can be used to implement data storage, but it is also useful in a number of other
                    contexts. Such as for counting the number of words in a file:
                    <code>
                        Dictionary&lt;string, int&gt; counters = new Dictionary&lt;string, int&gt;();

                        string text = File.ReadAllText("input.txt");
                        string[] words = text.Split(new char[] {' ', '.', ','}, StringSplitOptions.RemoveEmptyEntires);

                        foreach (string word in words){
                        string lowWord = word.ToLower();
                        if (counters.ContainsKey(lowWord))
                        {
                        counters[lowWord]++;
                        }
                        else
                        {
                        counters.Add(lowWord, 1);
                        }
                        }
                    </code>
                </li>
                <li>List and array instances provide a Sort method than can be used to sort their contents.
                    Unfortunately, the Dictionary class does not provide a sort behaviour.</li>
                <li>A LINQ query can be used on a dictionary to produce a sorted iteration of the dictionary contents
                    which can be used in conjunction with a foreach loop to generate sorted output:
                    <code>
                        var items = from pair in counters
                        orderby pair.Value descending
                        select pair;

                        foreach (var pair in items)
                        {
                        Console.WriteLine($"{pair.Key} : {pair.Value}");
                        }
                    </code>
                </li>
            </ul>
            <h4>Use a Set</h4>
            <ul>
                <li>A set is an unordered collection of items. Each of the items in a set will be present only once.
                </li>
                <li>A set can be used to contain tags or attributes that might be applied to a data item.</li>
                <li>C# doesn't have a built-in set type, but the HashSet class can be used to implement sets.</li>
                <li>The HasShet class provides methods that implement set operations. The IsSubsetOf method returns true
                    if the given set is a subset of another.</li>
                <li>In this example three sets of music genres are created and then IsSubsetOf is tested:
                    <code>
                        HashSet&lt;string&gt; t1Styles = new HashSet&lt;string&gt;();
                        t1Styles.Add("Electronic");
                        t1Styles.Add("Disco");
                        t1Styles.Add("Fast");

                        HashSet&lt;string&gt; t2Styles = new HashSet&lt;string&gt;();
                        t2Styles.Add("Orchestral");
                        t2Styles.Add("Classical");
                        t2Styles.Add("Fast");

                        HashSet&lt;string&gt; search = new HashSet&lt;string&gt;();
                        search.Add("Disco");
                        search.Add("Fast");

                        if(search.IsSubsetOf(t1Styles))
                        {
                        Console.WriteLine("All search styles present in T1");
                        }

                        if(search.IsSubsetOf(t2Styles))
                        {
                        Console.WriteLine("All search styles present in T2");
                        }
                    </code>
                </li>
                <li>Other set methods can be used to combine set values to produce unions, differences, and to test
                    supersets and subsets.</li>
            </ul>
            <h4>Use a Queue</h4>
            <ul>
                <li>A queue provides short term storage for data items.</li>
                <li>It is organized as a FIFI (First-In-First-Out) collection.</li>
                <li>The Enqueue method adds items to the queue and Dequeue removes them.</li>
                <li>The Peek method allows the program to see what the top item of the queue is without removing the
                    item.</li>
                <li>
                    <code>
                        Queue&lt;string&gt; demoQueue = new Queue&lt;string&gt;;

                        demoQueue.Enqueue("Rob Miles");
                        demoQueue.Enqueue("Immy Brown");

                        Console.WriteLine(demoQueue.Dequeue());
                        Console.WriteLine(demoQueue.Dequeue());
                    </code>
                </li>
                <li>A potential use for a queue is for passing work items from one thread to another. The
                    ConcurrentQueue should be used for this.</li>
            </ul>
            <h4>Use a Stack</h4>
            <ul>
                <li>A stack is similar to a queue, but the most important difference is that a stack is organized as
                    LIFO (Last-In-First-Out).</li>
                <li>The Push method pushes items to the top of the stack.</li>
                <li>The Pop method removes items from the top of the stack.</li>
                <li>
                    <code>
                        Stack&lt;string&gt; demoStack = new Stack&lt;string&gt;;

                        demoStack.Push("Rob Miles");
                        demoStack.Push("Immy Brown");

                        Console.WriteLine(demoStack.Pop());
                        Console.WriteLine(demoStack.Pop());
                    </code>
                </li>
                <li>The ConcurrentStack should be used when different Tasks are using the same Stack.</li>
            </ul>
        </div>
        <div>
            <h3>Choose a Collection Type</h3>
            <ul>
                <li>The type of collection to use normally falls naturally from the demands of the application.</li>
                <li>If you need to store a list of values, use a List in preference to an array or ArrayList. An array
                    is fixed in size and an ArrayList does not provide type safety.</li>
                <li>A list can only contain objects of the list type and can grow and contract. It is also very easy to
                    remove a value from the middle of a list or to insert an extra value.</li>
                <li>Use an array if you are concerned about performance and you are holding value types, since the data
                    will be accessed more quickly. Or when the program needs to store 2d data.</li>
                <li>Use a dictionary when there is an obvious value in an object upon which it can be indexed.</li>
                <li>Use a List and LINQ if you need to locate a data value based on different elements, such as needing
                    to find a customer based on their customer ID, name, or address.</li>
                <li>Sets are useful when working with tags. Their built-in operations are much easier to use than
                    writing your own code to match elements together.</li>
                <li>Queues and stacks are used when the needs of the application require LIFO or FIFO behaviour.</li>
            </ul>
        </div>
        <div>
            <h3>Initialize a Collection</h3>
            <ul>
                <li>This example shows the initialization process for each of the collections discussed before:
                    <code>
                        int[] arrayInit = { 1, 2, 3, 4 };

                        ArrayList arrayListInit = new ArrayList { 1, "Rob Miles", new ArrayList() };

                        List&lt;int&gt; listInit = new List&lt;int&gt;{ 1, 2, 3, 4 };

                        Dictionary&lt;int, string&gt; dictionaryInit = new Dictionary&lt;int, string&gt; {
                        { 1, "Rob" },
                        { 2, "Immy" }
                        };

                        HashSet&lt;string&gt; setInit = new HashSet&lt;string&gt;{ "Electronic", "Disco", "Fast" };

                        Queue&lt;string&gt; queueInit = new Queue&lt;string&gt;(new string[] { "Rob", "Immy" });

                        Stack&lt;string&gt; stackInit = new Stack&lt;string&gt;(new string[] { "Rob", "Immy" });
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Add and Remove Items from a Collection</h3>
            <h4>Add and Remove Items from an Array</h4>
            <ul>
                <li>The array class does not provide any methods that can add or remove elements.</li>
                <li>The size of an array is fixed when it is created. The only way to modify the size of an existing
                    array is to create a new array of the reqired type and then copy the elements from one to the other.
                </li>
                <li>The array class provides a CopyTo method that will copy the contents of an array into another array.
                    The first parameter of CopyTo is the destination array. The second parameter is the start position
                    in the destination array for the copied values.</li>
                <li>In this example the CopyTo method is used to migrate data to a larger array:
                    <code>
                        int[] dataArray = { 1, 2, 3, 4 };
                        int[] tempArray = new int[5];
                        dataArray.CopyTo(tempArray, 0);
                        dataArray = tempArray;
                    </code>
                </li>
            </ul>
            <h4>Add and Remove Items in ArrayList and List</h4>
            <ul>
                <li>There are a number of methods that can be used to modify the contents of the ArrayList and List
                    collectons:
                    <code>
                        List&lt;string&gt; = new List&lt;string&gt;();
                        list.Add("Add to the end of the list");
                        list.Insert(0, "Insert at the start of the list");
                        list.Insert(1, "Insert new item at the 2nd index");
                        list.InsertRange(2, new string[] { "Rob", "Immy" });
                        list.Remove("Rob"); // Removes the first occurrence of "Rob".
                        list.RemoveAt(0); // Removes the first element.
                        list.RemoveRange(1, 2); // Remove 2 elements.
                        list.Clear(); // Clears the entire list.
                    </code>
                </li>
            </ul>
            <h4>Add and Remove Items from a Dictionary</h4>
            <ul>
                <li>The Dictionary type provides Add and Remove methods:
                    <code>
                        Dictionary&lt;int, string&gt; dictionary = new Dictionary&lt;int, string&gt;();
                        dictionary.Add(1, "Rob Miles"); // Add an entry.
                        dictionary.Remove(1); // Remove the entry with the given key.
                    </code>
                </li>
            </ul>
            <h4>Add and Remove Items from a Set</h4>
            <ul>
                <li>The Set type provides Add, Remove and RemoveWhere methods.</li>
                <li>The RemoveWhere function is given a predicate (a behaviour that generates either true or false) to
                    determine which elements are to be removed:
                    <code>
                        HashSet&lt;string&gt; set = new HashSet&lt;string&gt;();
                        set.Add("Rob Miles"); // Add an item.
                        set.Remove("Rob Miles"); // Remove and item.
                        set.RemoveWhere(x => x.StartsWith("R")); // Remove all items that start with 'R'.
                    </code>
                </li>
            </ul>
            <h4>Add and Remove Items in Queue and Stack</h4>
            <ul>
                <li>The most important aspect of the behaviour of queues and stacks is the way that items are added and
                    removed.</li>
                <li>For this reason, the only actions that allow their contents to be changed are the ones you have seen
                    earlier.</li>
            </ul>
        </div>
        <div>
            <h3>Use Typed Vs. Non-typed Collections</h3>
            <ul>
                <li>ArrayList collections can contain any type of object in the same ArrayList. Though you can do this,
                    it isn't good programming practice:
                    <code>
                        ArrayList messyList = new ArrayList();
                        messyList.Add(1); // An integer.
                        messyList.Add("Rob Miles"); // A string.
                        messyList.Add(new ArrayList()); // An ArrayList.
                    </code>
                </li>
                <li>Another difficulty caused by the untyped storage provided by the ArrayList is that all of the
                    references in the list are references to objects.</li>
                <li>When a program removes an item from an ArrayList it must cast the item into its proper type before
                    it can be used. Meaning, a value must be cast before using it:
                    <code>
                        int messyInt = (int) messyList[0];
                    </code>
                </li>
                <li>Due to the issues caused by untyped collections, the ArrayList has been superseded by the List type,
                    whicih uses the generics feature in alter versions of C#.</li>
            </ul>
        </div>
        <div>
            <h3>Implement Custom Collections</h3>
            <ul>
                <li>A custom collection is one you create for a specific purpose that has behaviours that you need in
                    your application.</li>
                <li>One way to create them is to create a new type that implements the ICollection interface. Once
                    created it can be used in the same way as any other collection, such as using a foreach construction
                    with it.</li>
                <li>Another way to create a custom collection is to use an existing collection class as the bas (parent)
                    class of a new collection type. You can then add new behaviours to your new collection, but
                    otherwise, it can be used the same way as any other collection.</li>
                <li>this example shows how to create a custom MusicTrack store based on the List collection type:
                    <code>
                        class TrackStore : List&lt;MusicTrack&gt;
                        {
                        public int RemoveArtist(string removeName)
                        {
                        List&lt;MusicTrack&gt; removeList = new List&lt;MusicTrack&gt;();
                        foreach (MusicTrack track in this)
                        {
                        if(track.Artist == removeName)
                        {
                        removeList.Add(track);
                        }
                        }

                        foreach (MusicTrack track in removeList)
                        {
                        this.Remove(track);
                        }

                        return removeList.Count;
                        }
                        }
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Implement Collection Interfaces</h3>
            <ul>
                <li>The behaviour of a collection type is expressed by the ICollection interface which is a child of the
                    IEnumerator interface.</li>
                <li>Interface hierarchies work in exactly the same way as class hierarchies, in that a child of a parent
                    interface contains all of the methods that are described in the parent.</li>
                <li>In this example is a class that implementes the ICollection interface. It can be used the same way
                    as any other collection, and can be enumerated as it provides a GetEnumerator method:
                    <code>
                        class CompassCollection : ICollection
                        {
                        // Array containing values in this collection.
                        string[] compassPoints = { "North", "East", "South", "West" };

                        // Count property to return the length of the collection.
                        public int Count
                        {
                        get { return compassPoints.Length };
                        }

                        // Returns an object that can be used to synchronise access to this object.
                        public object SyncRoot
                        {
                        get { return this; }
                        }

                        // Returns true if the collection is thread safe. This collection is not.
                        public bool IsSynchronized
                        {
                        get { return false; }
                        }

                        // Provide a copyto behaviour.
                        public void CopyTo(Array array, int index)
                        {
                        foreach (string point in compassPoints)
                        {
                        array.SetValue(point, index);
                        index++;
                        }
                        }

                        // Required for IEnumerate. Returns the enumerator from the embedded array.
                        public IEnumerator GetEnumerator()
                        {
                        return compassPoints.GetEnumerator();
                        }
                        }
                    </code>
                </li>
                <li>If you want the new collection type to be used with LINQ enquires it must implement the
                    IEnumberable&lt;type&gt; interface. This means the type must contain a GetEnumerator&lt;string&gt;
                    method.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="qa-4">Thought Experiments</h2>
        <div>
            <h3>1 Perform I/O Operations</h3>
            <p>Class hierarchies are an important element in the design of the data management mechanisms provided by
                .NET. The Stream class sets out the fundamental data movement commands and is used as the basis of
                classes that provide data storage on a variety of platforms. Streams can also be chained together so
                that character encoding, encryption and compression can be performed on data being moved to or from any
                stream-base store.</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">Why can't a program create and instance of the Stream type?</div>
                    <div class="answer">
                        <ul>
                            <li>Because the Stream class is defined as abstract and intended to be used as a base class for child classes that contain implementions of the behaviours described by Stream.</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">When would a program modify the file pointer in a file?</div>
                    <div class="answer">
                        <ul>
                            <li>The file pointer value is maanged by a stream and specifies the position at which the next I/L transaction will be performed.</li>
                            <li>When a file is read, the pointer is at the beginning of the file.</li>
                            <li>The pointer can skip some of the file by updating the file pointer location.</li>
                            <li>Updating the value is faster than reading through the file.</li>
                            <li>When writing into a file, the point is updated as the file is written.</li>
                            <li>When a file is opened in append mode the file pointer is moved to the end of the file.</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the difference between UTF8 UNicode and UTF32 Unicode?</div>
                    <div class="answer">
                        <ul>
                            <li>Unicode is a mapping between values and text characters.</li>
                            <li>The UTF8 standard maps Unicode characters onto one or more 8-bit storage locations.</li>
                            <li>The UTF32 standard maps Unicode characters onto one or more 32-bit storage locations.</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Is there such a thing as a "text file"?</div>
                    <div class="answer">
                        <ul>
                            <li>The file system makes no distinciton between a "text" file and a "binary" file.</li>
                            <li>This distinction is made by programs using the file system to store files.</li>
                            <li>In C#, a text file is one that contains values which represent text.</li>
                            <li>The values in the text file will be encoded using a standard that maps numeric values onto characters. Typically Unicode.</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Can a program both read from and write to a single file?</div>
                    <div class="answer">
                        <ul>
                            <li>Yes. If a stream is opened for ReadWrite access, then it can be read from and written to.</li>
                            <li>The file usually holds fixed length records, so a single record in the middle of a file can be changed without affecting any of the other records in the file.</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the difference between a TextWriter and a StreamWriter?</div>
                    <div class="answer">
                        <ul>
                            <li>The TextWriter class is abstract and specifies operations that can be performed to write text into a stream.</li>
                            <li>The StreamWriter class is a child of the TextWriter class that can be instantiated and used to write text into a stream.</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Why is it useful for a stream class to have a constructor that accepts an
                        object of the stream type?</div>
                    <div class="answer">
                        <ul>
                            <li>A stream can be constructed from another stream to allow streams to be "chained" together.</li>
                            <li>The output of one stream can be sent into the next.</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the File class for?</div>
                    <div class="answer">
                        <ul>
                            <li>It provides a set of very useful methods which allow the creation and population of files with only a small number of statements.</li>
                            <li>It also provides useful file management commands.</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Will you need to re-compile a program for it to be used on a system with a
                        different file system?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What happens to the files in a directory when you delete the directory?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">How can you tell if a file path is an absolute path to the file?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Why should you use the Path class to construct file paths in your programs?
                    </div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the difference between HTTP and HTML?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">When should you use the HttpWebRequest class to contact a web server?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Can a program make web requests asynchronously?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Why is it a good idea to perform file operations asynchronously?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
        <div>
            <h3>2 Consume Data</h3>
            <p>Databases are the storage resource that underpins many applications. This section has shown how SQL is
                used to interact with a database, how to use a database in ASP, and how JSON and XML documents allow
                programs to exchange structured data. Also, web services were covered; a means by which a server can
                expose resources in the form of method calls.</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">Does each suer of a database need their own copy of the data?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What would happpen if two users of a database updated the same record at the
                        same time?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What would happen if two items in a database had the same ID value?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Why do you need to protect your database connection string?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Do you always have to write SQL queries to interact with a database?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is an SQL injection attack, and how do you protect against one?
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">You can see how to read JSON data from a server, but is it possible to store
                        JSON formatted data values on a server?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the difference between a web service and just downloading JSON
                        documents from a server?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
        <div>
            <h3>3 Query and Manipulate Data and Objects by Using LINQ</h3>
            <p>LINQ allows developers to take their SQL skills in building queries and apply them to software objects.
                By exposing query elements as C# operators using the query comprehension syntax LINQ allows you to
                create C# statements that closely resemble SQL queries. These queries can be applied to structured data
                from a database, but they can also be applied to normal collections and XML documents. LINQ is useful
                for filtering data and extracting subsets; it also provides the group operator that can be used to
                summarize data. LINQ queries are actually implemented as method calls onto objects and can be created
                that way if preferred.</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">What does "Language Integrated Query" actually mean?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Does LINQ add new features for data manipulation?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Is it more efficient to build and perform our own SQL queries than to use
                        LINQ?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Why would the statement var counter; cause a compilation error?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is an anonymous type?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What does "deferred execution" of a LINQ query mean?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What does the group behaviour do in a LINQ query?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What do the take and skip behaviours do?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the differnece between query comprehension and method-based LINQ
                        queries?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the difference between the XDocument and XElement types?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the difference between the XmlDocument and XDocument types?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
        <div>
            <h3>4 Serialize and Deserialize Data</h3>
            <p>Serialization is very useful when you want to store or transfer structured data. It is susceptible to
                problems if the content or arrangement of data items that have been serialized change in later versions
                of an application. But, it is possible with sensible data design.</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">When should you use serialization in your program?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Do you need a copy of the type to read a serialized object?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Can any data type be serialized?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Can vlaue types and reference types be stored using serialization?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Does serialization store al of the elements of a class?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">When should you use binary serialization and when should you use XML
                        serialization?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Why should you be concerned about security when using binary serialization?
                    </div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Can you use a custom serializer when serializing to an XML document?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Is it possible to encrypt a serialized class?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the difference between an XML serializer and a DataContract
                        serializer?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
        <div>
            <h3>5 Store Data in and Retrieve Data from Collections</h3>
            <p>Collections provided by .NET can be thought of as a set of tools. Each tool suited to a particular
                situation. Most of the time storage demands are met by List or Dictionary types, but there are
                occassions when a queue or set can save a lot of work. Extending a parent collection type is a great way
                to add custom behaviours. It is possible to perform LINQ queries on collections, which can save a lot of
                work writing code to search through them.</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">When should you use a collection, and when should you use a database?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Can you create an array of arrays?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Can you create a twenty-dimensional array?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Why do the program keep crashing with an array index error?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">The array is one element too small. How do you add a new element on the end of the array?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Why do you use Length to get the length of an array and Count to get the number of items in an ArrayList?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">How does a Dictionary actually work?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">When would you use a set?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">What is the difference between a stack and a queue?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
                <li class="question-answer">
                    <div class="question">Could you use a List to store every type of data in a program?</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
    </div>
</div>