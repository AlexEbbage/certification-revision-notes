<div>
    <h1 id="chapter-4">Chapter 4: Implement Data Access</h1>
    <p>Skills covered in this chapter are:</p>
    <ul>
        <li><a href="#skill-4-1">Skill 4.1: Perform I/O Operations</a></li>
        <li><a href="#skill-4-2">Skill 4.2: Consume Data</a></li>
        <li><a href="#skill-4-3">Skill 4.3: Query and Manipulate Data and Objects by Using LINQ</a></li>
        <li><a href="#skill-4-4">Skill 4.4: Serialize and Deserialize Data by Using Binary and Custom Serialization, and
                XML, JSON and Data Contract Serializer</a></li>
        <li><a href="#skill-4-5">Skill 4.5: Store Data in and Retrieve Data from Collections</a></li>
        <li><a href="#qa-4">Thought Experiments</a></li>
    </ul>
    <div>
        <h2 id="skill-4-1">Skill 4.1: Perform I/O Operations</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Read and write files and streams</li>
            <li>Read and write from the network by using classes in the System.NET namespace</li>
            <li>Implement asynchronous I/O operations</li>
        </ul>
        <div>
            <h3>Read and Write Files and Streams</h3>
            <ul>
                <li>A stream is a software object that represents a stream of data.</li>
                <li>The .NET framework provides a Stream class that serves as the parent type to a range of classes that
                    can be used to read and write data.</li>
                <li>There are 3 ways that a program can interact with a stream:
                    <ul>
                        <li>Write a sequence of bytes to a stream</li>
                        <li>Read a sequence of bytes from a stream</li>
                        <li>Position the "file pointer" in a stream</li>
                    </ul>
                </li>
                <li>File Pointer: Position in the stream where the next read or write operation will take place.</li>
                <li>Seek Method: Provided by the stream to set the file pointer position.</li>
                <li>The Stream class is abstract and serves as a template for streams that connect to actual storage
                    resources.</li>
                <li>Any object that can work with a Stream can work with any objects that behave like a stream.</li>
                <li>System.IO.Stream is the base type to 5 types: BufferedStream, FileStream, MemoryStream, PipeStream,
                    and NetworkStream.</li>
                <li>Each base class contains the Stream behaviours that allow data to be transferred. However, each type
                    is created differently. <i>e.g. A FileStream must specify the path to the file, and a Memory Stream
                        must specify the buffer in memory.</i></li>
            </ul>
            <h4>Use FileStream</h4>
            <ul>
                <li>The FileStream object provides a stream instance connected to a file which converts calls into the
                    stream into commands for the filesystem on the computer running the program.</li>
                <li>The file system provides the interface to the physical device performing the data storage for the
                    computer.</li>
                <li>A call to the stream object's Write method will generate a request to the file system to write the
                    data to the storage.</li>
                <li>
                    <code>
                        static void Main(string[] args){
                        // Writing to a files
                        FileStream outputStream = new FileStream("Output.txt", FileMode.OpenOrCreate, FileAccess.Write);
                        string outputMessageString = "Hello world";
                        byte[] outputMessageBytes = Encoding.UTF8.GetBytes(outputMessageString);
                        outputStream.Write(outputMessageBytes, 0, outputMessageBytes.Length);
                        outputStream.Close();

                        // Reading from files
                        FileStream inputStream = new FileStream("Output.txt", FileMode.Open, FileAccess.Read);
                        long fileLength = inputStream.Length;
                        byte[] readBytes = new byte[fileLength];
                        inputStream.Read(readBytes, 0, (int)fileLength);
                        string readString = Encoding.UTF8.GetString(readBytes);
                        inputStream.Close();
                        Console.WriteLine("Read message: {0}", readString);

                        Console.ReadKey();
                        }
                    </code>
                </li>
            </ul>
            <h4>Control File Use with FileMode and FileAccess</h4>
            <ul>
                <li>A stream can be associated with reading, writing, or updating a file.</li>
                <li>The base Stream class provides properties that a program can use to determine the abilities of a
                    given stream instance.</li>
                <li>The FileMode enumeration is used in the constructor of a FileStream to indicate how the file is to
                    be opened:
                    <ul>
                        <li><b>FileMode.Append:</b> Open a file for appending to the end. If the file exists, move the
                            seek position to the end of this file. If not, create it. Only useable if the file is being
                            opened for writing.</li>
                        <li><b>FileMode.Create:</b> Create a file for writing. If it exists, it is overwritten.</li>
                        <li><b>FileMode.CreateNew:</b> Create a file for writing. If it exists, an exception is thrown.
                        </li>
                        <li><b>FileMode.Open:</b> Open an existing file. If it doesn't exist, an exception is thrown.
                            The mode can be used for reading or writing.</li>
                        <li><b>FileMode.OpenOrCreate:</b> Open a file for reading or writing. If it doesn't exist, an
                            empty file is created. The mode can be used for reading or writing.</li>
                        <li><b>FileMode.Truncate:</b> Open a file for writing and remove any existing contents.</li>
                    </ul>
                </li>
                <li>The FileAccess enumeration is used to indicate how the file is to be used:
                    <ul>
                        <li><b>FileMode.Read:</b> Open a file for writing.</li>
                        <li><b>FileMode.ReadWrite:</b> Open a file for reading or writing.</li>
                        <li><b>FileMode.Write:</b> Open a file for writing.</li>
                    </ul>
                </li>
            </ul>
            <h4>Convert Text to Binary Data with Unicode</h4>
            <ul>
                <li>The System.Text namespace has the Encoding class which has a property, UTF8, which provides methods
                    that will encode and decode Unicode text.</li>
                <li>Unicode is a mapping of character symbols to number vaules. The UTF8 encoding maps Unicode
                    charaacters onto 8-bit calues that can be stored in arrays of bytes.</li>
                <li>Most text files are encoded using UTF8.</li>
                <li>The Encoding class also provides support for other encoding standaring including UTF32 and ASCII.
                </li>
                <li>The GetBytes encoding method takes a C# string and returns the bytes that represent that string in
                    the specified encoding.</li>
                <li>The GetString decoding method takes an array of bytes and returns the string that a buffer full of
                    bytes represents.</li>
            </ul>
            <h4>IDispose and FileStream Objects</h4>
            <ul>
                <li>The stream class implements IDisposable, meaning objects derived from the Stream type must also
                    implement the interface.</li>
                <li>This also means the using construction can be used to ensure that files are closed when they are no
                    longer required.</li>
            </ul>
            <h4>Work with Text Files</h4>
            <ul>
                <li>The filesystem makes no particular distinciton between text files and binary files.</li>
                <li>The TextWriter and TextReader classes are abstract stream classes which make it much easier to work
                    with text, and define a set of methods that can be used with text.</li>
                <li>The StreamWriter class extends the TextWriter class to allow us to write text to streams.
                    <code>
                        using (StreamWriter writeStream = new StreamWriter("Output.txt")){
                        writeStream.Write("Hello world!");
                        }

                        using (StreamReader readStream = new StreamReader("Output.txt")){
                        string readString = readStream.ReadToEnd();
                        Console.WriteLine("Text read: {0}", readString);
                        }
                    </code>
                </li>
            </ul>
            <h4>Chain Stream Together</h4>
            <ul>
                <li>The Stream class has a constructor that will accept another stream as a paramter, allowing the
                    creation of chains of streams.</li>
                <li>This example shhows how to use the GZipStream from the System.IO.Compression namespace in a chain of
                    streams that will save and load compressed text:
                    <code>
                        using (FileStream writeFile = new FileStream("CompressedText.zip", FileMode.OpenOrCreate,
                        FileAccess.Write))
                        {
                        using (GZipStream writeFileZip = new GZipStream(writeFile, CompressionMode.Compress))
                        {
                        using (StreamWriter writeFileText = new StreamWriter(writeFileZip))
                        {
                        writeFileText.Write("Hello world!");
                        }
                        }
                        }

                        using (FileStream readFile = new FileStream("CompressedText.zip", FileMode.Open,
                        FileAccess.Read))
                        {
                        using (GZipStream readFileZip = new GZipStream(readFile, CompressionMode.Decompress))
                        {
                        using (StreamReader readFileText = new StreamReader(readFileZip))
                        {
                        string readString = readFileText.ReadToEnd();
                        Console.WriteLine("Text read: {0}", readString);
                        }
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Use the File Class</h4>
            <ul>
                <li>The Files class is a helper class that makes it easier to work with files.</li>
                <li>It contains a set of static methods that can be used to append text to a file, copy a file, create a
                    file, delete a fil, move a file, open a file, read a file, and manage file security.</li>
            </ul>
            <h4>Handle Stream Exceptions</h4>
            <ul>
                <li>When creating applications that use streams you need to ensure that your code can deal with any
                    exceptions that might be thrown by a stream.</li>
                <li>An application may try to open a file that doesn't exist, or a given storage device may become full
                    during writing.</li>
                <li>It is possible that threads in multi-threaded applications can "fight" over files. If one thread
                    attempts to access a file already in use by another this will lead to exceptions being thrown.</li>
            </ul>
            <h4>Handle Stream Exceptions</h4>
            <ul>
                <li>When creating applications that use streams you need to ensure that your code can deal with any
                    exceptions that might be thrown by a stream.</li>
                <li>An application may try to open a file that doesn't exist, or a given storage device may become full
                    during writing.</li>
                <li>It is possible that threads in multi-threaded applications can "fight" over files. If one thread
                    attempts to access a file already in use by another this will lead to exceptions being thrown.</li>
            </ul>
            <h4>File Storage</h4>
            <ul>
                <li>A storage device can be devided into partitions. Each represents an area on the storage device that
                    can be used to store data.</li>
                <li>A partition on a storage device is exposed as a drive which, on the Windows OS, is represented by a
                    drive letter.</li>
                <li>The drive letter is assigned by the OS and is used as the root of an absolute path to a file on the
                    computer.</li>
                <li>The Disk Management application allows administrators to re-assign drive letter, combine multiple
                    physical drivers into a single logical driver, and attach virtual hard drives (VHD) created from
                    drive images.</li>
                <li>Each of the partitions on a physical storage device is formatted using a particular filing system
                    that manages the storage of files.</li>
                <li>The System.IO namespace provides the DriveInfo class which can be used to obtain information about
                    the drivers attached to a system.</li>
            </ul>
            <h4>Use FileInfo</h4>
            <ul>
                <li>A file system maintains information about each file it stores. Including the name, permissions,
                    dates for creation and modification, and the physical location on the storage device.</li>
                <li>It also maintains attribute information about each file. Attribute information is held as a single
                    value with different bits in the value indicating different attributes.</li>
                <li>Logical operators can be used to work with these values and to assign different attributes to a
                    file.</li>
                <li>The available attributes are as follows:
                    <ul>
                        <li><b>FileAttributes.Archive:</b> The file has not been backed up yet. The attribute will be
                            cleared when/if the file is backed up.</li>
                        <li><b>FileAttributes.Compressed:</b> The file is compressed. This is not something that our
                            program should change.</li>
                        <li><b>FileAttributes.Directory:</b> The file is a directory. This is not something that our
                            prgram should change.</li>
                        <li><b>FileAttributes.Hidden:</b> This file will not appear in an ordinary directory listing.
                        </li>
                        <li><b>FileAttributes.Normal:</b> This is a normal file with no special attributes. This
                            attribute is only valid when there are no other attributes assigned to the file.</li>
                        <li><b>FileAttributes.ReadOnly:</b> The file cannot be written.</li>
                        <li><b>FileAttributes.System:</b> The file is part of the OS and is used by it.</li>
                        <li><b>FileAttributes.Temporary:</b> The file is a temporary file that will not be required when
                            the application has finished. The file system will attempt to keep this file in memory to
                            improve performance.</li>
                    </ul>
                </li>
                <li>This information is exposed in a C# program via the FileInfo class.</li>
                <li>You can use a FileInfo instance to open a file for reading and writing, moving a file, renaming a
                    file, and also modifying the security settings of a file.</li>
                <li>Some of the functions provided by FileInfo are diplicates of those provided by the File class.</li>
                <li>The File class is most useful when you want to perform an action on a single file, and FileInfo when
                    working with a large number of files.</li>
            </ul>
            <h4>Use the Directory and DirectoryInfo Classes</h4>
            <ul>
                <li>A file system can create files that contain collections of file information items called directories
                    or folders.</li>
                <li>Directories can contain directory information about child directories, which allows a user to nest
                    directories to create tree structures.</li>
                <li>As with files, there are 2 way to work with directories: the Directory class and the DirectoryInfo
                    class.</li>
                <li>The Directory class is static and provides methods that can enumerate the contents of directories
                    and to create and manipulate directories.</li>
            </ul>
            <h4>Files and Paths</h4>
            <ul>
                <li>A path defines the location of a file on a storage device. They can be relative or absolute.</li>
                <li>A relative path specifies the location of a file relative to the folder in which the program is
                    presently running. They can specify a file in a parent directory, or a file in a directory in
                    another part of the tree.</li>
                <li>The period "." character means the current directory and a double period ".." means the directory
                    above the current one.</li>
                <li>The "@" character can be placed at the start of a string to mark it as a verbatim string. This means
                    that any escape character will be ignored making it useful because otherwise backslash characters
                    might be interpreted as escape characters.</li>
                <li>An absolute path includes the drive letter and identifies all the sub-directories in the path to the
                    file.</li>
                <li>The Path class provides methods to remove filenames from full paths, change the extension on a
                    filename, and combine filenames and directory paths.</li>
                <li>The Path class is very useful and should always be used in preference to manually working with path
                    string.</li>
                <li>It also provides methods that can generate temporary filenames.</li>
            </ul>
            <h4>Searching for Files</h4>
            <ul>
                <li>The DirectoryInfo class provides a method called GetFiles that can be used to get a collection of
                    FileInfo items that describe the files in a directory.</li>
                <li>One overload of GetFiles can accept a search string. An asterisk "*" character in the search string
                    represents any number of characters and the question mark "?" character can repreent a single
                    character.</li>
                <li>Recursion can be used to retrieve the files of nested directories, and nested directories within
                    those directories.</li>
            </ul>
        </div>
        <div>
            <h3>Read and Write from the Network by Using Classes in the System.NET Namespace</h3>
            <ul>
                <li>.NET Framework provides a range of application programming interfaces that cn interact with a TCP/IP
                    (Transmission Control Protcol/Internet Protocol) network.</li>
                <li>C# programs can create network socket objects that can communicate over the network by sending
                    unacknowledged datagrams using UDP (User Datagram Protocol) or creating managed connection using TCP
                    (Transmission Control Protocol).</li>
                <li>Classes in the System.Net namespace allow a porgram to communicate with servers using the HTTP
                    (HyperText Transport Protocol). This protocol operates on top of a TCP/IP connection.</li>
                <li>An HTTP client, for example a web browser, creates a TCP connection to a server an makes a request
                    for data by sending the HTTP GET command. The server will then respond with a page of information
                    and the TCP connection will close.</li>
                <li>Information returned from the server will be formatted using HTML (HyperText Markup Language) and
                    rendered by the browser.</li>
                <li>In the case of an ASP (Active Server Pages) application the HTMl document may be produced
                    dynamically by software, rather than being loaded from a file stored on the server.</li>
                <li>HTTP was originally used for the sharing of human-readable web pages. However, now an HTTP request
                    can return an XML or JSON formatted document that describes data in an application.</li>
                <li>The REST (REpresentational State Transfer) architecture uses the GET, PUT, POST and DELETE
                    operations of HTTP to allow a client to request a server to perform functions in a client-server
                    application.</li>
                <li>The fundamental operation that is used to communicate with these and other servers is the sending of
                    a "web request" to a server to perform an HTML command on the server.</li>
            </ul>
            <h4>WebRequest</h4>
            <ul>
                <li>The WebRequest class is an abstract base class that specifies the behaviours of a web request. it
                    exposes a static factory method called Create, which is given a URI (Universal Resource Identifier)
                    string that specifies the resource that is to be used.</li>
                <li>The Create method inspects the URI and returns a child of the WebRequest class that matches that
                    resource, these are: HttpWebRequest, FtpWebRequest, and FileWebRequest.</li>
                <li>In the case of a website, a URI string will start with "http" or "https" and the Create method will
                    return an HttpWebRequest instance.</li>
                <li>The GetResponse method on an HttpWebRequest returns a WebResponse instance that describes the
                    response from the server.</li>
                <li>To read the text from a webpage you must use the GetResponseStream method on the response.</li>
                <li>Using WebRequest instances to read web pages works, but is rather complicated. It does have the
                    advantage that a program can set a wide range of properties on the web request to tailor it to
                    particular server requirements.</li>
                <li>
                    <code>
                        WebRequest webRequest = WebRequest.Create("https://microsoft.com");
                        WebResponse webResponse = webRequest.GetResponse();

                        using (StreamReader responseReader = new StreamReader(webResponse.GetResponseStream()))
                        {
                        string siteText = responseReader.ReadToEnd();
                        Console.WriteLine(siteText);
                        }
                    </code>
                </li>
            </ul>
            <h4>WebClient</h4>
            <ul>
                <li>The WebClient class provides a simpler and quicker way of reading the text from a web server. </li>
                <li>There is no need to create a stream to read the page contents and there is no need to deal with the
                    response to the web request before you cna obtain the reply from the server.</li>
                <li>
                    <code>
                        WebClient client = new WebClient();
                        string siteText = client.DownloadString("https://www.microsoft.com");
                        Console.WriteLine(siteText);
                    </code>
                </li>
                <li>The WebClient also provides methods that can be used to read from the server asynchronously.
                    <code>
                        async Task&lt;string&gt; readWebpage(string uri)
                        {
                        WebClient client = new WebClient();
                        return await client.DownloadStringTaskAsync(uri);
                        }
                    </code>
                </li>
            </ul>
            <h4>HttpClient</h4>
            <ul>
                <li>The HttpClient is important because it is the way Windows Universal Applications download the
                    contents of a website.</li>
                <li>Unlike the WebRequest and the WebClient classes, an HttpClient only provides asynchronous methods,
                    but can be used in a very similar manner to the WebClient.</li>
                <li>
                    <code>
                        async Task&lt;string&gt; readWebpage(string uri)
                        {
                        HttpClient client = new HttpClient();
                        return await client.GetStringAsync(uri);
                        }
                    </code>
                </li>
            </ul>
            <h4>Exception Handling</h4>
            <ul>
                <li>As with file handling, loading information from the Internet is prone to error. Network connectons
                    may be broken or servers may be unavailable.</li>
                <li>This means web request code should be enclosed in appropriate exception handlers.</li>
            </ul>
        </div>
        <div>
            <h3>Implement Asynchronous I/O Operations</h3>
            <ul>
                <li>When a user has to wait for a synchronous file action to perform it may lead to a very poor user
                    experience.</li>
                <li>File operations provided by the File class do not have any asynchronous versions, so the FileStream
                    class should be used instead.
                    <code>
                        async Task WriteBytesAsync(string filename, byte[] items)
                        {
                        using (FileStream outStream = new FileStream(filename, FileMode.OpenOrCreate, FileAccess.Write))
                        {
                        await outStream.WriteAsync(items, 0, items.Length);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Handling Exceptions in Asynchronous Methods</h4>
            <ul>
                <li>If any exceptions are thrown by the asynchronous file write method they must be caught and a message
                    displayed for the user.</li>
                <li>This will only happen if the WriteBytesAsync method returns a Task object that is awaited when the
                    WriteBytesAsync method is called.
                    <code>
                        private async void StartTaskButton_Click(object sender, RoutedEventArgs e)
                        {
                        byte[] data = new byte[100];

                        try
                        {
                        // This filename contains an invalid character.
                        await WriteBytesAsynctask("demo:.dat", data);
                        }
                        catch (Exception ex)
                        {
                        MessageBox.Show(ex.Message, "File write failed");
                        }
                        }
                    </code>
                </li>
                <li>The only asynchronous methods that should return void are the actual event handlers for the windows
                    controls. Other asynchronous methods must return either a result or a Task, so that any thrown
                    exceptions can be dealt with correctly.</li>
            </ul>
        </div>
        <div>
            <h3>Implement Asynchronous I/O Operations</h3>
            <ul>
                <li>When a user has to wait for a synchronous file action to perform it may lead to a very poor user
                    experience.</li>
                <li>File operations provided by the File class do not have any asynchronous versions, so the FileStream
                    class should be used instead.
                    <code>
                        async Task WriteBytesAsync(string filename, byte[] items)
                        {
                        using (FileStream outStream = new FileStream(filename, FileMode.OpenOrCreate, FileAccess.Write))
                        {
                        await outStream.WriteAsync(items, 0, items.Length);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Handling Exceptions in Asynchronous Methods</h4>
            <ul>
                <li>If any exceptions are thrown by the asynchronous file write method they must be caught and a message
                    displayed for the user.</li>
                <li>This will only happen if the WriteBytesAsync method returns a Task object that is awaited when the
                    WriteBytesAsync method is called.
                    <code>
                        private async void StartTaskButton_Click(object sender, RoutedEventArgs e)
                        {
                        byte[] data = new byte[100];

                        try
                        {
                        // This filename contains an invalid character.
                        await WriteBytesAsynctask("demo:.dat", data);
                        }
                        catch (Exception ex)
                        {
                        MessageBox.Show(ex.Message, "File write failed");
                        }
                        }
                    </code>
                </li>
                <li>The only asynchronous methods that should return void are the actual event handlers for the windows
                    controls. Other asynchronous methods must return either a result or a Task, so that any thrown
                    exceptions can be dealt with correctly.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-2">Skill 4.2: Consume Data</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Retrieve data from a database</li>
            <li>Update date in a database</li>
            <li>Consume JSON and XMl data</li>
            <li>Retrieve data by using web Windows Communication Foundation (WCF)</li>
        </ul>
        <div>
            <h3>Retrieve Data from a Database</h3>
            <h4>Data in a Database</h4>
            <ul>
                <li>The following class contains data members and an integer ID value, which will be used by the
                    database to allow it to uniquely identify each record.
                    <code>
                        public class MusicTrack
                        {
                        public int ID {get; set;}
                        public string Artist {get; set;}
                        public string Title {get; set;}
                        public int Length {get; set;}
                        }
                    </code>
                </li>
                <li>The Entity Framework toolchain uses the class definnition to produce a table in a database that has
                    the required data storage.</li>
                <li>From a data design point of view, a table in a database can be considered as a collection of
                    objects.</li>
            </ul>
            <h4>Read with SQL</h4>
            <ul>
                <li>A database is managed by a server process that accepts commands and acts on them. These commands are
                    given in the SQL (Structured Query Language) format.</li>
                <li>SQL dates back to the 1970's and is called a domain specific language because it is used solely for
                    expressing commands to control a database.</li>
                <li>The asterisk "*" character in SQL is a wildcard that matches all the entries in the table.</li>
                <li>The following command will read all the records from a given table:
                    <code>
                        SELECT * FROM TableName
                    </code>
                </li>
                <li>A program uses an SQL database in a similar way to a stream. It creates an object that represents a
                    connection to the database and sends SQL commands to it.</li>
                <li>The DbConnection is an abstract class that represents a connection to a database and describes
                    behaviours of the connection in the same way that the Stream class is also abstract and describes
                    the behaviours of streams.</li>
                <li>The SqlConnection class is a child of the DbConnection class and represents the implementation of a
                    connection to a SQL database.</li>
                <li>The SqlConnection constructor needs a connection string that identifies the datavase that is to be
                    opened.</li>
                <li>A connection string contains a number of items expressed as name-value pairs. For a server on a
                    remote machine the string will contain the address of the server, the port on which the server is
                    listening and a username/password pair that can authenticate the connection.</li>
                <li>In this example I connect to a database, create an SQL query, execute it and read and print the
                    information:
                    <code>
                        static void Main(string[] args)
                        {
                        string connectionString = "Server=(localdb)\\mssqllocaldb;" +
                        "Database=DatabaseName;" +
                        "Trusted_Connection=True;MultipleActiveResultSets=true";

                        using (SqlConnection connection = new SqlConnection(connectionString))
                        {
                        connection.Open();
                        SqlCommand command = new SqlCommand("SELECT * FROM TableName", connection);
                        SqlReader reader = command.ExecuteReader();
                        while (reader.read())
                        {
                        string artist = reader["Artist"].ToString();
                        string title = reader["Title"].ToString();

                        Console.WriteList("Artist: {0} Title: {1}", artist, title);
                        }
                        }
                        Console.ReadKey();
                        }
                    </code>
                </li>
                <li>It is important that a connection string is not hard-coded. Otherwise, anyone obtaining the source
                    code of the program can view the connection string and will get accdess to the database.</li>
                <li>Anyone obtaining the compiled version of the program can use a tool such as ildasm to view the MSIL
                    code and extract the connection.</li>
                <li>You would also have to change the code, recompile it, and publish it, if you want to change the
                    connection string.</li>
            </ul>
            <h4>Connection String Management in ASP.NET</h4>
            <ul>
                <li>The database connection strings in ASP.NET applications are stored in the configuration files.
                    Usually, this file is the web.config, app.config, or appsettings.json file.</li>
                <li>The ConnectionStrings element in the settings file contains the connection strings for all the data
                    contexts used in the program.</li>
                <li>The setting information in a solution can contain the descriptions of environments that are to be
                    used for development and production deployments of an application.</li>
                <li>The setting information to be used is when a server is started and determined by an environment
                    variable on the computer that is tested when the program starts running. There are 2 contexts in
                    which the word environment is being used:
                    <ul>
                        <li>An ASP applicaiton environment determines the settings for logging, tracing, and debugging,
                            and the database connection string that will be in force when the ASP application runs on a
                            machine. A developer can also create their own settings values that can be used to give them
                            more control over a particular environment.</li>
                        <li>An environment variable is a value that is maintained by the OS and can be used by processes
                            running on the machine. Environment variables managed by Windows 10 include the name of the
                            machine and the file paths to be used to search for programs. The system environment
                            variable ASPNETCORE_ENVIRONMENT can be set to values that determine which environment an ASP
                            application will select when it starts running.</li>
                    </ul>
                </li>
                <li>In older ASP.NET applications the SQL settings are held in the web.config file, which is part of the
                    solution. Developers then use XML transformations to override settings in the file to allow
                    different SQl servers to be selected.</li>
            </ul>
            <h4>SQL Query Operation</h4>
            <ul>
                <li>A program can make a query of a database by creating an SqlCommand instance. The constructor for it
                    takes an SQL command in the form of a string and a database connection.</li>
                <li>In this example the query is executed as a reader command:
                    <code>
                        SqlCommand command = new SqlCommand("SELECT * FROM TableName", connection);
                        SqlCommand command = ne SqlCommand("SELECT * FROM TableName", connection);
                    </code>
                </li>
                <li>The SqlReader provides methods that can be used to move through the results returned by the query.
                    It is only possible to move forward through the results.</li>
                <li>The Read method returns false when there are no more results.</li>
                <li>Individual items in the element can be accessed using their name:
                    <code>
                        while(reader.read())
                        {
                        string artist = reader["Artist"].ToString();
                        string title = reader["Title"].ToString();

                        Console.WriteLine("Artist: {0} Title: {1}", artist, title);
                        }
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Update Data In A Database</h3>
            <ul>
                <li>An SQL UPDATE command will update the contents of a database.</li>
                <li>Specific records in a table can be targeted by identifying them with the WHERE clause.</li>
                <li>
                    <code>
                        using (SqlConnection connection = new SqlConnection(connectionString))
                        {
                        connection.Open();
                        dumpDatabase(connection);
                        SqlCommand command = new SqlCommand("UPDATE TableName SET FieldName='newValue' WHERE ID IN
                        (1,4,5);", connection);
                        int result = command.ExecuteNonQuery();
                        Console.WRiteLine("Number of entries updated: {0}", result);
                        dumpDatabase(connection);
                        }
                    </code>
                </li>
            </ul>
            <h4>SQL Injection and Database Commands</h4>
            <ul>
                <li>You can allow a user to enter values which can be used in the SQL query but this is very dangerous.
                    They could easily delete data with SQL injecton.</li>
                <li>SQL injection is where a malicious user injects SQL commands into the code, often via input fields
                    whose values are used to construct an SQL command.</li>
                <li>You should never construct SQL commands directly from user input. You must use parameterized SQL
                    statements instead.</li>
                <li>This example shows how to use parameterized SQL statements:
                    <code>
                        string sqlCommandText = "UPDATE TableName SET FieldNameA=@newValue WHERE
                        FieldNameB=@searchValue";

                        SqlCommand command = new SqlCommand(sqlCommandText, connection);
                        command.Parameters.AddWithValue("@newValue", newValue);
                        command.Parameters.AddWithValue("@searchValue", searchValue);
                    </code>
                </li>
            </ul>
            <h4>Asynchronous Database Access</h4>
            <ul>
                <li>There are asynchronous versions of all the methods used above.</li>
                <li>These methods used in conjunction with the async/await mechanisms allow a program to run database
                    queries asynchronously.</li>
                <li>This is particularly important if your program is interacting with the user via a windowed
                    interface.</li>
                <li>The dumpDatabase nethod uses asynchronous database commands to create a listing of the contents of a
                    database. It is part of a WPF (Windows Presentation Foundation) application that also allows
                    database editing.
                    <code>
                        async Task &lt;string&gt; dumpDatabase(SqlConnection connection)
                        {
                        SqlCommand command = new SqlCommand("SELECT * FROM MusicTrack", connection);
                        SqlDataReader reader = await command.ExecuteReaderAsync();
                        StringBuilder databaseList = new StringBuilder();
                        while(await reader.ReadAsync())
                        {
                        string id = reader["ID"].ToString();
                        string artist = reader["Artist"].ToString();
                        string title = reader["Title"].ToString();

                        string row = string.Format("ID: {0} Artist: {1} Title: {2}", id, artist, title);
                        databaseList.AppendLine(row);
                        }
                        return databaseList.ToString();
                        }
                    </code>
                </li>
            </ul>
            <h4>Using SQL in ASP Applications</h4>
            <ul>
                <li>You won't find any SQL commands in the code that implement the controller classes for ASP
                    applications.</li>
                <li>This is due to database updates in ASP applications being performed using an Update method that
                    accepts a modified instance of the class to be updated.</li>
                <li>In this example the code updates the database and catches any exceptions that may be thrown:
                    <code>
                        try
                        {
                        _context.Update(record); // Update the database context with the edited track.
                        await _context.SaveChangesAsync(); // Save all the changes.
                        }
                        catch(DbUpdateConcurrencyException)
                        {
                        // Deal with exceptions.
                        }
                    </code>
                </li>
                <li>ASP applications use embedded C# code in the web page (Razor) which iterates through the database
                    contents and presents a view of the data.</li>
                <li>In this example is the index.cshtml file for a MusicTrack:
                    <code>
                        &lt;tr&gt;
                        &lt;td&gt;
                        @Html.DisplayFor(modelItem => item.Artist)
                        &lt;/td&gt;
                        &lt;td&gt;
                        @Html.DisplayFor(modelItem => item.Title)
                        &lt;/td&gt;
                        &lt;td&gt;
                        @Html.DisplayFor(modelItem => item.Length)
                        &lt;/td&gt;
                        &lt;td&gt;
                        &lt;a asp-action="Edit" asp-route-id="@item.ID"&gt;Edit&lt;/a&gt; |
                        &lt;a asp-action="Details" asp-route-id="@item.ID"&gt;Details&lt;/a&gt; |
                        &lt;a asp-action="Delete" asp-route-id="@item.ID"&gt;Delete&lt;/a&gt;
                        &lt;/td&gt;
                        &lt;/tr&gt;
                    </code>
                </li>
        </div>
        <div>
            <h3>Consume JSON and XML Data</h3>
            <h4>Consume JSON Data</h4>
            <ul>
                <li>JSON (JavaScript object Notation) is a means by which applications can exchange data.</li>
                <li>A JSON document is a plain text file that contains a structured collection of and value pairs.</li>
                <li>JSON files can be read and written using the Newtonsoft.Json library.</li>
                <li>In this example the program consumes a JSON feed provided by NASA. It's updated every daya with new
                    pictures or videos from the NASA archives:
                    <code>
                        public class ImageOfDaya
                        {
                        public string date {get; set;}
                        public string explanation {get; set;}
                        public string hdurl {get; set;}
                        public string media_type {get; set;}
                        public string service_version {get; set;}
                        public string title {get; set;}
                        public string url {get; set;}
                        }

                        async Task&lt;ImageOfDay&gt; GetImageOfDay(String imageUrl)
                        {
                        string NASAJson = await readWebpage(imageUrl);
                        ImageOfDay result = JsonConvert.DeserializeObject&lt;ImageOfDay&gt;(NASAJson);
                        return result;
                        }
                    </code>
                </li>
                <li>For this to work the ImageOfDay class had to be created which exactly matches the object described
                    in the JSON feed from NASA.</li>
                <li>This can be done using http://json2csharp.com which accepts a web address that returns a JSON
                    document and then automatically generates a C# class as described by the doucment.</li>
                <li>In this example the code displays the image when the user clicks a button to perform the load. In
                    this case it'll always display the same image but could easily be updated to display the image for a
                    particular day:
                    <code>
                        private async void LoadButtonClickedObject(object sender, RoutedEventArgs e)
                        {
                        try
                        {
                        ImageOfDay imageOfDay = await
                        getImageOfDay("https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&date=2018-05-29");

                        if(imageOfDay.media_type != "image")
                        {
                        MessageBox.Show("It is not an image today");
                        return;
                        }

                        DescriptionTextBlock.Text = imageOfDay.explanation;

                        await displayUrl(imageOfDay.url);
                        }
                        catch (Exception ex)
                        {
                        MessageBox.Show("Fetch failed: {0}", ex.Message);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>Consume XML Data</h4>
            <ul>
                <li>XML is slightly more expressive than JSON, but XML documents are larger than equivalent JSON
                    documents, and this, along with the ease of JSON, has led to JSON replacing XML. However, a lot of
                    information is still expressed ussing XML.</li>
                <li>The System.XML namespace contains a set of classes for working with XML documents. The XMLTextReader
                    class works through a stream of text and decodes each XML element in turn:
                    <code>
                        using (StringReader stringReader = new StringReader(XMLDocument))
                        {
                        XmlTextReader reader = new XmlTextReader(stringReader);

                        while (reader.Read())
                        {
                        string description = string.Format("Type:{0} Name:{1} Value:{2}",
                        reader.NodeType.ToString(),
                        reader.Name,
                        reader.Value);
                        Console.WriteLine(description);
                        }
                        }
                    </code>
                </li>
            </ul>
            <h4>XML Documents</h4>
            <ul>
                <li>It is possible to read information from an XML document by decoding each individual element, but
                    this can be hard work to code.</li>
                <li>An easier approach is to use an XMLDocument instance. This creates a DOM (Document Object Model) in
                    memory from which data can be extracted.</li>
                <li>An advantage of a DOM is that a program can change elements in the DOM and then write out a modified
                    copy of the document incorporating the change:
                    <code>
                        XmlDocument doc = new XmlDocument();
                        doc.LoadXml(XMLDocument);

                        System.Xml.XmlElement rootElement = doc.DocumentElement;
                        // Make sure it is the right element.
                        if (rooElement.Name != "MusicTrack")
                        {
                        Console.WriteLine("Not a music track");
                        }
                        elements
                        {
                        string artist = rootElement["Artist"].FirstChild.Value;
                        string title = rootElement["Title"].FirstChild.Value;
                        Console.WriteLine("Arist:{0} Title:{1}", artist, title);
                        }
                    </code>
                </li>
                <li>An XmlDocument contains a hierarchy of items with a rootElement object at the top of the hierarchy.
                </li>
                <li>These items can be accessed in an element by using a string indexer that contains the name of the
                    required item.</li>
            </ul>
        </div>
        <div>
            <h3>Retrieve Data by Using Windows Communication Foundation (WCF)</h3>
            <ul>
                <li>The NASA image reader works by converting a response from a server into an instance of a class that
                    contains a description of the image and the web address from which the image can be downloaded.</li>
                <li>To read information provided by the NASA server, a client program contains a C# class that matches
                    the JSON document that is received from the server.</li>
                <li>A client of a web service also uses an instance of an object to interact with a server. However, in
                    this case, the client can call methods on the object to read data and also update information on the
                    server.</li>
                <li>The object that is created is a "proxy object". A call to a method of the proxy object will cause a
                    request to be create that is sent to the service on the server.</li>
                <li>When the server receives the request, it will then call the method in a server object. The result
                    which is returned by the method is packaged up into another network message, which is sent back to
                    the client and then sends the return value back to the calling software.</li>
                <li>The service also exposes a description of the methods that it provides. These are used by the
                    development tool to actually create the proxy object in the client program. Meaning you can easily
                    create a client application.</li>
            </ul>
            <h4>Create a Web Service</h4>
            <ul>
                <li>As an example, we'll create a 'Joke of the Day' service. It'll return a string containing a joke on
                    request from the client. The user will be able to select the "strength" of the joke, ranging from 0
                    to 2 where 0 is mildly amusing and 2 is a guaranteed ROFL experience.</li>
                <li>The application is made up of 2 parts: the server program that exports the service, and the client
                    program that uses it.</li>
                <li>The server is created as a WCF (Windows Communication Foundation) Service application.</li>
                <li>The client will be an application that connects to the service and requests a joke.</li>
                <li>The attributes [ServiceContract] and [OperationContract] denote that the interface and method are to
                    be exposed as services.</li>
                <li>
                    <code>
                        using System.ServiceModel;

                        namespace JokeOfTheDay
                        {
                        [ServiceContract]
                        public interface IJokeOfTheDayService
                        {
                        [OperationContract]
                        string GetJoke(int jokeStrength);
                        }
                        }
                    </code>
                </li>
                <li>Once you have the interface you now need a class that implements the method:
                    <code>
                        public class JokeOfTheDayService : IJokeOfTheDayService
                        {
                        public string GetJoke(int jokeStrength)
                        {
                        string result = "Invalid strength";
                        switch(jokeStrength)
                        {
                        case 0:
                        result = "Knock knock. Who's there? Oh, you've heard it.";
                        break;
                        case 1:
                        result = "What's green and hairy and goes up and down? A gooseberry in a lift.";
                        break;
                        case 2:
                        result = "A horse walks into a bar and the barman asks 'Why the long face?'.";
                        break;
                        }
                        return result;
                        }
                        }
                    </code>
                </li>
                <li>If you create a service you can use the WCF Test Client to inboke the methods and view the results.
                </li>
                <li>You can also view the service description in a browser. This gives you a link to the service
                    description, as well as some sample code that shows how to use it.</li>
            </ul>
            <h4>Create a Web Client</h4>
            <ul>
                <li>The client application can run on any machine that has a network connection and wants to consume the
                    service.</li>
                <li>The client application needs to contain a connection to the JokeOfTheDayService which is added to
                    the client Visual Studio project like any other references.</li>
                <li>Once done, you'll see a panel that displays the JokeOfTheDayService only provides one method and you
                    can also change the namespace used to access it on the client.</li>
                <li>The client must now create a proxy object that will be used to invoke the methods in the service:
                    <code>
                        using System;
                        using JokeClient.JokeService;

                        namespace JokeClient
                        {
                        class program
                        {
                        static void Main(string[] args)
                        {
                        using (JokeOfTheDayServiceClient jokeClient = new JokeOfTheDayServiceClient())
                        {
                        Console.WriteLine(jokeClient.GetJoke(1));
                        }
                        Console.ReadKey();
                        }
                        }
                        }
                    </code>
                </li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-3">Skill 4.3: Query and Manipulate Data and Objects by Using LINQ</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Query data by using operators, including projection, join, group, take, skip, and aggregate</li>
            <li>Create method-base LINQ queries</li>
            <li>Query data by using query comprehension syntax</li>
            <li>Select data by using anonymous types</li>
            <li>Force execution of a query</li>
            <li>Read, filter, create, and modify data structures by using LINQ to XML</li>
        </ul>
        <div>
            <h3>Query Data by Using Operators, Including Projection, Join, Group, Take, Skip, and Aggregate</h3>
            <h4>Use an Object Initializer</h4>
            <ul>
                <li>Object initializer syntax is used to create new instances of record objects and to initialize thei
                    values at the same time.</li>
                <li>This is a very useful C# feature that allows you to initialize objects when they are created without
                    the need to create a consturctor method in the class being initialized.</li>
                <li>In this example the statement creates and initializes a new MusicTrack instance where the braces
                    delimit the items that initialize the instance:
                    <code>
                        MusicTrack newTrack = MusicTrack
                        {
                        Artist = "Rob Miles",
                        Title = "My Way",
                        Length = 150
                        };
                    </code>
                </li>
                <li>Any properties not initialized are set to their default values (0 for numeric values and null for
                    strings).</li>
                <li>Properties initialized this way must be made public members of the class.</li>
            </ul>
            <h4>Use a LINQ Operator</h4>
            <ul>
                <li>In this xample, the first statement uses a LINQ query to create an enumerable collection of
                    MusicTracks, which is then enumerated by the foreach construction to print the results:
                    <code>
                        IEnumberable&lt;MusicTrack&gt; selectedTracks = from track in musicTracks where track.Arist.Name
                        == "Rob Miles" select track;
                        foreach (MusicTrack track in selectedTracks)
                        {
                        Console.WriteLine("Artist:{0} Title:{1}", track.Artist.Name, track.Title);
                        }
                    </code>
                </li>
            </ul>
            <h4>Use the var Keyword with LINQ</h4>
            <ul>
                <li>C# is statically typed. Meaning, the type of objects in a program is determined at compile time and
                    the compiler rejects any actions that are not valid.</li>
                <li>This means that the following code fails to compile because the compiler will not allow strings to
                    be subtracted from numbers:
                    <code>
                        string name = "Rob Miles";
                        int age = 21;
                        int silly = age - name;
                    </code>
                </li>
                <li>This increases our confidence in our programs being correct when they run, but does involve going
                    through extra effort to give each variable a type when you declare it.</li>
                <li>The above code can be simplified by using the car keyword to tell the compiler to infer the type of
                    variable being created from the context in which the variable is used:
                    <code>
                        var name = "Rob Miles";
                    </code>
                </li>
                <li>This does not mean that the compiler cannot detect compilation errors. The example earlier will
                    still fail to compile.</li>
                <li>The var keyword is especially useful when using LINQ as the result of a simple LINQ query is an
                    enumerable colection of the type of data element held in the data source:
                    <code>
                        var selectedTracks = from track in musicTracks where track.Arist.Name == "Rob Miles" select
                        track;
                    </code>
                </li>
                <li>There are some situations where you won't know the type of a variable when writing the code. These
                    are called anonymous types and the only way to refer to these is by use of variables of type var.
                </li>
                <li>You can use var everywhere in your code but you won't be popular with other devs as they'll have to
                    infer the type of variable by diging through the code. When you do use it, make sure the type can be
                    inferred easily by the variable name.</li>
            </ul>
            <h4>LINQ Projection</h4>
            <ul>
                <li>The select operation in LINQ can be used to produce a filtered version of a data source.</li>
                <li>Projection can be used to ask a query to "project" the data in the class onto new instaces of a
                    class created just to hold the data returned by the query.</li>
                <li>In this example the query is asked to create a new instance of the TrackDetails class to hold the
                    result of each query.
                    <code>
                        class TrackDetails
                        {
                        public string ArtistName;
                        public string Title;
                        }

                        var selectedTracks = from track in musicTracks
                        where track.Arist.Name == "Rob Miles"
                        select new TrackDetails
                        {
                        ArtistName = track.Artist.Name,
                        track.Title
                        };

                    </code>
                </li>
            </ul>
            <h4>Anonymous Types</h4>
            <ul>
                <li>You can remove the need to create a class to hold the result of a search query by making the query
                    return results of an anonymous type:
                    <code>
                        var selectedTracks = from track in musicTracks
                        where track.Arist.Name == "Rob Miles"
                        select new // Project type name missing from here.
                        {
                        ArtistName = track.Artist.Name,
                        track.Title
                        };
                    </code>
                </li>
                <li>Instances of the new type are initialized using the object initializer syntax.</li>
                <li>The item that is returned by this query is an enumerable collection of instances of a type that has
                    no name. It is anonymous. You have to use a var reference to refer to the query result.</li>
                <li>You can iterate through the collection in this result as your would any other, but each item must
                    also be referred to using a var:
                    <code>
                        foreach (var item in selectedTracks)
                        {
                        console.WriteLine("Artist:{0} Title:{1}", item.ArtistName.Name, item.Title);
                        }
                    </code>
                </li>
            </ul>
            <h4>LINQ Join</h4>
            <ul>
                <li>The MusicTrack and Artist classes used in prior examples use C# references to implement the
                    associations between the objects in the system.</li>
                <li>If you store your data in a database, you will not be able to store the associations in this way.
                </li>
                <li>Instead, each item in the database will have a unique ID (its primary key) and objects referring to
                    this object will contain this ID value (a foreign key).</li>
                <li>Rather than a reference to an Artist instance the MusicTrack now contains an ArtistID field that
                    identifies the artist associated with that track.</li>
                <li>This design makes it slightly more difficult to search for tracks by a particular artist. The
                    progrma needs to find the ID value for the artist with the name being searched for an then search
                    for an tracks with that value of artist ID.</li>
                <li>Fortunately, LINQ provides a join operator that can be used to join the output of on LINQ query to
                    the input of another:
                    <code>
                        var artistTracks = from artist in artists where artist.Name == "Rob Miles"
                        join track in musicTracks on artist.ID equals track.ArtistID
                        select new
                        {
                        ArtistName = artist.Name,
                        track.Title
                        };
                    </code>
                </li>
            </ul>
            <h4>LINQ Group</h4>
            <ul>
                <li>Another useful LINQ feature is the ability to group the results of a query to create a summary
                    output. Such as a query to tell how many tracks there are by each artist in the music collection.
                </li>
                <li>The group action is given the data item to group by and the property by which it is to be grouped.
                </li>
                <li>The artistTrackSummary contains an entry for each different artist. Each of the items i the summary
                    has a Key property, which is th value that item is "grouped" around:
                    <code>
                        var artistTracks = from track in musicTracks
                        group track by track.ArtistID
                        into artistTrackSummary
                        select new
                        {
                        ID = artistTrackSummary.Key,
                        Count = artistTrackSummary.Count()
                        };

                        foreach (var item in artistSummary)
                        {
                        Console.WriteLine("Artist:{0} Tracks recorded:{1}", item.ID, item.Count);
                        }
                    </code>
                </li>
                <li>The issue with this query is that rather than the name of the Artist in displays their ID. This can
                    be resolved with the use of a join operation:
                    <code>
                        var artistTracks = from track in musicTracks
                        join artist in artists on track.ArtistID equals artist.ID
                        group track by artist.Name
                        into artistTrackSummary
                        select new
                        {
                        ID = artistTrackSummary.Key,
                        Count = artistTrackSummary.Count()
                        };
                    </code>
                </li>
            </ul>
            <h4>LINQ Take and Skip</h4>
            <ul>
                <li>A LINQ query will normally return all of the items that it finds. However, this might be more items
                    than your program wants.</li>
                <li>You might want to show the user the output one page at a time. You can use take to tell the query to
                    take a particular number of items and the skip to tell a query to skip a particular number of items
                    in the result before taking the requested number.</li>
                <li>In this example the program displays all of the music tracks ten items at a time:
                    <code>
                        int pageNo = 0;
                        int pageSize = 10;

                        while(true)
                        {
                        // Get the track information.
                        var trackList = from musicTrack in musicTracks.Skip(pageNo*pageSize).Take(pageSize)
                        join artist in artists on musicTrack.ArtistID equals artist.ID
                        select newTrack
                        {
                        ArtistName = artist.Name,
                        Title = musicTrack.title
                        };

                        // Quit if we reached the end of the data.
                        if (trackList.Count() == 0)
                        break;

                        // Display the query result.
                        foreach (var item in trackList)
                        {
                        Console.WriteLine("Artist:{0} Title:{1}", item.ArtistName, item.Title);
                        }

                        Console.WriteLine("Press any key to continue!");
                        Console.ReadKey();

                        // Move on to the next page.
                        pageNo++;
                        }
                    </code>
                </li>
            </ul>
            <h4>LINQ Aggregate Commands</h4>
            <ul>
                <li>In the context of LINQ commands, the word aggregate means "bring together a number of related values
                    to create a single result".</li>
                <li>You can use aggregate operators on the results produced by group operations. </li>
                <li>In this example the Sum operator is used to get the length of all tracks assigned to an artist:
                    <code>
                        var artistSummary = from track in musicTracks]
                        join artist in artists on track.ArtistID equals artist.ID
                        group track by artist.Name
                        into artistTrackSummary
                        select new
                        {
                        ID = artistTrackSummary.Key,
                        Length = artistTrackSummary.Sum(x => x.Length)
                        };
                    </code>
                </li>
                <li>The Average, Max, and Min operations can also be used to generate other items of aggregate
                    information.</li>
                <li>You can also create your own Aggregate behaviour that will be called on each successive item in the
                    group and will generate a single aggregate result.</li>
            </ul>
        </div>
        <div>
            <h3>Create Method-base LINQ Queries</h3>
            <ul>
                <li>The first LINQ query we looked at was this:
                    <code>
                        IEnumberable&lt;MusicTrack&gt; selectedTracks = from track in musicTracks where track.Arist.Name
                        == "Rob Miles" select track;
                    </code>
                </li>
                <li>The query statements uses query comprehension syntax, which includes the operators from, in, where,
                    and select.</li>
                <li>The compiler uses these to generate a call to the Where method on the MusicTracks collections.</li>
                <li>This query can also be written using the Where method which accepts a lambda expression as a
                    parameter:
                    <code>
                        IEnumberable&lt;MusicTrack&gt; selectedTracks = musicTracks.Where(track => track.Artist.Name ==
                        "Rob Miles");
                    </code>
                </li>
                <li>Programs can use the LINQ query methods on data collections such as lists and arrays, and also on
                    database connections.</li>
                <li>The methods that implement LINQ query behaviours are not added to the classes that use them.
                    Instead, they are implemented as extension methods.</li>
            </ul>
        </div>
        <div>
            <h3>Query Data by Using Query Comprehension Syntax</h3>
            <ul>
                <li>The phrase "query comprehension syntax" refers to the way that you can build LINQ queries using the
                    C# operators provided specifically for expressing data queries.</li>
                <li>The intention is to make the C# statements that strong resemble the SQL queries that peform the same
                    function to make it easier for develoeprs familiar with SQL syntax to use LINQ.</li>
                <li>The LINQPad application that allows programmers to create LINQ queries and view the SQL and
                    method-based implementations.</li>
                <li>The standard edition is a very powerful resource for develoeprs and can be downloaded for free from
                    http://www.linqpad.net/.</li>
            </ul>
        </div>
        <div>
            <h3>Select Data by Using Anonymous Types</h3>
            <ul>
                <li>You can also create anonymous type instances in method-based SQL queries.</li>
                <li>In this example an intermediate anonymous class is used to implement the join between the two
                    queries and generates objects that contains artist and track information:
                    <code>
                        var artistSummary = MusicTracks.Join(
                        Artists,
                        track => track.ArtistID,
                        artist => artist.ID,
                        (track, artist) =>
                        new
                        {
                        track = track,
                        artist = artist
                        }
                        )
                        .GroupBy(
                        temp0 => temp0.artist.Name,
                        temp0 => temp0.track
                        )
                        .Select(
                        artistTrackSummary =>
                        new
                        {
                        ID = artistTrackSummary.Key,
                        Length = artistTracks.Sum(x => x.Length)
                        }
                        );
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Force Execution of a Query</h3>
            <ul>
                <li>The result of a LINQ query is an item that can be iterated.</li>
                <li>In previous examples we've used the foreach construction to display the results from queries.</li>
                <li>The actual evaluation of a LINQ query normally only takes place when a program starts to extract
                    results from the query. this is called deferred execution.</li>
                <li>If you want to force the execution of a query you can use the ToArray() method:
                    <code>
                        var artistTracksQuery = from artist in artists
                        where artist.Name == "Rob Miles"
                        join track in musicTracks on artist.ID equals track.ArtistID
                        select new
                        {
                        ArtistName = artist.Name,
                        Title = track.Title
                        };

                        var artistTrackResult = artistTracksQuery.ToArray();

                        foreach (var item in artistTrackResult)
                        {
                        Console.WriteLine("Artist:{0} Title:{1}", item.ArtistName, item.Title);
                        }
                    </code>
                </li>
                <li>A query result also provides ToList and ToDictionary methods that will force the execution of the
                    query and generate an immediate result of that type.</li>
                <li>If a query returns a singleton value (the result of an aggregation operation such as sum or count)
                    it will be immediately evaluated.</li>
            </ul>
        </div>

        <div>
            <h3>Read, Filter, Create, and Modify Data Structures by Using LINQ to XML</h3>
            <h4>Read XML with LINQ to XML and XDocument</h4>
            <ul>
                <li>The XMLDocument class has be superseded in later versions of .NET (3.5 onwwards) by the XDocument
                    class, which allows the use of LINQ queries to parse XML files.</li>
                <li>A program can create an XDocument instance that represents the earlier document by using the Parse
                    method provided by the XDocument class:
                    <code>
                        XDocument musicTracksDocument = XDocument.Parse(XMLText);
                    </code>
                </li>
                <li>The format of LINQ queries is slightly different when working with XML because the source of the
                    query is a filtered set of XML entries from the source document.</li>
                <li>The result of the query is an enumeration of XElement items that have been extracted from the
                    document.</li>
                <li>The XElement class is a development of the XMLElement class that includes XML behaviours.</li>
                <li>
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks = from track in
                        musicTracksDocument.Descendants("MusicTrack") select track;

                        foreach (XElement item in selectedTracks)
                        {
                        Console.WriteLine("Artist:{0} Title:{1}", item.Element("Artist").FirstNode,
                        item.Element("Title").FirstNode);
                        }
                    </code>
                </li>
            </ul>
            <h4>Filter XML Data with LINQ to XML</h4>
            <ul>
                <li>A program can perform filtering in the query by adding a where operator, just as with the LINQ
                    before:
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks = from track in
                        musicTracksDocument.Descendants("MusicTrack")
                        where (string) track.Element("Artist") == "Rob Miles"
                        select track;
                    </code>
                </li>
                <li>It is also possible to express the same query in a method-based form:
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks =
                        musicTracksDocument.Descendants("MusicTrack").Where(element => (string)element.Element("Artist")
                        == "Rob Miles");
                    </code>
                </li>
            </ul>
            <h4>Create XMl with LINQ to XML</h4>
            <ul>
                <li>The LINQ to XML features include very easy ways to create XML documents. Note the arragements of the
                    constructor calls to each XElement item mirror the structure of the document:
                    <code>
                        XElement musicTracks = new XElement("MusicTracks",
                        new List&lt;XElement&gt;
                        {
                        new XElement("MusicTrack",
                        new XElement("Artist", "Rob Miles"),
                        new XElement("Title", "My Way")),
                        new XElement("MusicTrack",
                        new XElement("Artist", "Immy Brown"),
                        new XElement("Title", "Her Way"))
                        }
                        );
                    </code>
                </li>
            </ul>
            <h4>Modify Data with LINQ to XML</h4>
            <ul>
                <li>The XElement class provides methods that can be used to modify the contents of a given XML element.
                </li>
                <li>In this example all the records with a particular title are found and updated to show the correct
                    title:
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks = from track in
                        musicTracksDocument.Descendants("MusicTrack"
                        where track.Element("Title") == "my Way"
                        select track;

                        foreach (XElement item in selectedTracks)
                        {
                        item.Element("Title").FirstNode.ReplaceWith("My Way");
                        }
                    </code>
                </li>
                <li>As with when creating a new XML document, an XElement can contain a collection of other elements to
                    build the tree structure of an XML document.</li>
                <li>You can programatically add and remove elements to change the structure of the XML document:
                    <code>
                        IEnumerable&lt;XElement&gt; selectedTracks = from track in
                        musicTracksDocument.Descendants("MusicTrack"
                        where track.Element("Style") == null
                        select track;

                        foreach (XElement item in selectedTracks)
                        {
                        item.Add(new XElement("Style", "Pop"));
                        }
                    </code>
                </li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-4">Skill 4.4: Serialize and Deserialize Data by Using Binary and Custom Serialization, and XML,
            JSON and Data Contract Serializer</h2>
        <ul>
            <li>Serialiation does not store any of the active elements in an object. The behaviours (methods) in a class are not stored when it is serialized.</li>
            <li>This means the application deserializing the data must have impementations of the classes that can be used to manipulate the data after it has been read.</li>
            <li>Serialization is a complex process. If a data strcture contains a graph of objects that have a large number of associations between them, the serialization process will have to persist each of these associations in the stored file.</li>
            <li>It is best used for transporting data between applicaitons. You can think of it as transferring the "value" ov an object from one place to another.</li>
            <li>Serialization can be used for persisting data, and a serialized stream can be directed into a file, but this is not normally how applications store their state.</li>
            <li>It can lead to problems if the structure or behaviour of the classes implementing the data storage changes during the lifetime of the application.</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>Use and manage versions with binary serialization</li>
            <li>Use custom serialization</li>
            <li>Use the XML and JSON serializers</li>
            <li>Use the data contract serializer</li>
        </ul>
        <div>
            <h3>Use and Manage Versions with Binary Serialization</h3>
            <h4>Use Binary Serialization</h4>
            <ul>
                <li>There are essentially 2 types of serialization a program can use: binary serialization and text serialization.</li>
                <li>Binary serialization imposes its own format on the data that is being serialized, mapping the data onto a stream of 8-bit values.</li>
                <li>The data in a stream created by a binary serializer  can only be read by a corresponding binary de-serializer. Binary serialization can provide a complete "snapshot" of the source data.</li>
                <li>Both public and private data in an object will be serialized, and the type of each data item is preserved.</li>
                <li>Classes to be serialized by the binary serializer must be marked with the [Serializable] attribute:
                    <code>
                        [Serializable]
                        class Artist
                        {
                            public string Name {get; set;}
                        }
                    </code>
                </li>
                <li>The binary serialization classes are held in the System.Runtime.Serialization.Formatters.Binary namespace.</li>
                <li>This example shows how binary serialization is performed:
                    <code>
                        MusicDataStore musicData = MusicDataStore.TestData();

                        BinaryFormatter formatter = new BinaryFormatter();
                        using (FileStream outputStream = new FileStream("MusicTracks.bin", FileMode.OpenOrCreate, FileAccess.Write))
                        {
                            formatter.Serialize(outputStream, musicData);
                        }
                    </code>
                </li>
                <li>An instance of the BinaryFormatter class also provides a behaviour called Deserialize that accepts a stream and returns an object that is has deserialized from that stream.</li>
                <li>In this example the code uses a cast to convert the object returned by the Deserialize method:
                    <code>
                        MusicDataStore inputData;

                        using (FileStream inputStream = new FileStream("MusicTracks.bin", FileMode.Open, FileAccess.Read))
                        {
                            inputData = (MusicDataStore)formatter.Deserialize(inputStream);
                        }
                    </code>
                </li>
                <li>If there are data elements in a class that should not be stored, they can be marked with the [NonSerialized] attribute:
                    <code>
                        [Serializable]
                        class Artist
                        {
                            public string Name {get; set;}
                            [NonSerialized]
                            int tempData;
                        }
                    </code>
                </li>
                <li>Binary serialization is the only serialization technique that serializes private data members by default.</li>
                <li>However, once an object has serialized there is nothing to stop a devious programmer from working with serialized data, perhaps viewing and tampering with the values inside it.</li>
                <li>A program should treat deserialized inputs with suspicion. Furthermore, any security sensitive information in a class should be explicitly marked NonSerialized.</li>
                <li>Another way to improve security of a binary serialized file is to encrypt the stream before it is stored, and decrypt it before deserialization.</li>
            </ul>
            <h4>Manage Versions with Binary Serialization</h4>
            <ul>
                <li>The OnDeserializing method can be used to set values of fields that might not be present in data that is being read from a serialized document. This can be used to manage versions.</li>
                <li>Say you added a new field to a class, this causes a problem when the program tries to deserialize old data without this information.</li>
                <li>You can address this by marking the new field with the [OptionalField] attribute and then setting a default value for this element in the OnDeserializing method.</li>
                <li>The OnDeserializing method is performed during deserialization. The method is called before the data for the object is deserialized and can set default values for fields:
                    <code>
                        [Serializable]
                        class MusicTrack
                        {
                            public string Artist {get; set;}
                            public string Title {get; set;}
                            public int Length {get; set;}

                            [OptionalField]
                            public string Style;

                            [OnDeserializing()]
                            internal void OnDeserializingMethod(StreamingContext context)
                            {
                                Style = "Unknown";
                            }
                        }
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Use Custom Serialization</h3>
            <ul>
                <li>Sometimes it might be necessary for code in a class to get control during the serialization process. Perhaps for checking information, encryption to data elements, or custom compression of data.</li>
                <li>The first way to do this is to create your own implementation of the serialization process by making a data class implement the ISerializable interface.</li>
                <li>A class that implements the ISerializable interface must contain a GetObjectData method which gets called when an object is serialized.</li>
                <li>It takes data out of the object and places it into an object stream. The class must also contain a constructor that will initialize an instance of the class from the serialized data source.</li>
                <li>GetObjectData has two parameters. The SerializationInfo parameter provides AddValue methods that can be used to store named items in this serialization stream. The StreamingContext paramter provides the serialization method with context about the serialization.
                    <code>
                        [Serializable]
                        class Artist : ISerializable
                        {
                            public string Name {get; set;}
                        
                            protected Artist (SerializationInfo info, StreamingContext context)
                            {
                                Name = info.GetString("name");
                            }

                            protected Artist(){}

                            [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
                            public void GetObjectData(SerializationInfo info, StreamingContext context)
                            {
                                info.AddValue("name", Name);
                            }
                        }
                    </code>
                </li>
                <li>The GetObjectData method must access private data in an object in order to store it. This can be used to read the contents of private data in serialized objects. This is why the GetObjectData method definition should be preceded by the security permission attribute.</li>
                <li>The second way of customizing the serialization process is to add methods that will be called during serialization.</li>
                <li>The OnSerializing method is called before the serialization is performd and the OnSerialized method is called when the serialization is completed.</li>
                <li>The same format of attributes is used for the deserialize methods. These methods allow code in a class to customize the serialization process, but they don't have access to the serialization stream, only the streaming context information.</li>
                <li>In the example below a message is displayed at each stage of the process:
                    <code>
                        [Serializable]
                        class Artist
                        {
                            [OnSerializing()]
                            internal void OnSerializingMethod(StreamingContext context)
                            {
                                Console.WriteLine("Called before the artist is serialized.");
                            }
                            
                            [OnSerialized()]
                            internal void OnSerializedMethod(StreamingContext context)
                            {
                                Console.WriteLine("Called after the artist is serialized.");
                            }
                            
                            [OnDeserializing()]
                            internal void OnDeserializingMethod(StreamingContext context)
                            {
                                Console.WriteLine("Called before the artist is deserialized.");
                            }
                            
                            [OnDeserialized()]
                            internal void OnDeserializedMethod(StreamingContext context)
                            {
                                Console.WriteLine("Called after the artist is deserialized.");
                            }
                        }
                    </code>
                </li>
            </ul>
        </div>
        <div>
            <h3>Use the XML and JSON Serializers</h3>
            <h4>Use the XML Serializer</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>Use the JSON Serializer</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
        <div>
            <h3>Use the Data Contract Serializer</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-4">Skill 4.4: Serialize and Deserialize Data by Using Binary and Custom Serialization, and XML,
            JSON and Data Contract Serializer</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-4-5">Skill 4.5: Store Data in and Retrieve Data from Collections</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="qa-4">Thought Experiments</h2>
        <div>
            <h3>HEADING</h3>
            <p>DESCRIPTION</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">QUESTION</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
    </div>
</div>