<div>
    <h1 id="chapter-3">Chapter 3: Debug Applications and Implement Security</h1>
    <p>Skills covered in this chapter are:</p>
    <ul>
        <li><a href="#skill-3-1">Skill 3.1: Validate Application Input</a></li>
        <li><a href="#skill-3-2">Skill 3.2: Perform Symmetric and Asymmetric Encryption</a></li>
        <li><a href="#skill-3-3">Skill 3.3: Manage Assemblies</a></li>
        <li><a href="#skill-3-4">Skill 3.4: Debug An Application</a></li>
        <li><a href="#skill-3-5">Skill 3.5: Implement Diagnostics in an Application</a></li>
        <li><a href="#qa-3">Thought Experiments</a></li>
    </ul>
    <div>
        <h2 id="skill-3-1">Skill 3.1: Validate Application Input</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Validate JSON data</li>
            <li>Choose the appropriate data collection type</li>
            <li>Manage data integrity</li>
            <li>Evaluate a regular expression to validate the input format</li>
            <li>Use built-in functions to validate data type and content</li>
        </ul>
        <div>
            <h3>Using JSON</h3>
            <ul>
                <li>JSON (JavaScript Object Notation) is a very popular means by which applications can exchange data.
                </li>
                <li>It is easy for both people and computers to understand.</li>
                <li>The JSON standard is defined at <a href="https://www.json.org">https://www.json.org</a>.</li>
            </ul>
            <h4>The JSON Document</h4>
            <ul>
                <li>A JSON document contains a number of name/value pairs that represent the data in an application.
                </li>
                <li>A JSON document can also contain arrays of JSON objects.</li>
                <li>JSON documents map very well onto objects in an object-oriented language, although JSON itself is
                    not tied to any one programming language.</li>
                <li>JSON is therefore very useful if you want to share data between programs written in different
                    languages.</li>
                <li>A JSON document is enclosed in braces and contains a series of name and value pairs.</li>
                <li>The type of data is not stored as part of the document.</li>
                <li>JSON documents can contain lists of items. Any value in JSON can be expressed as a comma separated
                    list of name and value pairs, enclosed in square brackets.</li>
                <li>The design of JSON is very lightweight, but can be used to represent highly structured data;
                    particularly when you consider that a list can contain values that represent another list.</li>
            </ul>
        </div>
        <div>
            <h3>JSON and C#</h3>
            <ul>
                <li>The most popular way of converting C# classes to and from C# objects was not a library built into
                    .NET, but a ibrary of routines created by James Newton-King.</li>
                <li>The Newtonsoft.Json library can be obtained via NuGet package manager.</li>
                <li>You can use the classes in it to create JSON descriptions of object contents and retrieve them.</li>
                <li>The SerializeObject and DeserializeObject emthods exposed by the JsonConvert object can be used to
                    create and parse string of JSON.</li>
                <li>There are a few things to be aware of from a security and class design point of view:
                    <ul>
                        <li>In order to save and load private properties in a class you need to mark these items with
                            the [JsonProperty] attribute.</li>
                        <li>If you want to serialize a class using JSON you don't have to add the [Serializable]
                            attribute to the class.</li>
                        <li>When loading a class back using JSON you need to provide the type into which the result is
                            to be stored. No type information is stored in the file that stores the JSON data.</li>
                        <li>The JSON deserializer determines the type of each property in the dstination object and then
                            performs type conversion automatically, a good example of reflection.</li>
                        <li>There is nothing to prevent changes to the context of the text in a JSON document.</li>
                        <li>If you wish to detect modification of a document transferred by JSOn you can add a checksum
                            or hash property to the type that is validated by the recipient of the data.</li>
                    </ul>
                </li>
            </ul>
            <h4>JSON and XML</h4>
            <ul>
                <li>XML (eXtensible Markup Langauge) is another way of expressing the content of an object in a portable
                    and human readable form.</li>
                <li>This is a more heavyeight standard, in that an XML docuent contains more metadata than a JSON
                    doucment.</li>
                <li>XML documents are versiond, and also contain encoding details.</li>
                <li>Each element of the document also contains a name.</li>
                <li>There are a few things that need to be aware of when considering JSON and XML:
                    <ul>
                        <li>XML Serialization can only save and load the public data elements in a type. If you want to
                            save the private elements in a class you should use the Data Contract serializer.</li>
                        <li>For XML serialization to work the class being serialized must contain a parameterless
                            constructor.</li>
                        <li>The XML deserialization process returns a reference to an object.</li>
                        <li>XML documents can have a schema attached to them. A schema formally sets out the items that
                            a document must contain to be valid. Schemas can be used to automatically validate the
                            structure of incoming documents.</li>
                        <li>Elements in an XML document can also be given attributes to provide more information about
                            them.</li>
                        <li>An XML document is no less vulnerable to tampering than a JSON document. However, the
                            attribute mechanism can be used to add vailidation information to data fields.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div>
            <h3>Validate JSON Data</h3>
            <ul>
                <li>You can perform simple text-based checks on a JSON file to get some level of confidene about the
                    validity of tis content.</li>
                <li>A program can check that the text starts and ends with a matching pair of brace characters, contains
                    the same number of open square brackets as close brackets, and an even number of double quote
                    characters.</li>
                <li>The exceptions thrown by the JSON parser can also give good information about the content.</li>
            </ul>
        </div>
        <div>
            <h3>Choose the Appropriate Data Collection Type</h3>
            <ul>
                <li>During the implementation of an application you will need to decide how collections of the data are
                    to be organized. There are a large number of options available.</li>
            </ul>
            <h4>Use Typed Collection Classes</h4>
            <ul>
                <li>From a security point of view, it is advisable to use the typed versions of the C# collection
                    classes.</li>
                <li>The System.Collections namespace provides untype collection classes such as ArraList.</li>
                <li>These are regarded as untyped because the data in them is managed in terms of reference to an
                    object.</li>
                <li>Since object is the base type of all C# types; this means that such collections can hold any type of
                    object, in any arrangement.</li>
                <li>The List class in the Systems.Collections.Generic namespace uses generic typing, which allows the
                    programmer to specify that a given list can only contain specific object references.</li>
            </ul>
            <h4>Consider Threading</h4>
            <ul>
                <li>The standard C# collection classes are not "thread safe".</li>
                <li>If several processes attempt to interact with a non-thread safe object, it can lead to data being
                    lost of duplicated in ways that can be very hard to debug, because the nature of the error and when
                    it occurs may be dependent on system loading and timing conditions that are hard to replicate.</li>
            </ul>
            <h4>Use the Correct Kind of Collection</h4>
            <ul>
                <li>If you're processing a stream of incoming messages and then discarding them you should consider
                    using a Queue class if you want first-in, first-out (FIFO) behaviour and a stack if you want
                    last-in, first-out (LIFO) behaviour.</li>
                <li>If you plan to use an index to access elements and you know in advance how many elements there are,
                    you can use a simple array. This is useful for lookup tables.</li>
                <li>If the number of items being stored is not known in advance you can use a List&lt;T&gt; type, which
                    allows your program indexed access to given elements.</li>
                <li>If you need to perform frequent insertions and deletions of data items, and also needs to work
                    through a large list of items, you can use the LinkedList&lt;T&gt; type. This will be more efficient
                    that using an index to access elements in a sequence.</li>
                <li>If you want to store your data sorted in a particular order you can add a CompareTo behaviour to
                    your data objects, make them implement the IComparable interface and then us the Sort method in the
                    List type to perform the sorting.</li>
                <li>If you want to index your information on a key value the Dictionary&lt;TKey,TValue&gt; collection
                    class will do.</li>
                <li>If you are storing only strings you can use the StringCollection and StringList classes.</li>
            </ul>
            <h4>Plan to Work with LINQ on Your Collections</h4>
            <ul>
                <li>Any object that implements the IEnumberable or the IQueryable&lt;T&gt; interface can be acted on by
                    a LINQ query.</li>
                <li>LINQ queries are compiled into expression trees and execute very quickly.</li>
                <li>It is easy to create LINQ queryes and process their results, and the queries can produce sorted
                    results.</li>
                <li>IQueryable&lt;T&gt; is more effiecnt that IEnumerable, because it performs data filtering on the
                    source database, rather than loading all data and then filtering it to produce the result.</li>
                <li>It is advised you use LINQ for any searching and sorting operations, rather than trying to craete
                    custom data high performance storage elements.</li>
            </ul>
        </div>
        <div>
            <h3>Use the Entity Framework to Design Your Data Storage</h3>
            <ul>
                <li>The Entity Framework is part of ADO.NET (Active Data Objects) that you can use to create data
                    storage for your applications.</li>
                <li>Objects in your application can be mapped onto tables in a database that is automatically created.
                </li>
                <li>The objects are created as C# classes and the Entity Framework tools migrate these into a database
                    design.</li>
                <li>The object and database design can be updated by performing successive migrations as the application
                    evolves over time.</li>
                <li>This is a great way to create and deploy a line of business and web applications.</li>
                <li>Once you've built the model class, add a controller for that model using the Entiy Framework option.
                    This will build the code for the class design needed to create a database from.</li>
                <li>Install EntityFrameworkCore.Tools using the command:
                    <code>Install-Package Microsoft.EntityFrameworkCore.Tools</code></li>
                <li>Once the tools are loaded, create the database by performing the first migration using the command:
                    <code>Add-Migration Initial</code></li>
                <li>Now the database is created, perform an updated to create the tables that will store the class data
                    in the application. Use the command:
                    <code>Update-Database</code>
                </li>
                <li>This will result in an application that exposes data as a web page. Any data created will now be
                    persistant.</li>
            </ul>
            <h4>Model View Controller and ASP Web Pages</h4>
            <ul>
                <li>The Model View Controller (MVC) pattern makes it simpler to create complex applications by
                    separating out the activities required to build an application with a rich user interface.</li>
                <li>The model contains the data and any busines logic for the application. It also contains the state of
                    the application.</li>
                <li>In ASP, a given item in the model is exposed as an instance of a context, which provides methods
                    that can be used to interact with data.</li>
                <li>The controller responds to events that are generated by the view an selects which view to render. It
                    also initiates any changes to the model in response to a user action.</li>
                <li>The view displays what the user sees on the screen. In this case it is implemented by a web page for
                    each view.</li>
                <li>A given ASP controller class can be associated with a number of views.</li>
                <li>The HTML that describes the web page also contains embedded C# code (using an ASP.NET feature called
                    the Razor view engine) that can be used to aid with the presentation of the data.</li>
            </ul>
        </div>
        <div>
            <h3>Manage Data Integrity</h3>
            <ul>
                <li>Ensuring that your data integrity falls directly out of the need to consider security at all points
                    in the creation of your application.</li>
                <li>You need to actively consider how changes are made to your data and how these might fail or be
                    subverted and cause the data to be corrupted.</li>
                <li>Data that is managed by an object should be private to that object, and the object should provide
                    the bare minimum number of public interactions with the data.</li>
                <li>Beyond this, you should consider how object interactions can be designed to ensure that the datain
                    the objects has integrity.</li>
            </ul>
            <h4>Integrity in Method Calls</h4>
            <ul>
                <li>Parameters to method calls should be range checked to ensure that their behaviour cannot be
                    subverted to corrupt data.</li>
                <li>When passing parameters into a method call, be aware of the way that passing a method reference to
                    an object as a parameter raises the possibility that the method may make changes to the object.</li>
                <li>An action of a method that changes data outside the method is called a "side effect" of that method.
                </li>
                <li>If you want to be sure that a method can't change the contents of an object that it is given a
                    reference to, you will have to copy the object and pass the method a reference to the copy. You
                    don't need to do this if the paramter being supplied is a value type.</li>
                <li>A copy constructor can be used to achieve this. It is a constructor which takes an object of the
                    same type as a parameter, and then the values are copied over to the new instance.</li>
                <li>The use of copies of objects is also a good idea when creating multi-threaded applications. It
                    removes the possibility of other threads making changes to an object reference.</li>
                <li>When creating copies of objects, you have to be aware of the implictions of copying objects that
                    contain references to other objects.</li>
                <li>If the object contained a reference you'd have to decide whether or not to copy the nested reference
                    object as well. This is called a "deep copy", the name given to a copy process that also copies all
                    the objects referred to by an object being copied.</li>
                <li>You need to decide if you should make a "shallow copy" and risk methods not behaving as expected, or
                    put the extra effort to make a secure but computationally expensive "deep copy".</li>
            </ul>
            <h4>Risk and Impact</h4>
            <ul>
                <li>You need to consider how much risk you can tolerate at every point in your design.</li>
                <li>You also need to consider the impact of any failure of the security you have implemented to protect
                    your objects.</li>
                <li>The potential for financial loss if someone, maliciously or inadvertently, changes the Price
                    property of a MusicTrack, which means that this would have impact on the business.</li>
                <li>This would be high risk as people might stand to benefit from a price change. So extra effort into
                    protecting the Price property must be made.</li>
                <li>Decisions like this should be made at the start of the development process.</li>
            </ul>
            <h4>Atomic Actions</h4>
            <ul>
                <li>An action on a data item should be atomic. The word atomic in this context means "indivisible".</li>
                <li>If a value failed to be set when an object instance was being created you will end up with
                    incomplete data.</li>
                <li>You should have a single "atomic" action to add a new object instance which either succeeds or
                    fails. There should be no posibilty of the action half-completing and leaving the object in an
                    invalid state.</li>
            </ul>
        </div>
        <div>
            <h3>Evaluate a Regular Expression to Validate the Input Format</h3>
            <ul>
                <li>String validation of data coming into your program can be hard work.</li>
                <li>The C# string type provides methods that can be used to search a string for particular substrings.
                </li>
                <li>However, it would be hard to use just these methods to do things like validate dates, times, email
                    addresses and telephone numbers.</li>
                <li>Fortunately, C# contains an implementation of regular expressions that can be used to perform data
                    validation.</li>
                <li>A regular expression is a means of expressing a string fo characters that need to be matched in a
                    target string.</li>
            </ul>
            <h4>String Editing Using Regular Expressions</h4>
            <ul>
                <li>A regular expression can be as simple as just a single character match.</li>
                <li>The Regex object from the System.Text.RegularExpressions namespace provides a method called Replace
                    that can be used to replace regular expressions in a source string.</li>
                <li>The Replace method is supplied with paramters that specify an input string, a regular expression to
                    match, and a replacement string.</li>
                <li>Regular expressions can be used to match very complex input strings. There are a series of control
                    characters that will allow the expression to match ranges of characters in complex combinations.
                </li>
            </ul>
            <h4>Data Validation Using Regular Expressions</h4>
            <ul>
                <li>The @ prefix before a regular expression string means that the string should be processed by the
                    compiler as a verbatim string.</li>
                <li>This means that the compielr will make no attempt to process any escape sequences in the string.
                </li>
                <li>This is a good idea because regular expressions frequently contain characters that may be regarded
                    by the compiler as escape characters.</li>
                <li>The ^ (circumflex) character means "the start of a line".</li>
                <li>The | (vertical bar) characters means "or". It is used between alternative match values. It allows
                    you to create a validation string to match upper and lower-case letters, along with a space.</li>
            </ul>
        </div>
        <div>
            <h3>Use Built-in Functions to Validate Data Types and Content</h3>
            <ul>
                <li>Defensive programming is a design appraoch which views an application as a castle that must be
                    protected by a moat and a drawbridge and has guards that say "Halt. Who goes there?" to anyone
                    trying to get insides. Everything coming towards the program is viewed as malicious.</li>
                <li>Input processing should be designed in such a way as to make sure that invalid values are detected
                    and rejected.</li>
                <li>Regular expressions are a great way to ensure that data has a valid form but tehre are also some
                    built-in functions that are provided by C# to help with data validation.</li>
            </ul>
            <h4>Reading Values</h4>
            <ul>
                <li>The simplest form of conversion is taht of a string of digits into a numeric value.</li>
                <li>The C# numeric types provide a Parse method that will convert a string to a number. It will not
                    allow ivnalid strings to be converted into numbers, but rejectes invalid values by throwing an
                    exception, which seems a little extreme.</li>
                <li>It is best to reserve exceptons for events which are more unexpected.</li>
                <li>All numeric types provide a TryParse method which will attempt to parse a string and return False if
                    the parse fails. The first parameter is the string to be parsed, and the second is the variable that
                    will receive the value.</li>
                <li>The C# library also contains a Convert class that can be used to convert between various types. It
                    can even convert strings into Boolean types.</li>
                <li>The Convert method will throw an exception if the conversion fails, but not if the input value is
                    null.</li>
                <li>There are some things to consider when considering the three different ways of converting values:
                    <ul>
                        <li>int.Parse will throw an exception if supplied with a null argument or a string that does not
                            contain text that represents a valud value.</li>
                        <li>int.TryParse will return false if supplied with a null argument or a string that does not
                            contain text that represents a valud value.</li>
                        <li>Convert.ToInt32 will throw an exception if the supplied string argument does not contain
                            text that represents a valid value. It will not, however, throw an exception if the supplied
                            argument is null. Returning 0 if the supplied argument is null.</li>
                    </ul>
                </li>
            </ul>
            <h4>Validation in ASP.NET</h4>
            <ul>
                <li>Attributes can be added to the model class to restrict the values of properties.</li>
                <li>Attributes can be used to provide correct validation behaviours.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-3-2">Skill 3.2: Perform Symmetric and Asymmetric Encryption</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Choose an appropriate encryption algorithm</li>
            <li>Manage and create certificates</li>
            <li>Implement key management</li>
            <li>Implement the System.Security namespace</li>
            <li>Hashing data</li>
            <li>Encrypt streams</li>
        </ul>
        <div>
            <h3>Cryptography and Cryptoanalysis</h3>
            <ul>
                <li>Cryptography is the business of rending a message unreadable to anyone except for the proper
                    recipient of the message.</li>
                <li>It involves taing the original message and encrypting it to generate a version that can be safely
                    transferred over an open network.</li>
                <li>The recipient will perform decryption of the message to recover the original contents.</li>
                <li>Anyone else who gets a copy of the encrypted substitution will be unable to make sense of it.</li>
                <li>Cryptoanalysis is the business of code breaking.</li>
                <li>It involves examining an encrypted message and looking for statistical patterns in it that reflect
                    the language and conventions of the sender.</li>
                <li>Once these patterns have ben detected they can be used as the basis of attempts to break a code by
                    performing repeated guesses as to the encrytion method until the original message is retrieved.</li>
            </ul>
        </div>
        <div>
            <h3>Symmetric and Asymmetric Encryption</h3>
            <ul>
                <li>Symmetric encryption involves a single key which both sides of the encryption-decryption process
                    uses.</li>
                <li>The only issue with this is that if you wan to talk to someone new you have to send them a copy of
                    the key, which can be intercepted.</li>
                <li>Asymmetric encryption involves two keys, one used on either end of the process.</li>
                <li>The only issue with it is that it's very computationally expensive.</li>
                <li>Using symmetric keys is far easier, but you can get around the issue by combinging symmetric and
                    asymmetric keys.</li>
                <li>Start by making one of the asymmetric key pairs a public key. This key can be given to anyone you
                    want to have a secure connection with. The other key is kept private.</li>
                <li>Anyone with the public key can decrypt messages that have been encrypted with the private key.</li>
                <li>Anyone with the public key can encrypt messages that only you can read, because you're using the
                    private key to decrypt them.</li>
            </ul>
            <h4>Conversing Using Asymmetric Keys</h4>
            <ul>
                <li>Alice and Bob want to have a private conversaton, and Eve wants to eavesdrop. This is how Alice and
                    Bob can use asymmetric keys to talk in private:
                    <ol>
                        <li>At the start of the conversation Alice and Bob each make an asymmetric pair of keys. They
                            nominate one of their keys public and the other private.</li>
                        <li>Alice and Bob then exchange their public keys over an open network. Eve, of course, obtains
                            copies of these.</li>
                        <li>Alice and Bob now each create a symmetric key. Alice uses Bob's public key to encrypt her
                            symmetric key and send it to Bob. Eve, of course, gets a copy of this encrypted message but,
                            because she doesn't have Bob's private key, she can't decrypt it and obtain the symmetric
                            key.</li>
                        <li>Bob uses his private key to decrypt the message containing Alice's symmetric key and can use
                            this to efficiently encrypt a long message to Alice. Alice can do the same if Bob uses her
                            public key to send her an encrypted symmetric key.</li>
                        <li>Eve, in the middle, can noly see encrypted messages. The conversation between Alice and Bob
                            is private.</li>
                    </ol>
                </li>
                <li>The combination of asymmetric keys to set up the conversation, and symmetric keys to transfer the
                    data, underpines secure conversations on the internet.</li>
            </ul>
            <h4>Using Asymmetric Keys to Sign Messages</h4>
            <ul>
                <li>Another use of asymmetric keys is for signing messages. A message encoded by a private key can noly
                    be decoded by the matching public key.
                    <ol>
                        <li>Bob creates a document and also a signature or "message digest" that describes the message.
                            The signature is a tiny piece of data that can be used to authenticate the document. The
                            simplest form can be a "checksum", which is a number calculated by adding together the codes
                            of all the characters in the message.</li>
                        <li>Bob sends Alice three things: his signed document, the signature encrypted using his private
                            key, and his public key.</li>
                        <li>Alice can use the public key she receives from Bob to decrypt the message digest and compare
                            it with one that she has calculated for the document she received. If the two match she can
                            be sure that the document came from bob. She can also be sure that the document she
                            receieved has no been tampered with, as any changes would cause her calculated message
                            digest to differ from the one she receieved in the message digest.</li>
                    </ol>
                </li>
                <li>Document signing can be extended to cover items such as software downloads and system updates. It
                    this how you can be sure that messages you receive are actually from the correct person.</li>
            </ul>
        </div>
        <div>
            <h3>Data Encryption Using AES Symmetric Encryption</h3>
            <ul>
                <li>The Advanced Encryption Standard (AES) is used worldwide to encrypt data.</li>
                <li>It supersedes the Data Encryption Standard (DES).</li>
                <li>AES is a symmetric encryption system.</li>
                <li>Encrypted messages and the keys that are used to perform the encryption are stored in arrays of
                    bytes.</li>
                <li>The initialization vector adds security to a particular key value by specifiying a random start
                    point in the stream of encryption values that will be produced to encrypt the input.</li>
                <li>If every encryption started at the beginning of the encryption stream, there is a chance that the
                    repeated use of a particular encryption key provides a large enough set of encrypted messages for an
                    eavesdropper to break the code.</li>
                <li>By using a different initialization vector for each message, you can remove this possibility.</li>
                <li>The receiver will need both the key and the initialization vector value to decrypt the code.</li>
                <li>The Aes class provides options that allow you to set the length of the key used. Longer keys mean
                    greater security, but slower encrpytion and decryption.</li>
            </ul>
        </div>
        <div>
            <h3>Encrypting Data Using Other Symmetric Standards</h3>
            <ul>
                <li>The encryption process in .NET is an example of good class design. All of the encryption classes,
                    including Aes, are extensions of the base class SymmetricAlgorithm, which is in the
                    System.Security.Cryptography namespace.</li>
                <li>There are a number of other encryption implementations you can use in a program including the Data
                    Encryption Standard (DES), RC2, Rijndael, and Triple DES.</li>
                <li>DES was developed in the 1970s. Advances in computer power and cryptoanalysis mean that this
                    standard is now regarded as insecure.</li>
                <li>DES should only be used for compatability with legacy systems. Any new systems requiring data
                    encryption should use AES.</li>
                <li>RC2 is also supported by .NET, but is also now regarded as insecure. This should also only be used
                    if working with an existing system that uses it.</li>
                <li>Rijndael is the cypher on which AES was based. AES is implemented as a subset of Rijndael.</li>
                <li>TripleDES improves on the security of the DES standard by encrypting the incoming data three times
                    in succession using three different keys. The electronic payment industry make use of TripleDES.
                </li>
            </ul>
            <h4>Use RSA Asymmetric Encryption to Create Public and Private Keys</h4>
            <ul>
                <li>Rivest-Shamir-Adleman (RSA) is a very popular asymmetric encryption standard.</li>
                <li>The RSACryptoServiceProvider class in the System.Security.Cryptography namespace will perform
                    encryption and decryption using this standard.</li>
            </ul>
        </div>
        <div>
            <h3>Implementing Public and Private Key Management</h3>
            <ul>
                <li>The RSACryptoServiceProvider class provides methods that can be used to extract the public and
                    private keys from an instance.</li>
                <li>These can then be sent to a recipient who can use them to encrypt and decrypt messages.</li>
                <li>The ToXmlString method will return either the public or the public and private keys, depending on
                    the value of a Boolean argument.</li>
                <li>Once the XML has been sent to the recipient it can be used to configure an RSACryptoServiceProvider
                    isntance by using the FromXmlString method.</li>
                <li>This works well, but it means that the user of the encryption service has to find a secure place to
                    store the key file. It is important that this is stored somewhere safe, because it contains the
                    private key.</li>
            </ul>
            <h4>User Level Key Storage</h4>
            <ul>
                <li>There is a secure key storage facility provided for each user of a computer.</li>
                <li>When you create a new instance of RSACryptoServiceProvider you can tell the instance to use a
                    particular location in this storage to save and load keys.</li>
                <li>The CspParameters class from the System.Security.Cryptography can be used to specify the storage
                    location.</li>
                <li>If you want to delete a stored key you can set the PersistKeyInCsp property of the
                    RSACryptoServiceProvider instance to False and the clear the service.</li>
            </ul>
            <h4>Machine Level Key Storage</h4>
            <ul>
                <li>User level key storage is fine if a machine only has one user, but if keys are to be shared among
                    many users, they should be stored at a macine level.</li>
                <li>Windows implements machine level key storage in a folder that contains a file for each key.</li>
                <li>The path to this folder on Windows 10 is usally C:\ProgramData\Microsoft\Crypto\RSA\MachineKeys.
                </li>
                <li>Once the keys have been saved, they will be loaded from the store the next time the program runs.
                </li>
                <li>A machine level key is removed in just the same way as a user key, by setting the PersistKeyInCsp
                    property to False.</li>
            </ul>
        </div>
        <div>
            <h3>Digital Signatures and Certificates</h3>
            <ul>
                <li>The flaw of this approach concerns identity validation. Consider that one day Alice receives a
                    message that is supposed to be from Bob. It contains a public key that she can use to encrypt
                    messages to Bob and use to validate messages from Bob that have been signed by him.</li>
                <li>How does Alice know this message actually came from Bob? Eve could have be pretending to be Bob and
                    trying to get Alice to have an encrypted conversation with her. Or worse still, Eve could intercept
                    a message from Bob to start a covnersation and reply to the message instead of Alice.</li>
                <li>Alice could be receiving a public key that is being sent by Eve pretending to be Bob. Eve could be
                    sittingin the middle, using the "real" public key she received from Bob and then re-encrypting the
                    messages and passing them on to Alice.</li>
                <li>Without some form of identiy validation, Alice has no way of knowing whether the sender of a message
                    is who they claim to be. You need an authority that can be used to validate the idenity of the
                    sender of a message.</li>
                <li>There are a number of Certification Authorities that do this online. They produce digital
                    certificates for use when signing messages.</li>
                <li>Bob can register with a certification authority, providing his details upon request. Alice can ask
                    the relevant authority for the public portion of Bob's certificate and use this to validate a
                    message claiming to come from him.</li>
                <li>The process is used every time your computer contacts a web site. Your computer contains a list of
                    certification authorities and also provides a certificate store.</li>
            </ul>
            <h4>Signing Documents Using Certificates</h4>
            <ul>
                <li>You can test code taht uses certificates to sign documents.</li>
                <li>Firstly, you need to create a test certificate. This can't be used for real validation because it
                    was created by us, and not a trusted certification authority.</li>
                <li>Visual Studio provides a prompt which can be used to make an X.509 certificate:
                    <code>makecert democert.cer</code>
                </li>
                <li>You will need to create this certiciate in a folder where you have write permissions. You can also
                    put the certificate into the certificate store on your machine. The following creates a certificate
                    with the name "AlexEbbage" in a certificate store called "demoCertStore":
                    <code>makecert -n "CN=AlexEbbage" -sr currentuser -ss demoCertStore</code>
                </li>
                <li>You can use this certificate to perform encryption and also sign documents.</li>
                <li>You can think of the certificate store as very similar to the machine key storage, but the
                    certificate store contains trusted items.</li>
            </ul>
        </div>
        <div>
            <h3>Implement the System.Security Namespace</h3>
            <ul>
                <li>The System.Securiy namespace contains the cryptography classes that can be used to encrypt and
                    decrypt data.</li>
                <li>All the encryption classes are extensions of the abstract base class SymmetricAlgorithm.</li>
                <li>If you want to implement your own encryption technology you canc reate an encryption class that
                    extends the SymmetricAlgorithm class and implements its own encryption and decryption.</li>
                <li>Your class can be used interchangeably with other encryption classes on your machine, but it is
                    strongly encouraged you don't do this.</li>
                <li>The namespace also contains classes that underpin file access permissions as well as the
                    cryptography namespace that contains the algorithms used above.</li>
            </ul>
        </div>
        <div>
            <h3>Data Integrity by Hashing Data</h3>
            <ul>
                <li>You "hash" a large lump of data to create a small lump of data that is distincitve for the large
                    lump.</li>
                <li>The checksum can be a good start for a hash code, and it can be calculated bery easily using the
                    CalculateChecksum method which accepts a string and returns an integer.</li>
                <li>The checksum calculation does not take into account the order of the characters of a string, so
                    characters can be easily moved about without affecting the checksum.</li>
                <li>A hashing algorithm will weight the values in the source data according to their positions in the
                    data, so that these kinds of changes result in different hash codes being calculated.</li>
                <li>All C# objects provide a GetHash method that will return an integer hash value for that object based
                    on that objects location in memory.</li>
                <li>The hash value provided by the GetHash method is a single integer value, which is held in four bytes
                    of memory. Therefore it is going to be smaller than the data being hashed. This means that a given
                    hash value will correspond to more than one source file.</li>
                <li>The hasing algorithm provided by GetHash is good enough for use in programs so that you only want to
                    use the hash value of an object for indexing and searching, but for cryptographic appliactions you
                    need a hashing algorithm that produces a large hash value.</li>
            </ul>
            <h4>MD5 Hashing</h4>
            <ul>
                <li>The MD5 (Message Digest 5) algorithm was created in 1991 to replce MD4.</li>
                <li>It produces a hash code that is 16 bytes (128 bits) in size.</li>
                <li>It has been shown that it is possible to create different documents that have the same MD5 hash
                    code, so the algorithm should not be used for cryptographic purposes such as document signing.</li>
                <li>It can be used to detect data corruption. Corruption due to failure of a storage medium or bit
                    errors during transmission of data.</li>
                <li>The main advantage MD5 has over other hasing algorithms is that it is fast.</li>
            </ul>
            <h4>SHA1 Hashing</h4>
            <ul>
                <li>Secure Hash Algorithm 1 (SHA1) is a hash algorith that produces a 20 byte (160 bit) hash code value.
                </li>
                <li>While it's better than MD5 it has been shown to be vulnerable to brute force attacks.</li>
            </ul>
            <h4>SHA2 Hashing</h4>
            <ul>
                <li>SHA2 improves on SHA1 and is actually a family of six hash functions that can produce outputs that
                    are 224, 256, 384 or 512 bits in size.</li>
                <li>The key generated is much longer than the others, so it is normally applied to much larger datasets.
                </li>
                <li>It is vulnerable to "length extension attacks", where a malicious person can add to the end of an
                    existing document without changing the hash code.</li>
                <li>The SHA3 standard addresses this, but it is not presently available from the Security.Cryptography
                    namespace.</li>
            </ul>
        </div>
        <div>
            <h3>Encrypting Streams</h3>
            <ul>
                <li>The symmetric encryption uses a CryptoStream object that acts as a Stream object and can be chained
                    togetehr with other objects that implement the behaviour of a stream.</li>
                <li>A MemoryStream instance can be used to connect to a CryptoStream, but you can connect a stream type
                    to any other stream type.</li>
                <li>CryptoStream instance can even be chained together so you can implement additional security by
                    "double encrypting" data.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-3-3">Skill 3.3: Manage Assemblies</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Version assemblies</li>
            <li>Sign assemblies using strong names</li>
            <li>Implement side-by-side hosting</li>
            <li>Put an assembly in the global assembly cache</li>
            <li>Create a WinMD assembly</li>
        </ul>
        <div>
            <h3>Version Assemblies</h3>
            <ul>
                <li>Earlier versions of Windows also used dynamically loaded libraries to build large applications.</li>
                <li>The library files were loaded when required and some library files were shared between multiple
                    appliactions running on a machine.</li>
                <li>This was a good idea at the time, as it save memory, allowing a system to simultaneously host a
                    large number of applications.</li>
                <li>Sharing libraries causes problems when applications become dependent on particular versions of
                    shared library files.</li>
                <li>It was frequently the case that installign a nwe pplication would break applications already on a
                    machine because the installation process replaced one of th shared libraries with a version
                    incompatible with the other program on the machine. AKA "DLL Hell".</li>
                <li>The manifest for an assemvly contains a description of the contents of the assembly. It also
                    contains a list of all the assemblies that this assembly uses.</li>
                <li>The version information is added by Visual Studio when the application is built.</li>
                <li>When the application runs, the .NET runtime environment can ensure that the version of the library
                    that is loaded matches the one that is required. If the versions don't match the application won't
                    run.</li>
                <li>The information is stored in a file called AssemblyInfo.cs, which is held in the properties folder
                    for the Visual Studio solution.</li>
                <li>The version number of an assembly is expressed as four values separated by the period character:
                    <code>{Major version}.{Minor version}.{Build number}.{Revision}</code>
                </li>
                <li>The major version should be increased with each major release. Major releases contain new features
                    and/or breaking changes.</li>
                <li>The minor version increases when smaller changes are made to the assembly.</li>
                <li>The build number is used by the build server to identify builds so that they can be tracked.</li>
                <li>The revision number is used to track patched versions in the production environment.</li>
            </ul>
        </div>
        <div>
            <h3>Sign Assemblies Using Strong Names</h3>
            <ul>
                <li>A strong-named assembly is signed and validated using the same public/private key arrangement. There
                    are a number of advantages to using strong-named assemblies:
                    <ul>
                        <li>Version checking of assemblies only takes place when they are signed with strong names.</li>
                        <li>A strong-named assembly can only be used in an application with other strong-named
                            assemblies. This ensures that an entire application has integrity.</li>
                        <li>A strong-named assembly can be loaded into the Global Assembly Cache (GAC), which provides
                            performance inmporvements and alows assemblies to be shared among applications.</li>
                        <li>A strong-named assembly has a unique name that is generated using the pivrate key when the
                            assembly is signed. This allows multiple versions of the same assembly to exist side-by-side
                            on a system. Because the manifest of an assembly contains the strong name of the other
                            assemblies that it wishes to use; tehre is no possibility of name confusion leading to "DLL
                            hell".</li>
                    </ul>
                </li>
                <li>The command line tool "sn" can be used to generate public and private keys used to sign an assembly.
                    You can also generate key files by selecting the Sign tab in the properties for an assembly project.
                </li>
                <li>An assembly that has been given a strong-name contains the public key that can be used to validate
                    its signature. The public key is placed in the manifest assembly.</li>
            </ul>
            <h4>Fully Qualified Assembly Name and Public Key Token</h4>
            <ul>
                <li>A strong-named assembly has a fuly qualified name thatis made up of the assembly's name, the culture
                    of the assembly, the public key token, and a version number.</li>
                <li>The public key token is a 64-bit (8 byte) hash of the public key in the strong-name.</li>
                <li>It ensures that every fully qualified assembly name is unique.</li>
                <li>You can use reflection to obtain the fully qualified name of an assembly from the FullName property.
                </li>
            </ul>
            <h4>Delay Signing</h4>
            <ul>
                <li>The key file that is used to sign the assembly contains the private key that is used to sign
                    assemblies.</li>
                <li>This should be kept securely (not uploaded to GitHub) as it allows antone to create strong-named
                    assemblies signed with that key.</li>
                <li>An organization usnig signed assemblies can use "Delay Signing" of assemblies to reduce the chance
                    of the private key falling into the wrong hands.</li>
                <li>In the case of Delay Signing the key that is used to sign the assemblies during production is the
                    public key of the key pair and attributes are added to the assembly to indicate that Delay Signing
                    is being used.</li>
                <li>During the final build process distributing the application, the assemblies can be signed with the
                    private key.</li>
            </ul>
            <h4>Limitations of Strong-names</h4>
            <ul>
                <li>Strong-names prevent "DLL Hell" by giving every assembly a unique name.</li>
                <li>They prevent tampering with the contents of an assembly and they also prevent the substituion of one
                    assembly for another.</li>
                <li>However, giving an assembly a strong-name does not protect the contents of the assembly, nor does it
                    prove the idenity of the person who created the assembly.</li>
                <li>Anyone can use ildasm to view the contents of an assembly with a strong-name; including the actual
                    program code in the applications.</li>
                <li>If you create and distribute applications you can use digital certificate provided by Authenticode
                    to sign code and identify yourself as the publisher of the code.</li>
                <li>If you publish applications in Windows Store, this certification process happens automatically and a
                    certificate is created that identifies you as the publisher of the application.</li>
            </ul>
        </div>
        <div>
            <h3>The Global Assembly Cache (GAC)</h3>
            <ul>
                <li>When the .EXE assembly is executed it will load the other assemblies as required, which works weel
                    as a deployment model for individual applications.</li>
                <li>However, you might want to share a particular assembly among a number of different applications that
                    you have created, which can be done by putting the assembly in the Global Assembly Cache (GAC).</li>
                <li>The GAC is implemented as a folder named assembly, which is stored in the Windows folder on the
                    machine.</li>
                <li>During the installation of the application a copy of the assembly is placed into this folder.</li>
                <li>When the .NET Runtime searches for an assembly it automatically looks for the assembly in the GAC,
                    among other places.</li>
            </ul>
        </div>
        <div>
            <h3>Implement Side-by-side Hosting</h3>
            <ul>
                <li>All assemblies in the GAC are strong-named and so can be uniquely identified via its fully qualified
                    name.</li>
                <li>This makes it possible for the GAC to contain multiple versions of the same assembly. This is called
                    side-by-side hosting of assemblies.</li>
                <li>The manifest of ana seembly contains referencs to the specific assembly version it works with.
                    Removing the possibility of "DLL Hell" in .NET applications.</li>
                <li>A new "side hosted" version of an assembly that has a different fully qualified name is only
                    associated with assemblies that specify that they want to use the new version of the assembly.</li>
            </ul>
            <h4>Assembly Binding Redirection</h4>
            <ul>
                <li>Side-by-side hosting works because the assemblies used by a particular application are explicitly
                    specified in the manifest for the application.</li>
                <li>However, this can lead to problesms during the lifecycle of an application. If you fix a bug in a
                    shared assembly you can deploy a new version of the assembly into the GAC alongside the original,
                    but it will not be used because all of the existing applications contain references to original.
                </li>
                <li>The problem can be addressed by creating assembly binding redirection, which modifies the behaviour
                    of the GAC so that when a module asks for the faulty assembly the request is redireced to the
                    assembly that contains the fixed code.</li>
                <li>The redirection can be specified at 3 levels: the application level, the published level and the
                    machine level. In each you can add a policy file to specify that an application requests a
                    particular assembly it should be redirected to the replacement.</li>
                <li>The policy file for an applicaton has the same name as the application executable file with the
                    language extension ".config". It is an XML formatted file that contains application configuration
                    options for a specific applicaiton.</li>
                <li>The replacement assembly must have the same publicKeyTokrn value. This ensures that only the
                    original publisher of an assembly can release replacement versions. This is applied during the
                    installation of a service pack or an update to an application.</li>
                <li>A configuration can be applied at the nmachine level. By adding entries into the system wide
                    machine.config file, a system administrator can redirect all of the applications on a machine to use
                    particular versions of assemblies.</li>
            </ul>
        </div>
        <div>
            <h3>Put an Assembly in the Global Assembly Cache</h3>
            <ul>
                <li>The primary reason for placing assemblies in the GAC is to allow them to be shared between
                    applications.</li>
                <li>It might also be done to prevent them from being removed from the systemm; only system administators
                    can remove assemblies from the GAC.</li>
                <li>Finally, it might be to take advantage of the ability to implement side by side versions of
                    assemblies and to perform assembly binding redirection.</li>
                <li>Developers can add assemblies into the GAC as part of the setup process, or with gacutil (Global
                    Assembly Cache tool) during development.</li>
            </ul>
        </div>
        <div>
            <h3>Create a WinMD Assembly</h3>
            <ul>
                <li>Assemblies contain MSIL code that implements its behaviours.</li>
                <li>The MSIL code is produced by compiling a language like C# or VB.</li>
                <li>The MSIL will be "Just In Time" compiled for the target platform when the assembly is loaded and
                    methods in the assembly are called.</li>
                <li>The MSIl code runs inside a maanged code environment.</li>
                <li>The runtime element of an OS starts programs running and manages their execution. When a C# program
                    is started, the .NET runtime opens the startig assembly, finds the entry point, and begins running
                    the program.</li>
                <li>When Windows 8 released, Microsoft introduced a new WinRT runtime, which is written in C++.</li>
                <li>WintRT runtime is completely different from Windows 8 RT, which was a version of Windows developed
                    for use with ARm processors.</li>
                <li>WinRT was created to provide the same level of support for C++ application components provided by
                    .NET assemblies.</li>
                <li>The informaton about a WinRT component is held in a WinMD (Windows Metadata) file. It might contain
                    both metadata and executable code, or it might just contain metadata and serve as a "wrapper" for an
                    existing block of compiled code.</li>
                <li>WinRT has evolved into one of the technologies that underpins the Universal Windows Platform.
                    Allowing Windows applications to be created and deployed across a wide range of different devices.
                </li>
                <li>WinRT allows programmers to create portable C++ applications that can run on devices supported by
                    Windows OS.</li>
                <li>WinRT applications interact with the OS via WinMD files that expose all of the API elements of
                    Windows.</li>
                <li>C# classes that are used in Windows Runtime Components are subject to a few limitations, so that
                    their behaviours conform with the C++ origins of WinRT:
                    <ul>
                        <li>You must use Windows Runtime types for all the member variables, fields, and return values
                            in your classes.</li>
                        <li>It is not possible to use generics in your programs.</li>
                        <li>A class can only implement Windows Runtime interfaces.</li>
                        <li>A class can only derive from Windows Runtime classes.</li>
                        <li>Public classes must be sealed (i.e. nothing can derive from them).</li>
                        <li>Public structures must contain only public members, which must be strings or value types.
                        </li>
                        <li>The namespace of a public type must match the name of the assembly.</li>
                        <li>Public member types must not have names that start with the word "Windows".</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-3-4">Skill 3.4: Debug An Application</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Create and manage preprocessor compiler directives</li>
            <li>Choose an appropriate build type</li>
            <li>Manage programming program database files and debug symbols</li>
        </ul>
        <div>
            <h3>Create and Manage Preprocessor Compiler Directives</h3>
            <ul>
                <li>The C# compiler is a program that takes the C# source code and converts it into the Microsoft
                    Intermediate Language (MSL) code that will be stored in the assembly file output.</li>
                <li>The compilers behaviour can be modified by giving it compuler directives which are commands that are
                    pre-ceded by the # character.</li>
                <li>These commands are also known as preprocessor directives.</li>
                <li>An explicit part of the compilation process in which the program source file is scanned and
                    preprocessor directives are acted on.</li>
                <li>The C and C++ pre-processor nuderstands a wide range of commands that allow programmers to create
                    and trigger pre-built macros, swap one symbol in a program for another, and even include the
                    contents of one source file in another.</li>
                <li>The C# compiler directives are more limited in scope, but they are still very useful.</li>
            </ul>
            <h4>Use the #if Directive to Control Code Compilation</h4>
            <ul>
                <li>Code instrumentation is when you add code that produces diagnostic messages to your program.</li>
                <li>Boolean flags can be used to determine whether or not to produce dianostic output. This adds extra
                    code which increases the file size and slows the performance of the shipped product.</li>
                <li>The #if compiler directive can be used to control whether or not a particular set of statements in a
                    program are actually processed by the compiler.</li>
                <li>It is used with the #define directive that lts us define a symbol that controls the behaviour of the
                    #if.</li>
                <li>If the symbol is defined at the top of the program then the code within the #if and #endif
                    directives will be compiled, otherwise, it'll be grayed out and inactive.</li>
                <li>Conditonal compilations symbols can be defiend in the proeprties of an application. Multiple symbols
                    can be defined if separated by a semicolon.</li>
                <li>The #else directive can be used to perform code when a symbol isn't defined.</li>
                <li>The #elif directive can be used to perform an alternate #if condition.</li>
                <li>The #undef directive can undefine any symbol that might have been defined outside the program, but
                    must be at the very start of the program file.</li>
                <li>Use it with care as it makes the code much harder to read and the developers need to be aware which
                    symbols are defined.</li>
                <li>They can be good for single version programs that need to run on multiple platforms. Though this
                    need is greatly reduced thanks to Universal Applications.</li>
            </ul>
            <h4>Manage Method Execution with the Conditional Attribute</h4>
            <ul>
                <li>You can use the Conditonal attribute to enable and disable a method in your program.</li>
                <li>The attribute is defined in the System.Diagnostics namespace and can be used to flag a method as to
                    only be executed if a given conditional compilation symbol is defined.</li>
                <li>It can be passed a symbol to make the method active or inactive based on whether or not the symbol
                    is defined.</li>
                <li>The conditional attribute doesn't control whether or not the method is included in the compiled
                    assembly file output By the compiler.</li>
            </ul>
            <h4>Mark Code as Obsolete using the Obsolete Directive</h4>
            <ul>
                <li>Classes, interfaces, method and properties can be marked with the Obselete attribute to indicate
                    that they have been superseded by newer versions.</li>
                <li>The Obsolete attribute is applied to the superseded element and given a message and a boolean value
                    that indicates whether the compiler warning (false) or an error (true) should be produced if the
                    element with the attribute is used by the program.</li>
            </ul>
            <h4>Control Compilation with Warning and Error Directives</h4>
            <ul>
                <li>The #warning and #error directievs allow you to produce a compiler warning or even prevent
                    compilation of a source code file.</li>
                <li>The #error directive causes a compilation error to be produced. It is used to prevent the
                    compilation of a source code file with an invalid combination of conditional configuration options.
                </li>
            </ul>
            <h4>Manage Compilers Warning Reporting with the Pragma Directive</h4>
            <ul>
                <li>The #pragma warning directive can be used to disable warning reporting for a region of code.</li>
                <li>#pragma warning disable and #pragma warning restore are used to open and close a block where
                    warnings are ignored.</li>
                <li>Warning filtering can be improved by specifying the warning you want the compiler to ignore.
                    Multiples warning can be specified using a comma separated list.</li>
            </ul>
            <h4>Identify Error Positions with #line</h4>
            <ul>
                <li>The line numbers in error reports aren't always accurate due to auto-generated elements.</li>
                <li>The #line directive can be used to set the reported line numbers of statements in yor code.</li>
                <li>It can also be used to specify the file name delivered the error reporting.</li>
                <li>The #line default directive statement resume normal line number and source file name reporting.</li>
            </ul>
            <h4>Hide Code Using #line</h4>
            <ul>
                <li>Another use of the #line directive is to hide code statements from the debugger.</li>
                <li>This can be useful if your source code contains programmatically generated elements. You don't want
                    to have to step through all the programmatically generated statements when debugging.</li>
                <li>The #line hidden statement is used to prevent the debugger stepping through a block of code.</li>
            </ul>
            <h4>Use DebuggerStepThrough to Prevent Debugger Stepping</h4>
            <ul>
                <li>The DebuggerStepThrough attribute can be used to mark a method or class so that the debugger will
                    not debug each statement in turn when single stepping through the code in that method or class.</li>
                <li>This can be useful when the program contains programmatically generated elements that you don't want
                    to step through.</li>
                <li>Note that if you use this attribute on a class, none of the methods in the class will be stepped
                    through by the debugger.</li>
                <li>No breakpoints contained within elements marked with this attribute will be hit either.</li>
            </ul>
        </div>
        <div>
            <h3>Choose an Appropriate Build Configuration</h3>
            <ul>
                <li>The build configuration of your program controls the settings that are applied to the build process.
                </li>
                <li>The default configurations available are Debug and Release.</li>
                <li>The MSIL file generated by the Debug mode contains statements that declare and initialize unused
                    varaibles, whereas the Release file does not.</li>
                <li>The Debug file also contains nop (no operation) statements, which do nothing when the program runs.
                    They only serve as locations in the program that can be used as breakpoints.</li>
                <li>As breakpoints are only used in debugging, these get omitted in the Release build.</li>
                <li>The Release build may contain other differences such as "inline" implementations of short methods.
                    The compiler may decide the program runs faster if the method body was copied "inline" each time the
                    emthod is called, rather than generating the instructions that manage a method call.</li>
                <li>A Release build may also be more aggressive about the removal of objects as it runs, meaning the
                    finalizer methods are more likely to be called on objects. Usually they will perform the same but
                    you should be aware they can be different.</li>
                <li>The Configuration Manager can be used to make custom builds which are configured to target
                    particular processor platforms.</li>
            </ul>
        </div>
        <div>
            <h3>Manage Programming Program Database Files and Debug Symbols</h3>
            <ul>
                <li>The Program Debug Database (.pdb) file is produced when the program is compiled.</li>
                <li>It is sometimes known as the symbol file.</li>
                <li>It contains debugger information, including a mapping of the program source code to the compiled
                    statements, and the names of all the symbols in the program along with their addresses in the
                    program memory space.</li>
                <li>A new PDD is generated each time a program is compiles.</li>
                <li>A database file contains a Globally Unique Identifier (GUID), which is also held in the executable
                    file which the debug database is associated.</li>
                <li>When the debug database is opened this value is checked, and only the database with the matching
                    GUID can be used.</li>
            </ul>
            <h4>Symbol Servers</h4>
            <ul>
                <li>A symbol server provides debug database information to a program in place of local debug database
                    file.</li>
                <li>If you really want to step through the Microsoft elements of a program you can connect Visual Studio
                    to a Symbol Server that provides the information that would normally be in the debug database.</li>
                <li>To do this, and maange the use of other symbol servers, you can use the Debugging element of Visual
                    Studio options.</li>
                <li>New locations can be added for symbol files that are to be used with deugging, and you can also
                    request the application connects to the Microsoft Symbol servers when the program runs.</li>
                <li>The dialog also shows where program debug symbols should be cached on the machine.</li>
                <li>Visual Studio will keep local copies of debug database information to reduce the amount of network
                    traffic that is generated during debuging.</li>
                <li>If you use TFS to maange your projects, you have the opton of saving all debug data files to a
                    central server from which they can be accessed as required.</li>
            </ul>
            <h4>Public and Private Symbols</h4>
            <ul>
                <li>A program debug file can contain prublic and private symbol information.</li>
                <li>The public information contains descriptions of public elements in that assembly.</li>
                <li>The private information also cotnains descriptions of things like private methods and local
                    variables.</li>
                <li>Visual Studio creates debug files that contain both private and public components.</li>
                <li>You might not want other people to be able to see information about private elements in your
                    solution.</li>
                <li>The pdbcopy tool can be used to make a copy of a pdfb file and remove all the private elements. It
                    can also be provided with a list of symbols to remove.</li>
                <li>The output of the pdbcopy has the same GUID as an incoming file, so it can be used with the same
                    executable file.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-3-5">Skill 3.5: Implement Diagnostics in an Application</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>Implement logging and tracing</li>
            <li>Profiling applications</li>
            <li>Create and montior performance counters</li>
            <li>Write to the event log</li>
        </ul>
        <div>
            <h3>Implement Logging and Tracing</h3>
            <ul>
                <li>Sometimes a failure occurs behind something that prevents direct access to the broken code.</li>
                <li>In this situation, diagnostics information in the form of logs and traces of program execution will
                    be crucial in discovering what went wrong.</li>
                <li>Information generated by logging and tracing can allow you to determine the loading levels and the
                    nature of transactions being performed on the customer site.</li>
                <li>Logging can be used to find out what a program is doing and what happened when it failed.</li>
                <li>Tracing is used to discover the path followed by the program to perform a particular action.</li>
            </ul>
            <h4>Trace Execution Using Debug and Trace</h4>
            <ul>
                <li>The System.Diagnostics namespace contains Debug and Trace classes that can be used to trace the
                    execution of a program.</li>
                <li>WriteLineIf() can be used to write a debug message if a given condition is true.</li>
                <li>By default, the output from the Debug statements is directed to the output window in Visual Studio.
                </li>
                <li>If the program is not compiled for debug, the debug statemnts are not included in the program that
                    is produced. Debug code useses a conditional attribute to disable these methods when the debug
                    symbol is not defined.</li>
                <li>The Trace objects can be used in the same way as the Debug object to add tracing output to
                    production code.</li>
                <li>The Trace object provides additonal messages; TraceInformation, TraceWarning, and TraceError methods
                    can be used to specify the importance of a message.</li>
            </ul>
        </div>
        <div>
            <h3>Use Assertions in Debug and Trace</h3>
            <ul>
                <li>An assertion is a statement that you make, believing it to be true.</li>
                <li>When my program fails, the first thing to do is make sure that all the assertions about the state of
                    the program are actually true.</li>
                <li>Debug.Assert() can be used to perform this test when the program is running. The Trace class has the
                    same method.</li>
                <li>It is provided with a Boolean parameter which, if true, means the assertion is correct and the
                    program continues. If false, the assertion fails and the program will display a message offering the
                    developer the option to continue.</li>
            </ul>
            <h4>Use Listeners to Gather Tracing Information</h4>
            <ul>
                <li>By default the output from the Debug and Trace classes is sent to the output window in Visual
                    Studio.</li>
                <li>This works in development, but after deployment listener objects must be added to Debug and Trace,
                    which serve as destinations for tracing information.
                    <code>TraceListener consoleListener = new ConsoleTraceListener();
                        Trace.Listeners.Add(consoleListener);
                        Trace.TraceInformation("This is an information message");
                        Trace.TraceWarning("This is a warning message");
                        Trace.TraceError("This is an error message");
                    </code>
                </li>
                <li>There are a number of different TraceListener objects that can be created. You can also create your
                    own custom one:
                    <table>
                        <th>
                        <td>Class Name</td>
                        <td>Output</td>
                        </th>
                        <tr>
                            <td>ConsoleTraceListener</td>
                            <td>Sends the output to the console.</td>
                        </tr>
                        <tr>
                            <td>DelimitedTextTraceListener</td>
                            <td>Sends the ouput to a TextWriter.</td>
                        </tr>
                        <tr>
                            <td>EventLogTraceListener</td>
                            <td>Sends the output to the Event log.</td>
                        </tr>
                        <tr>
                            <td>EventSchemaTraceListener</td>
                            <td>Sends the output to an XML encoded file compliant with the Event log schema.</td>
                        </tr>
                        <tr>
                            <td>TextWriterTraceListener</td>
                            <td>Sends the output to a given TextWriter.</td>
                        </tr>
                        <tr>
                            <td>XMLWriterTraceListener</td>
                            <td>Sends XML formatted output to an XML writer.</td>
                        </tr>
                    </table>
                </li>
                <li>Multiple listeners can be given to a single tracing source so that tracing information can be sent
                    to both the console, and an XML log file if you wish.</li>
                <li>Listeners can be removed from the Listeners collection as well.</li>
            </ul>
            <h4>Trace Using the TraceSource Class</h4>
            <ul>
                <li>The TraceSource class offers a more managed approach to program tracing.</li>
                <li>An instance will create events that can be used to trace program execution.</li>
                <li>This example creates four events. The simplest event contains event type information and an event
                    number. A text string can be added to an event, and the TraceData method also allows information to
                    be added to an event in the form of a collection of object references.
                    <code>
                        TraceSource trace = new TraceSource("Tracer", SourceLevels.All);
                        trace.TraceEvent(TraceEventType.Start, 10000);
                        trace.TraceEvent(TraceEventType.Warning, 10001);
                        trace.TraceEvent(TraceEventType.Verbose, 10002, "At the end of the program");
                        trace.TraceEvent(TraceEventType.Information, 10003, new object[]{ "Note 1", "Message 2"});
                        trace.Flush();
                        trace.Close();
                    </code>
                </li>
                <li>The event number is just an integer used for identificaiton. They can be used to represent
                    particular events.</li>
                <li>There are a range of event types that are specified by a value of type TraceEventType. The event
                    types, in increasing order of significance are:
                    <ul>
                        <li><b>Stop, Start, Suspend, Resume, Transfer:</b> These are activity event types. Used to
                            indicate events that occur during normal operation. They don't reflect any error conditions.
                        </li>
                        <li><b>Verbose:</b> This indicates events that provide detailed information about normal
                            operations. This may include messages that are produced when methods are entered and exited,
                            or objects created and destroyed.</li>
                        <li><b>Information:</b> This indicates events that provide significant information about
                            operation; perhaps that transaction has started or ended.</li>
                        <li><b>Warning:</b> This indicates a warning event. Perhaps a login has failed, an operation
                            took longer to complete than expected or a resource such as memory is becoming low.</li>
                        <li><b>Error:</b> This indicates an error has been detected and dealt with by the application.
                            Perhaps some incoming data was provided in the wrong format, or an operation did not
                            complete and was re-tried.</li>
                        <li><b>Critical:</b> This indicates that the application has reached a point where it cannot
                            continue. Perhaps an exception was raised that the exception handler doesn't recognize, or a
                            resource or connection is not longer available.</li>
                    </ul>
                </li>
            </ul>
            <h4>Use TraceSwitch to Control Tracing Output</h4>
            <ul>
                <li>The TraceSwitch object is provided to help manage tracing output from a program in the form of a
                    Level property that determines the level of tracing output produced.</li>
                <li>This example shows a TraceSwitch instance being used to set the trace level, and it being used to
                    control tracing output.
                    <code>
                        TraceSwitch control = new TraceSwitch("Control", "Control the trace output");
                        control.Level = TraceLevel.Warning;

                        if(control.TraceError){
                        Console.WriteLine("An error has occurred");
                        }

                        Trace.WriteLine(Control.TraceWarning, "A warning message");
                    </code>
                </li>
            </ul>
            <h4>Use SourceSwitch to Control Tracing</h4>
            <ul>
                <li>The SourceSwitch can be used to directly control the behaviour of a TraceSource object.</li>
                <li>It works the same as a TraceSwitch object.</li>
                <li>This example shows a SourceSwitch instance being assigned to the Switch property of the TraceSource object.
                    <code>
                        TraceSource trace = new TraceSource("Tracer", SourceLevels.All);

                        SourceSwitch control = new SourceSwitch("Control", "Control the tracing");
                        control.Level = SourceLevels.Information;
                        trace.Switch = control;

                        trace.TraceEvent(TraceEventType.Start, 10000);
                        trace.TraceEvent(TraceEventType.Warning, 10001);
                        trace.TraceEvent(TraceEventType.Verbose, 10002, "At the end of the program");
                        trace.TraceEvent(TraceEventType.Information, 10003, new object[]{ "Note 1", "Message 2"});
                        trace.Flush();
                        trace.Close();
                    </code>
                </li>
            </ul>
            <h4>Configure Tracing using Application Config Files</h4>
            <ul>
                <li>It is possible to configure tracing output using the application configuration file.</li>
                <li>If a switch with the name configControl is created in the config, it can be used in code like so:
                    <code>
                        TraceSource trace = new TraceSource("configControl");
                    </code>
                </li>
                <li>If switch information with the given name isn't found in the app config, a trace is created that will not output any events.</li>
            </ul>
            <h4>Advanced Tracing</h4>
            <ul>
                <li>More complex behaviours can be added to the config, including the creation and assignment of listeners to TraceSource objects.</li>
                <li>Filters can be applied to listeners, so a given listener will only receive particular levels of tracing information.</li>
                <li>There offers lot of flexibility in the tracing and logging that your application can perform.</li>
            </ul>
        </div>
        <div>
            <h3>Profiling Applications</h3>
            <ul>
                <li>One of the most common devleoper mistakes is to spend too much time optimizing a solution during development.</li>
                <li>There are much more important issues than performance, especially considering the power of modern computers.</li>
                <li>This section covers the occasions where performance can become a problem and tools which can be used to address the issue.</li>
            </ul>
            <h4>The StopWatch Class</h4>
            <ul>
                <li>The StopWatch class can be used to measure elapsed time which can then be used to compare different methods of peforming a task.</li>
                <li>It provides Start, Stop, Reset, and Restart methods.</li>
                <li>
                    <code>
                    Stopwatch stopwatch = new StopWatch();

                    stopwatch.Start();
                    sequentialTest();
                    stopwatch.Stop();
                    Console.WriteLine("Sequential time in milliseconds: {0}", stopwatch.ElapsedMilliseconds);

                    stopwatch.Restart();
                    parallelTest();
                    stopwatch.Stop();
                    Console.WriteLine("Parallel loop time in milliseconds: {0}", stopwatch.ElapsedMilliseconds);
                </code>
            </li>
            </ul>
            <h4>Profiling in Visual Studio</h4>
            <ul>
                <li>The diagnostics display in Visual Studio gives a very good overview of the performance of an application.</li>
                <li>Visual Studio 2017 contains powerful profiling tools that you can use to discover where your application is spending most of its time.</li>
                <li>Once you've determined where the slow methods are, you can focus on optimizing those methods.</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
            <h4>SUBHEADING</h4>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="qa-3">Thought Experiments</h2>
        <div>
            <h3>HEADING</h3>
            <p>DESCRIPTION</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">QUESTION</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
    </div>
</div>