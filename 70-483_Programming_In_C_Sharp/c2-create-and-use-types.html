<div>
    <h1 id="chapter-2">Chapter 2: Create and Use Types</h1>
    <p>Skills covered in this chapter are:</p>
    <ul>
        <li><a href="#skill-2-1">Skill 2.1: Creating Types</a></li>
        <li><a href="#skill-2-2">Skill 2.2: Consuming Types</a></li>
        <li><a href="#skill-2-3">Skill 2.3: Enforcing Encapsulation</a></li>
        <li><a href="#skill-2-4">Skill 2.4: Create and Implement a Class Hierarchy</a></li>
        <li><a href="#skill-2-5">Skill 2.5: Find, Execute and Create Types At Runtime</a></li>
        <li><a href="#skill-2-6">Skill 2.6: Managing the Object Lifecycle</a></li>
        <li><a href="#skill-2-7">Skill 2.7: Manipulating Strings</a></li>
        <li><a href="#qa-2">Thought Experiments</a></li>
    </ul>
    <div>
        <h2 id="skill-2-1">Skill 2.1: Creating Types</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Create value types, including structs and enum</li>
            <li>Create reference types, generic types, constructors, static variables, method, classes and extension
                methods</li>
            <li>Create optional and named paramters</li>
            <li>Create indexed properties</li>
            <li>Create overloaded and overridden methods</li>
        </ul>
        <div>
            <h3>Value and Reference Types</h3>
            <ul>
                <li>Consider you have 2 variables, x and y, and you make the statement <code>y.Data = 99; x = y; x.Data
                        = 100;</code>...</li>
                <li>If the variables x and y are value types, the value of y is copied into the variable x. The Data
                    property of y is not affected by the final assignment to x.</li>
                <li>If the variables x and y are referemce types, the variable x is made to refer to the same object as
                    that referred to by variable y. The final assignment will make the Data property of a single object
                    set to 100.</li>
                <li>Structure variables are managed by value and class variables are managed by reference.</li>
            </ul>
            <h4>Value and Referene Types in .NET</h3>
                <ul>
                    <li>A good example of a value type is the DateTime structure provided by the .NET library.</li>
                    <li>You could represent date values in the form of a collection of individual values, but assigning
                        one date to another would be time-consuming as the program would have to transfer each value.
                    </li>
                    <li>Having a DateTime type means you can move a date value between variables with a single
                        assignment. During a DateTime assignment all the values that represent the date are copied into
                        the destination variable.</li>
                    <li>A good example of a reference type is the Bitmap class from the System.Drawing library in .NET.
                    </li>
                    <li>The Bitmap class is used to create objects that hold the pixels which make up an image which
                        could be millions.</li>
                    <li>If a Bitmap is held as a value type, when one is assigned to another, all the pixels in the
                        source Bitmap must be copied from the source image into the destination.</li>
                    <li>As they are managed by reference, an assignment simply makes the destination reference refer to
                        the same object as the source reference.</li>
                </ul>
                <h4>Type Design</h3>
                    <ul>
                        <li>Using the design of a space shooter game as an example...</li>
                        <li>The location of the alien on the screen should be a value type, as you'd want the position
                            as a single value. You don't want to share coordinates between aliens.</li>
                        <li>A sound effect would be a reference type, as it'd store a large array of integer data which
                            represent a given sound. You may want serveral aliens to share the same sound.</li>
                        <li>In C#, value types are enumerated types and references. Reference types are classes.</li>
                    </ul>
                    <h4>Immutablity in Types</h3>
                        <ul>
                            <li>An immutable type is one whose instances cannot be changed.</li>
                            <li>The DateTime structure is an immutable type. Once an isntance is created you cannot
                                change any elements of that instance.</li>
                            <li>The only way to edit them is to create a new DateTime value that contains the updated
                                values.</li>
                            <li>Changing the values of an immutable type is less efficient as it requires the creation
                                of a new object each time.</li>
                            <li>However, it removes the possiblity of elements in a variable changing once created.</li>
                            <li>They are advantagous when writing concurrent programs as they can never be corrupted
                                because they can never be changed.</li>
                            <li>The string type in C# is also immutable.</li>
                        </ul>
        </div>
        <div>
            <h3>Creating Value Types</h3>
            <h4>Structures</h4>
            <ul>
                <li>Structures can contain methods, data values, properties and can have constructors.</li>
                <li>The constructor for a structure must initalize all the data members. They cannot be initalized in
                    the structure.</li>
                <li>A structure cannot have a parameterless constructor. However, a structure can be created by calling
                    a parameterless constructor which sets all elements to have default values.</li>
                <li>A structure cannot be created by extending a parent structure object.</li>
                <li>Structure isntances are generally created on the program stack unless they are used in closures.
                </li>
                <li>An array of structure instances will be created as a block of contiguous memory, which holds all the
                    required items.</li>
                <li>A structure definition can contain overrides, e.g. ToString(). A structure cannot use a class
                    hierarchy, because it is posible to override methods from the parent type of a struct.</li>
            </ul>
            <h4>Enumerated Types</h4>
            <ul>
                <li>Enumerated types are used in situations where the programemr wants to specify a range of values a
                    given type can have.</li>
                <li>For example, they might want to represent the states of an AI: sleeping, attacking or destroyed. An
                    integer could be used for this but if 1-3 are used for these states and 4 is given, it will have no
                    meaning.</li>
                <li>Unless specified otherwise, an enumerated type is based on the int type and values start from 0.
                </li>
                <li>You would do this if you want to set particular values to be used in JSON and XML files when
                    enumerated variables are stored.</li>
            </ul>
        </div>
        <div>
            <h3>Creating Reference Types</h3>
            <ul>
                <li>A class is declared in a similar manner to a structure, but the way in which they are manipulated is
                    significantly different.</li>
                <li>When a variable of a class type is declared, the variable is now a refernce to that object.</li>
            </ul>
            <h4>Memory Allocation</h4>
            <ul>
                <li>Memory used to store variables of value type is allocated on the stack.</li>
                <li>The stack is an area of memory that is allocated and removed as programs enter and leave blocks.
                </li>
                <li>Any value type variables created during the execution of a block are stored on a local stack
                    frame and then the entire frame is discarded when the block completes.</li>
                <li>This is an extremely efficient way to manage memory.</li>
                <li>Memory used to store variables of reference type is allocated on the heap.</li>
                <li>The heap is managed for an entire application.</li>
                <li>The heap is required because, as references may eb passed between method calls as paramters, it
                    is not the ase that objects managed by refence cane be discarded when a method exits.</li>
                <li>Objects can only be removed from the heap when the garbage collection process determines that
                    there are no references to them.</li>>
            </ul>
            <h4>Generic Types</h4>
            <ul>
                <li>Generic types are used extensively in C# collections, such as with the List and Dictionary
                    classes.</li>
                <li>They allow you to create a List of any type or a Dictionary of any type, indexed on any
                    type.</li>
                <li>Without generic types you either have to reduce type safety in your programs by using
                    collections that manage only objects, or you have to waste time creating collections for
                    each type.</li>
                <li>An example of a generic stack is shown below:
                    <code>
                        class MyStack&lt;T&gt;
                        {
                        <span class="i1">&nbsp;</span>int stackTop = 0;
                        <span class="i1">&nbsp;</span>T[] items = new T[100];

                        <span class="i1">&nbsp;</span>public void Push(T item)
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>if (stackTop == items.Length)
                        <span class="i3">&nbsp;</span>throw new Exception("Stack full!");
                        <span class="i2">&nbsp;</span>items[stackTop] = item;
                        <span class="i2">&nbsp;</span>stackTop++;
                        <span class="i1">&nbsp;</span>}

                        <span class="i1">&nbsp;</span>public T Pop()
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>if (stackTop == 0)
                        <span class="i3">&nbsp;</span>throw new Exception("Stack empty!");
                        <span class="i2">&nbsp;</span>stackTop--;
                        <span class="i2">&nbsp;</span>return items[stackTop];
                        <span class="i1">&nbsp;</span> }

                        <span class="i1">&nbsp;</span>static void Main(string[] args)
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>MyStack&lt;string&gt; stringStack = new
                        <span class="i2">&nbsp;</span>MyStack&lt;string&gt;();
                        <span class="i2">&nbsp;</span>stringStack.Push("Apple");
                        <span class="i2">&nbsp;</span>Console.WriteLine(stringStack.Pop());
                        <span class="i2">&nbsp;</span>Console.ReadKey();
                        <span class="i1">&nbsp;</span>}
                        }
                    </code>
                </li>
            </ul>
            <h4>Generic Contstraints</h4>
            <ul>
                <li>There are several constraints which can be applied to the class declaration to restrict types which
                    can be represented by T:
                    <ul>
                        <li><b>where T : class</b> The type T must be a reference type.</li>
                        <li><b>where T : struct</b> The type T must be a value type.</li>
                        <li><b>where T : new()</b> The type T must have a public, parameterless, constructor. Specify
                            this constraint last if you are specifying a list of constraints.</li>
                        <li><b>where T : &lt;base class&gt;</b> The type T must be of type base class or derive from
                            base class.</li>
                        <li><b>where T : &lt;interface name&gt;</b> The type T must be or implement the specifed
                            interface. You can specify multiple interfaces.</li>
                        <li><b>where T : &lt;unmanaged&gt;</b> The type T must not be a reference type or contain any
                            members which are reference types.</li>
                    </ul>
                </li>
            </ul>
            <h4>Constructors</h4>
            <ul>
                <li>A constructor allows a programmer to control the process by which objects are craeted.</li>
                <li>Constructors can be used by both reference types (classes) and value types (stuctures).</li>
                <li>A constructor has the same name as the object it is part of but does not have a return type.</li>
                <li>They can perform validation on their parameters to ensure that any objects created contain valid
                    information.</li>
                <li>If invalid, a constructor must throw an exception to prevent the creation of an object.</li>
                <li>If an object only has a private constructor, it must be instantiated using a public factory method
                    that is declared in the same class.</li>
                <li>Constructors can be overloaded, so an object can contain multiple versions of a consntructor with
                    different signatures.</li>
                <li>A program can avoid code repition by making one constructor call another constructor by the use of
                    the keyword this.</li>
            </ul>
            <h4>Static Constructors</h4>
            <ul>
                <li>A static consturctor method is called once before the creation of the very first instance of the
                    class.</li>
                <li>It is a good place to load resources and initialize values that will be ysed by instances of the
                    class.</li>
                <li>They can include values of static members of the class.</li>
            </ul>
            <h4>Static Variables</h4>
            <ul>
                <li>A static varialb eis a member of a type, but it is not created for each instance of a type.</li>
                <li>A variable in a class is made static by using the static keyword in the declaration of that
                    variable.</li>
                <li>Code outside the class must refer to static variables via the class name, rather than the name of
                    any particular instance of that class.</li>
                <li>A program can use astic variable from a type without needing to have created any instances of that
                    type.</li>
                <li>Types can also contain static methods, which can be called without the need for an instance of that
                    object.</li>
                <li>Static variables are very useful for validation values for a type.</li>
                <li>They can be made private to a class so that their values can be managed by that class.</li>
            </ul>
            <h4>Methods</h4>
            <ul>
                <li>A method is a member of a class.</li>
                <li>It has a signature and a body.</li>
                <li>The signature defines the type and number of parameters that the method will accept.</li>
                <li>The body is a block of code that is performed when the method is called.</li>
                <li>The method method has a return type other than void, all code paths through the body of the code
                    must end with a return statement that returns a value of the type of the method.</li>
                <li>The name of a method is best expressed in a "verb-noun" manner, with an action followed by the thing
                    that the action is acting on.</li>
                <li>When talking about the signature and body we talk in terms of parameters used in the method.</li>
                <li>In the case of a method call we will talk in terms of the arguments supplied to the call.</li>
            </ul>
            <h4>Classes</h4>
            <ul>
                <li>A class can be thought of as a template required to create and instance of a class.</li>
                <li>Instances of a class are created when the new keyword is used. When used, 3 things occur:
                    <ol>
                        <li>The program code that implements the class is loaded into memory, if it is not already
                            present.</li>
                        <li>If this is the first time that the class has been referenced, any static members of the
                            class are initialized and the static constructor is called.</li>
                        <li>The constructor of the class is called.</li>
                    </ol>
                </li>
                <li>A class can contain members that are methods, data variables, or properties.</li>
                <li>A class method allows a class to provide behaviours that can be used by code running in other
                    classes.</li>
                <li>Data variables allow a class to maintain state and manage the storage of information.</li>
                <li>Properties provide a means for managing access to data within a class.</li>
            </ul>
            <h4>Extenison Methods</h4>
            <ul>
                <li>Extension methods provide a way in which behaviours can be added to a class without needing to
                    extend the class itself.</li>
                <li>The first parameter to the method specifies the type that the extension method should be added to,
                    by using the this keyword followed by the name of the type.</li>
                <li>Once created, it can be used from the namespace in which the class containing the method is
                    declared.</li>
                <li>When called the compiler searches the included namespaces for a matching method for that type, and
                    then generates a call of that method.</li>
                <li>Note that extensnion methods are never part of the object they are attached to, since they can't
                    access private members of the method class.</li>
                <li>They can never be used to replace an existing method in a class.</li>
                <li>They allow you to add behaviours to existing classes and use them as if they were part of that
                    class.</li>
            </ul>
            <h4>Optional and Named Parameters</h4>
            <ul>
                <li>If you want to make method calls without worrying about the order of the arguments, you can name
                    each one when you call the method.</li>
                <li>This makes it easy for another programmer reading your code to see the meaning of each argument
                    value.</li>
                <li>Using this format also removes the possibility of any confusion of the ordering of the values in the
                    method call.</li>
                <li>You should use named paramters whenever you call a method that has more than one parameter.</li>
                <li>A paramter is made optional by giving it a default value in the defintion of the method.</li>
                <li>Optional parameters must be provided after all of the required ones.</li>
            </ul>
            <h4>Index Properties</h4>
            <ul>
                <li>A program can access a particular array element by using an index value that identifies the element.
                </li>
                <li>A class can use the same indexing mechanism to provide indexed property values.</li>
                <li>This is how the Dictionary collection is used to index on a particular type of key value.</li>
            </ul>
            <h4>Create Overload and Overridden Methods</h4>
            <ul>
                <li>Overloading is providing a method with the same name, but a different signature in a given type.
                </li>
                <li>It is useful when you want to provide several ways of performing a particular behaviour based of
                    differing circumstances.</li>
                <li>The DateTime strcture has a large number of overloaded constructors, because there are man different
                    ways a programmer might want to initalize a DateTime value.</li>
                <li>Overriding takes place when class hierarchies are used.</li>
                <li>In a class hierarchy a child class is derived from a parent or base class.</li>
                <li>A method in a base class is overridden by a method in a child when the child class contains a method
                    with exactly the same signature as the parent class.</li>
                <li>Only methods that have been marked as virtual in the parent class can be overridden.</li>
                <li>The underlying principle of a class hierarchy is that classes at the top of the hierarchy are more
                    abstract, and classes toward the bottom are more specific.</li>
                <li>The classes higher in the hierarchy hold all the behaviours that are common. While classes lower
                    down might need a more specific behavior and have to override the parent method.</li>
                <li>The whole behavior doesn't need to be rewritten. It can be extended by calling the method in the
                    parent class by using the base keyword.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-2">Skill 2.2: Consuming Types</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Box or unbox to convert between value types</li>
            <li>Cast types</li>
            <li>Convert types</li>
            <li>Handle dynamic types</li>
            <li>Ensure interoperability with unmanaged code that accesses COM APIs</li>
        </ul>
        <div>
            <h3>Boxing and Unboxing</h3>
            <ul>
                <li>From a computational point of view, value types such as int and float have the advantage that the
                    processor can manipulate value types directly.</li>
                <li>Adding two int values tofther can be acheived by fetching the values into the processor, performing
                    the addition operation, and then storing the result.</li>
                <li>It can be useful to treat value types as refrence types. C# runtime system provides a mechanism
                    called boxing that will perform this conversion whenr required.</li>
                <li>The process of converting from a reference type into a value type is called unboxing.</li>
                <li>A .NET program processes data by moving values onto a stack (evaluation stack), performing actions
                    on them, and then storing the results.</li>
                <li>The box instruction (value to reference) and unbox instruction (reference to value) are always given
                    a destination (box) or source (unbox) type to use.</li>
                <li>Each built-in C# value type has a matching C# type called its itnerface type to which it is
                    converted when boxing is performed.</li>
                <li>Fortunately for programmers, the unboxnig and boxing process happens automatically when variables
                    are converted between types.</li>
                <li>Unfortunately, these processes slow the program down.</li>
                <li>The need to box and unbox values in a solution is a symptom of poor design, you should be clear in
                    your design which data items are value types and which references, and work with them correctly.
                </li>
            </ul>
        </div>
        <div>
            <h3>Cast Types</h3>
            <ul>
                <li>Narrowing is when a value is transferred into a type which offers a narrower range of values.</li>
                <li>The integer type does not handle the fractional part of a value, and so a float value will have its
                    fractional part discarded when the assignment takes place.</li>
                <li>The above conversion would not compile unless explicit conversion is used.</li>
                <li>This is achieved by the use of a cast, which identifies the desired type of value being assigned.
                </li>
                <li>The type is given, enclosed in brackets, before the value to be converted.</li>
                <li>Widening is when a value is transferred into a type which offers a wider ranger of value. This
                    doesn't required a cast, because there is no prospect of data loss.</li>
                <li>Casting can't be used to convert between different types, like an integer to a string.</li>
                <li>Casting is also used when converting references to objects that may be part of class hierarchies or
                    expose interfaces.</li>
            </ul>
        </div>
        <div>
            <h3>Convert Types</h3>
            <ul>
                <li>You can write your own type covnersion operators for your data classes so that you can perform
                    implicit and explicit conversions between types.</li>
                <li>An implicit conversion operator is called automatically.</li>
                <li>An explicit conversion operator requires a cast. The conversion is explicit because it is a
                    narrowing operation that will result in a loss of data.</li>
            </ul>
            <h4>Convert Types with System.Convert</h4>
            <ul>
                <li>The System.Convert class provides a set of static methods that can be used to perform type
                    conversion between .NET types.</li>
                <li>A string can be converted to an integer using:
                    <code>int myAge = Convert.ToInt32("21");</code>
                </li>
                <li>The convert method will throw an exception if the string provided cannot be converted into an
                    integer.</li>
            </ul>
        </div>
        <div>
            <h3>Handling Dynamic Types</h3>
            <ul>
                <li>C# is a strongly type language, meaning that when the program is compiled the compiler ensures that
                    all actions that are performed are valid in the contect of the types that have been defined in the
                    program.</li>
                <li>If a class does not contain a method with a particular name, the C# compiler will refuse to generate
                    a call to that method.</li>
                <li>Strong typing works well as a way of making sure C# programs are valid at the time they are
                    executed.</li>
                <li>Strong typing can create issues when a C# program is required to interact with a system with origins
                    not in C#.</li>
                <li>These situations arise when using Common Object Model (COM) interop, the Document Object Model
                    (DOM), with objects generated by C# reflection, or when interworking with dynamic languages such as
                    JavaScript.</li>
                <li>In these situations, you need to force the compiler to interact with objects for which the strong
                    typing information that is generated from compiled C# is not available.</li>
                <li>The dynamic keyword is used to identify items for which the C# compiler should suspend static type
                    checking.</li>
                <li>The compiler will then generate code that works with the items as described, without doing static
                    checking.</li>
                <li>This doesn't mean programs using dynamic objects will always work; if the description is incorrect
                    the program will fail at runtime.</li>
                <li>The dynamic keyword makes it possible to interact with objects that have behaviours, but not the C#
                    type informationthat the C# compiler would normally use to ensure that any interaction is valid.
                </li>
                <li>A variable declared as dynamic is allocated a type that is inferred from the context in which it is
                    used. Similar to variables in Python and JavaScript.</li>
                <li>Just because you can do this doesn't mean you should. The flexibilty was added to make it easier to
                    interact with other languages and libraries written using COM.</li>
            </ul>
            <h4>Use ExpandoObject</h4>
            <ul>
                <li>The ExpandoObject class allows a program to dynamically add properties to an object.
                    <code>
                        dynamic person = new ExpandoObject();

                        person.Name = "Alex Ebbage";
                        person.Age = 24;

                        Console.WriteLine($"Name: {person.Name}, Age: {person.Age}");
                    </code>
                </li>
                <li>A program can add ExpandoObject properties to an ExpandoObject to create nested data structures.
                </li>
                <li>They can also be queried by LINQ and can expose the IDictionary interface to allow its contents to
                    be queried and items to be removed.</li>
                <li>It's especially useful when creating data structures from markup languages, like when reading a JSON
                    or XML document.</li>
            </ul>
        </div>
        <div>
            <h3>Interoperability with Unmanaged Code that Accesses COM APIs</h3>
            <ul>
                <li>The COM is a mechanism that allows software components to interact.</li>
                <li>The model describes how to express an interface to which other objects can connect.</li>
                <li>COM is interesting to programmers because a great many resources you would like to use are exposed
                    via COM interfaces.</li>
                <li>The code inside a COM object runs as unmanaged code, having direct acces to the underlying system.
                </li>
                <li>While possible to run .NET applications in an unmanaged mode, .NET applications usually run inside a
                    managed environment, limiting the level of access that the applications have to the underlying
                    system.</li>
                <li>When a .NET application wants to interact with a COM object it has to perform the following:
                    <ol>
                        <li>Convert any parameters for the COM object into an appropriate format.</li>
                        <li>Switch to unmanaged eecution for the COM behaviour.</li>
                        <li>Invoke the COM behaviour.</li>
                        <li>Switch back to manged execution upon completion of the COM behaviour.</li>
                        <li>Convert any results of the COm request into the correct types of .NET objects.</li>
                    </ol>
                </li>
                <li>This is performed by the Primary Interop Assembly (PIA) component that is supplied along with the
                    COM object.</li>
                <li>The results returned by the PIA can be managed as dynamic objects, so tha thetype of the values can
                    be inferred rather than having to be specified directly.</li>
                <li>The use of dynamic types makes interaction with the Office application very easy.</li>
                <li>There is no need to cast the various elements that the program is interacting with, as they are
                    exposed by the interop as dynamic types, so conversion is performed automatically based on the
                    ienferred type of an assignment destination.</li>
            </ul>
            <h4>Embedding Type Information from Assemblies</h4>
            <ul>
                <li>You can create applications that interact with different versions of Microsoft Office by embedding
                    the Primary Interop Assembly in the application.</li>
                <li>This is achieved by setting the Embed Interop Types option of the assembly reference to True.</li>
                <li>This removes the need for any interop assemblies on the machine running the application.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-3">Skill 2.3: Enforcing Encapsulation</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Enforce encapsulation by using properties</li>
            <li>Enforce encapsulation by using accessors, including public, private, protected, and internal</li>
            <li>Enforce encapsulation by using explicit interface implementation</li>
        </ul>
        <div>
            <h3>Access Modifiers</h3>
            <h4>Public and Private Access</h4>
            <ul>
                <li>C# allows objects to encapsulate data and methods via marking them with access modifiers.</li>
                <li>The public access modifier can be accessed by code that is outside that type.</li>
                <li>A private member of a type can only be accessed by code running inside the type.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Properties</h3>
            <ul>
                <li>A propety in an object provides a way that a programmer can encapsulate data.</li>
                <li>You can get more control over the values assigned to properties by adding validation to the set
                    block of the property.</li>
                <li>If you throw an exception when invalid you ensure that the user is always made aware of any error
                    conditions.</li>
                <li>You can make the set behaviour ignore invalid values, or you could set a default value when an
                    invalid one is provided.</li>
                <li>Read-only properties can be created by only providing a get behaviour.</li>
                <li>You can also make write-only properties in a similar manner, though this ability is less frequently
                    used.</li>
                <li>Different access modifiers can also be applied to the get and set behaviours.</li>
                <li>The backing value of a property is a private data member of the same type as the property, with a
                    name starting with an "_". </li>
                <li>Auto-implemented properties have their backing values automatically created by the C# compiler.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Accessors</h3>
            <ul>
                <li>As a general rule, data held within a type should be private and the methods to access the data
                    inside should be public.</li>
                <li>Properties provide a way to manage access to individual values in a class.</li>
                <li>Making a data member of a class private will stop direct access to that data member.</li>
                <li>From a design perspective, making a class member private and only providing public methods that
                    allow access to that member is a good first step to creating secure code.</li>
                <li>However, you may also have to make sure that you provide a secure workflow that manages access to
                    the data.</li>
            </ul>
            <h4>Default Access Modifiers</h4>
            <ul>
                <li>If you don't specify an access modifer for a member of a type, it'll default to private.</li>
                <li>To make a member visible to the outside it must be done explicitly.</li>
                <li>You don't have to add the private modifier to private members, but it is strongly advised you do.
                </li>
            </ul>
            <h4>Protected Access</h4>
            <ul>
                <li>The protected access modifer makes a class member useable in any classes that extend the parent
                    (base) class in which the member is declared.</li>
                <li>It isn't recommended you use the protected access modifier to control acess to highly important data
                    members of a class.</li>
                <li>Doing so makes it easy for malicious programemrs to gain access to the protected member by extending
                    the parent class.</li>
                <li>A good use is to limit access to helper methods that have no meaningful use outside of the class
                    hierarchy.</li>
            </ul>
            <h4>Internal Access</h4>
            <ul>
                <li>The internal access modifier will make a meber of a type accessible within the assembly in which it
                    is declared.</li>
                <li>An assembly can be regarded as the output of a C# project in Visual Studio.</li>
                <li>It can be iether an executable program or a library of classes.</li>
                <li>Internal access is most useful when you have a large number of cooperating classes that are being
                    used to provide a particular library component.</li>
                <li>These classes may want to share memebers which should not be visible to programs that use the
                    library.</li>
            </ul>
            <h4>Readonly Access</h4>
            <ul>
                <li>The readonly access modifier will make a member of a type read only.</li>
                <li>The value member can only be set at declaration or within the constructor of the class.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Explicity Interface Implementation</h3>
            <ul>
                <li>When a class implements an interfface it contains methods with signatures that match the ones
                    specified in the interface.</li>
                <li>You can use an explicit interface implementation to make methods implementing an interface only
                    visible when the object is accessed via an interface reference.</li>
                <li>You might want an IPrintable interface that specifies methods used to print any object. This is a
                    good idea because now a printer can be asked to print any item that is referred to by a reference of
                    IPrintable type.</li>
                <li>In other words, any object that implemetns the method in IPrintable can be printed.</li>
                <li>Methods in the IPrintable interface only have meaning when being used by something trying to print
                    an object. It's not sensible to call the printing methods in any other context than via the
                    IPrintable reference.</li>
                <li>This can be achieved by making the implementation of the print methods explicit, thus adding the
                    interface name to the delcaration of the method body.</li>
                <li>When you use an interface in a program you should ensure that all the implementations of any
                    interface methods are explicit. This reduces the chances of the interface methods being used in an
                    incorrect contect.</li>
            </ul>
            <h4>Resolving Duplicate Method Signatures by Using Explicit Implementation</h4>
            <ul>
                <li>When a class implements an interface it must contain an implementation of all methods that are
                    defined in the interface.</li>
                <li>Sometimes a class may implement multiple interfaces, in which case it must contain all the methods
                    defined in all the interfaces.</li>
                <li>Issues can occur if 2 interfaces contain a method with the same name.</li>
                <li>This can be resolved by specifying the interface name to the declaration of the method body.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-4">Skill 2.4: Create and Implement a Class Hierarchy</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Design and implement an interface</li>
            <li>Inherit from a base class</li>
            <li>Create and implement classes based on the IComparable, IEnumerable, IDisposable, and IUnknown interfaces
            </li>
        </ul>
        <div>
            <h3>Design and Implement an Interface</h3>
            <ul>
                <li>You can think of the elements of a power specification as an "interface" that defines how an
                    electrical device in a house can be connected to a power supply.</li>
                <li>These components are possible because standard interfaces have been created to describe exactly how
                    they fit together.</li>
                <li>Components are required because without them they can't be replaced because systems would be
                    hard-wired together.</li>
            </ul>
            <h4>Software Componenets and Interfaces</h4>
            <ul>
                <li>An interface in C# specifies how a software component could be used by another software component.
                </li>
                <li>Instead of starting to build an application by designing classes, you should think about describing
                    their interfaces.</li>
                <li>How a component functions can be encapsulated inside the component.</li>
                <li>A C# interface contains a set of method signatures. </li>
                <li>If a class contains an implementation of all of the methods described in the interface it can be
                    defined as "implementing" that interface.</li>
                <li>Interfaces allow a program to regard objects in terms of their abilities, rather than what type an
                    object actually is.</li>
                <li>If you hired a painter to paint your house in real life, you'd hire them based on their ability to
                    paint rather than who they are.</li>
                <li>As an example of where interfaces are useful, consider a printing service that will print objects in
                    an application. The IPrintable interface will contain the definition of the methods that can be used
                    to print a document on paper.</li>
                <li>The methods of the interface do not ask a document to print itself, rather they ask the docment to
                    provide the text strings that the printer will put onto paper.</li>
                <li>A print object can be created that will accept and print objects implementing the IPrintable
                    interface.</li>
                <li>This interface decouples the printer from the object being printed. If you create a new object that
                    needs to be printed, it can be done without modifying the printer class.</li>
                <li>Conversely, you can add new types of print and be sure that the new print type can be used to print
                    any object that implements IPrintable.</li>
            </ul>
            <h4>Design an Interface</h4>
            <ul>
                <li>An interface is placed in a source file just like a class, and is compiled in the same way.</li>
                <li>It sets out a number of methods that relate to a particular task or role.</li>
                <li>The naming convention is to start the interface name with an I.</li>
                <li>When you tell the compiler that a class implements an interface, it means the class contains
                    implementations of all the methods described in the interface.</li>
                <li>It is good practice to explicitly implement each method for the interface so the methods are only
                    exposed when the object is referred to by a reference of the interface's type.</li>
            </ul>
            <h4>References to Interfaces</h4>
            <ul>
                <li>With interfaces you are moving away from conisdering classes in terms of what they are, and starting
                    to think about them in terms of what they can do.</li>
                <li>In the case of bank, you want to deal with objects in terms of IAccount (the set of account
                    abilities) rather than BankAccount (a particular account class).</li>
                <li>In C# terms this means that you need to create reference variables that refer to objects in terms of
                    interfaces they implement, rather than the particular type that they are.</li>
                <li>There will never be an instance of the IAccount interface, this is simply a way that you can refer
                    to something which has that ability.</li>
                <li>This is like in real life where there is no such physical thing as a "writer", merely a large number
                    of people who can be referred to as having that particular ability or role.</li>
            </ul>
        </div>
        <div>
            <h3>Inherit from a Base Class</h3>
            <ul>
                <li>One fundamental principle of software development is to ensure that you create every piece of code
                    in an application precisely once.</li>
                <li>This is because if you have a bug in a piece of code, and that code has been abstracted into a
                    method, you only have to fix the code once.</li>
                <li>A class hierarchy is a great way to reuse code so that you only have to create a behaviour in one
                    place and can reuse it where it makes sense to.</li>
                <li>A class hierarchy is used when an application must manipulate items that are part of a particular
                    group.</li>
                <li>If you have classes BankAccount and SavingsAccount which both implement IAccount, yet their
                    functionality is very similar, you'll have to rewrite a lot of the same code.</li>
                <li>Inheritance can be used to tell the compiler that SavingsAccount is based on BankAccount.</li>
                <li>Inheritance allows SavingsAccount to do everything the parent or base class, BankAccount, can do.
                </li>
            </ul>
            <h4>The Is and As Operators</h4>
            <ul>
                <li>The is and as operators are used when working with class hierarchies and interfaces.</li>
                <li>The is operator determines if the type of a given object is in a particular class hierarchy or
                    implements a specifed inteface.</li>
                <li>You apply the is operator between a reference variable and a type or interface. The operator will
                    return true if the reference can be made to refer to objects of that type.</li>
                <li>The as operator takes a reference and a type and returns a reference of the given type, or null if
                    the reference cannot be made to refer to the object.</li>
                <li>The difference between the as operator and a cast, is that if a cast cannot be performed a program
                    will throw an exception. If the as operator fails it returns a null reference and the program
                    continues.</li>
            </ul>
            <h4>Overriding Methods</h4>
            <ul>
                <li>Overriding replaces a method in a base class with a version that provides the behaviour appropriate
                    to the child class.</li>
                <li>The override keyword means "use this version of the method in preference to the one in the base
                    class".</li>
                <li>Declaring a method as virtual tell the C# compiler a method can be overridden by classes which are
                    children of the parent class. This needs to be done as the compiler calls overridden methods in a
                    slightly different way to "normal" ones.</li>
                <li>Explicit implementations of interface methods cannot be overridden. You have to sacrifice a bit of
                    encapsulation in order to use class hierarchies in this manner.</li>
                <li>If child classes need access to a private member of a parent class, the access modifier needs to be
                    changed to protected.</li>
            </ul>
            <h4>Using the Base Method</h4>
            <ul>
                <li>The base keyword in the context of an overridden method means "a reference to the thing which has
                    been overriden".</li>
                <li>By doing this, it saves you from having to duplicate code and it can allow you to keep members of
                    the base class private.</li>
                <li>If a bug occurs in the behaviour of a top-level class, only the top-level class needs to be fixed
                    for the behaviour to work in all the child classes which call back to it.</li>
            </ul>
            <h4>Replacing Methods in Base Classes</h4>
            <ul>
                <li>If the new keyword is used instead of the override one when creating a method in a child class, it
                    simply creates a new version of the method.</li>
                <li>The replacement method is not able to use base to call the method that has been overridden, as it is
                    replaced.</li>
            </ul>
            <h4>Stopping Overriding</h4>
            <ul>
                <li>Overriding/replacing is not always desirable.</li>
                <li>A malicious programmer can writer their own version of a method in a child class and override or
                    rplace the one in the parent.</li>
                <li>The sealed keyword means "You can't override this method any more". Child classes are prevented from
                    replacing a method in a parent.</li>
            </ul>
            <h4>Constructors and Class Hierarchies</h4>
            <ul>
                <li>A constructor is a method which gets control during the process of object creation and is used to
                    set the initial values of the object.</li>
                <li>Adding a constructor to a base class in a class hierarchy can break all the child classes. This is
                    because creating a child class instance involves creating an instance of the base class.</li>
                <li>If it does, a call must be made from the constructor of the child classes to the constructor of the
                    base class.</li>
            </ul>
            <h4>Abstract Methods and Classes</h4>
            <ul>
                <li>Methods can be made abstract to force child classes to provide an implementation for them.</li>
                <li>A virtual "default" method can be provided by a parent class, then the programmers of the child
                    classes can be relied on to override them with more specific behaviours.</li>
                <li>If a method is flagged as abstract then no method body is provided in the class.</li>
                <li>A class that contains an abstract method means that it is abstract itself and must be marked as
                    such.</li>
                <li>You can't create an isntance of an abstract class, they can essentially be thought of as templates.
                </li>
                <li>If you want to make an instance of a classed based on an abstract parent, you must provide
                    implementations of all the abstract methods given in the parent.</li>
            </ul>
            <h4>Abstract Classes and Interfaces</h4>
            <ul>
                <li>Abstract classes look similar to interfaces.</li>
                <li>However, abstract classes can contain fully implemented methods alongside the abstract ones.</li>
                <li>This is useful because it means you don't have to repeatedly implement the same methods in each of
                    the components that implement a particular interface.</li>
                <li>A class can only inherit from one parent, so it can only pick up the behaviours of one class.</li>
                <li>Some languages support multiple inheritance, where a class can inherit from multiple parents.</li>
            </ul>
            <h4>References in Class Hierarchies</h4>
            <ul>
                <li>A reference to a base class in a class hierarchy can refer to an instance of any of the classes that
                    inherits from that base class.</li>
                <li>A variable declared as a reference object cannot be made to refer to a class higher in the class
                    hierarchy because a child class may have added behaviours to the parent class.</li>
                <li>Some prefer to manage references to objects in terms of the interfaces than the type of the
                    particular object. It is more flexible as you're not restricted to a particular type of object.</li>
            </ul>
        </div>
        <div>
            <h3>Create and Implement Classes Based on the IComparable, IEnumerable, IDisposable, and IUnknown Interfaces
            </h3>
            <ul>
                <li>.NET framework provides services that make use of particular behaviours that may be provided by a
                    given object.</li>
                <li>Each of these behaviours is described by an interface.</li>
            </ul>
            <h4>IComparable</h4>
            <ul>
                <li>IComparable is used to determine the order of objects when they are sorted.</li>
                <li>It contains a single method, CompareTo, which compares one object to another.</li>
                <li>A result of 0 indicates a match. Less than 0 indicates it should be placed before the object it's
                    being compared to. Greater than 0 indicates it should be placed after the object it's being compared
                    to.</li>
            </ul>
            <h4>Typed IComparable</h4>
            <ul>
                <li>The IComparable interface uses a CompareTo method that accepts an object reference as a paramter.
                </li>
                <li>This reference should refer to an object of the same type as the object that is doing the comparing.
                </li>
                <li>If the program attempts to compare and object with something that isn't a comparable type an error
                    will be produced at runtime.</li>
                <li>There is another version of the IComparable interface that accepts a type. This can be used to
                    create a CompareTo that only accepts parameters of a specified type.</li>
                <li>It might be necessary to make your interface extend IComparable to ensure that any objects that
                    implement your interface also implement IComparable.</li>
                <li>So, it is possible to create interface hierarchies, though it is not something you'll do very often.
                </li>
            </ul>
            <h4>IEnumerable</h4>
            <ul>
                <li>Programs spend a lot of time consuming lists and other collections of items. This is called
                    iterarting or enumerating.</li>
                <li>Any C# object can implement IEnumerable interface that allows other programs to get an enumerator
                    from that object. The enumerator object can then be used to enumerate the object.</li>
                <li>GetEnumerator() can be called to get an enumertor, which exposes MoveNext(), which returns true if
                    it can move onto another item in the enumeration.</li>
                <li>The enumerator also exposes a proeprty called Current, which is a reference to the currently
                    selected item in the enumerator.</li>
                <li>A foreach construction can be used to automatically get the enumerator from an object and to work
                    through it.</li>
            </ul>
            <h4>Making an Object Enumerable</h4>
            <ul>
                <li>The IEnumberable interface allows you to create objects that can be enumerated within your programs,
                    like the foreach loop construction.</li>
                <li>To implement it an object needs to implement the IEnumberable and IEnumerator&lt;T&gt; interfaces.
                </li>
                <li>IEnumberable means an object can be enumeratred.</li>
                <li>IEnumerator&lt;T&gt; means an object contains a call of GetEnumerator to get an enumerator from it.
                </li>
            </ul>
            <h4>Using Yield</h4>
            <ul>
                <li>To make the creation of enumerators simpler C# includes the yield keyword.</li>
                <li>The yield keyword is followed by the return keyword and precedes the value to be returned for the
                    current iteration.</li>
                <li>The C# compiler generates all the Current and MoveNext behaviours that make the iteration work, and
                    also records the state of the iterator method so that the iterator method resumes at the statement
                    following the yield statement when the next iteration is requested.</li>
                <li>The yield keyword does 2 things:
                    <ul>
                        <li>It specifies the value to be returned for a given iteration.</li>
                        <li>It returns control to the iterating method.</li>
                    </ul>
                </li>W
            </ul>
            <h4>IDisposable</h4>
            <ul>
                <li>C# provides memory management for applications, but it can't control how programs use other
                    resources such as file hadnles, database connections and lock objects.</li>
                <li>While an object can get control when it is removed by the garbage collector it is hard for a
                    developer to know precisely when this happens. It amy not even happens until the program ends.</li>
                <li>The IDisposable interface provides a way that an object can indicate that it contains an explict
                    Dispose method that can be used to tidy up an object when an application has finished using it.</li>
                <li>A disposed object may exist in memory, but any attempts to use it will result in the
                    ObjectDisposedExpection being thrown.</li>
                <li>The action of the Dispose method depends entirely on the needs of the application.</li>
                <li>The dispose methodis not called automatically when an object is deleted from memory.</li>
                <li>There are two ways to make sure that Dipose is called correctly:
                    <ul>
                        <li>You can call the method yourself in your application.</li>
                        <li>You can make suse of the C# using construction.</li>
                    </ul>
                </li>
                <li>The using construction creates an instance of the object that implements IDisposable, is followed by
                    a block of code that uses the object, and then Dispose() is called at the end of the block.</li>
            </ul>
            <h4>IUnknown</h4>
            <ul>
                <li>Dynamic types are used to interact with services provided via the Component Object Model (COM).</li>
                <li>Interop services return results which are dynamically typed, and the program can use these results
                    by assinging them to correctly typed variables.</li>
                <li>Interop services are implemented as C# libraries that marshal te data between the managed code world
                    of C# and the unmanaged world of COM objects.</li>
                <li>The IUnknown interface is a means by which one object describes the interfaces that it makes
                    avaialable for use by others.</li>
                <li>It provides a means by which .NET applications can interoperate with COM object at this level.</li>
                <li>You can use it when connection C# applications to COM objects.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-5">Skill 2.5: Find, Execute and Create Types At Runtime</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Create and apply attributes</li>
            <li>Read attributes</li>
            <li>Generate code at runtime by using CodeDom and Lambda expressions</li>
            <li>Use types from the System.Reflection namespace, including Assembly, PropertyInfo, MethodInfo and Type
            </li>
        </ul>
        <div>
            <h3>Create and Apply Attributes</h3>
            <ul>
                <li>When describing a piece of data you can talk in terms of the attributes of that data.</li>
                <li>Metadata is "data about data". In the case of music; the data is the music itself, and the metadata
                    is the name of the artist.</li>
                <li>C# allows you to add metadata to an application in the form of attributes that are attached to
                    classes and class members.</li>
                <li>An attribute is an instance of a class that extends the Attrbiute class.</li>
            </ul>
            <h4>The Serializable Attribute</h4>
            <ul>
                <li>The Serializable attribute doesn't hold any data.</li>
                <li>It indicates that the class attached to it may be opened and read by a serializer.</li>
                <li>A serializer takes the entire contents of a class and sends it into a stream.</li>
                <li>There are securiting implications in seriaizing a class, so C# requires that a class explicitly
                    "opts in" for the serialization process.</li>
                <li>The NonSerializaed attribute is applied to members which you don't want saved when the object is
                    serialized.</li>
            </ul>
            <h4>Conditional Compilation Using Attributes</h4>
            <ul>
                <li>The Conditional attribute is used to activate and de-activate the contents of methods.</li>
                <li>This attribute is declared in the System.Diagnostics namepsace.</li>
                <li>The conditional attribute controls whether or not the body of a given method is obeyed whe the
                    method is called.</li>
                <li>It does not control whether or not the method itself is passed to the compiler.</li>
                <li>The conditional attribute does not perform the same function as the conditional compilation in
                    langauges such as C and C++, it doesn't prevent code from being passed to the compiler, rather it
                    controls whether code is executed when it runs.</li>
            </ul>
            <h4>Testing for Attributes</h4>
            <ul>
                <li>A program can check that a given class has a particular attrbiute class attached to it by using the
                    IsDefined method, which is a static member of the Attrbiute class.</li>
                <li>The IsDefined method accepts two parameters; the first is the type of the class being tested and the
                    second is the type of the attribute class that the test is looking for.</li>
                <li>Note that although the attribute is called Serializable, when it is used in the source doe the name
                    of the class that implements the attribute has the word "Attribute" appended to it.</li>
                <li>This convention should be followed when creating your own attributes.</li>
            </ul>
            <h4>Creating Attribute Classes</h4>
            <ul>
                <li>You can create your own attributes to help manage elements of your application.</li>
                <li>These classes can serve as markers in the same way as the Serializable attribute specifies that a
                    class can be serialized.</li>
                <li>You can also store data in attribute instances to give information about the items the attributes
                    are attached to.</li>
                <li>Data values stored in an attribute instance are set from the class metadata when the attribute is
                    loaded.</li>
                <li>These values can be changed as the program runs but will be lost when it ends.</li>
            </ul>
            <h4>Controlling the Use of Attributes</h4>
            <ul>
                <li>You can add an attribute to any item in a program, including memeber variables, methods, properties,
                    or type of object.</li>
                <li>When you create an attribute class, the proper practice is to add attribute usage information to the
                    declaration of the attribute class.</li>
                <li>This allows the compiler to make sure that the attribute is only used in meaningful situations.</li>
                <li>The AttributeUsage attribute can be added to the declaration of an attribute class to control this.
                </li>
                <li>If you apply an AttributeUsage.Class attribute to an item other than a class, the compiler will
                    generate errors. This means the compiler is performing reflection on the code as it compiles.</li>
                <li>You can set values of the AttributeUsage class to do a variety of things:
                    <ul>
                        <li>Control whether children of a class can be given the attribute.</li>
                        <li>Specify which elements of your program can have the attribute assigned to them.</li>
                        <li>Identify specifc types to be given the attribute.</li>
                        <li>Specify whether the given attribute can be applied multiple times to the same item.</li>
                    </ul>
                </li>
                <li>You can use the | operator to set multiple targets for a given attribute.</li>
            </ul>
        </div>
        <div>
            <h3>Read Attributes</h3>
            <ul>
                <li>The Attribute also provides a method called GetCustomAttribute which gets an attribute from a
                    particular type.</li>
                <li>It has the same parameters as IsDefined and returns a reference to the attribute. It returns null if
                    it is not defined.</li>
            </ul>
        </div>
        <div>
            <h3>Using Reflection</h3>
            <ul>
                <li>Searching for and reading attribute values is an example of a program performing refleciton.</li>
                <li>It can be thought of as a program reflecting on its own contents.</li>
                <li>It is sometimes called introspection.</li>
                <li>Testing systems can use reflection to search for objects that need testing and identify the testing
                    that is required by attributes that have been set on these objects.</li>
                <li>Reflection allows an application to automaticalyl identify "plug-in" components, so that the
                    application can be made up of discrete elements that are connected together when the program runs.
                </li>
                <li>If faults are found in one component, or new components need to be added, this can be performed
                    without changes to the rest of the system.</li>
                <li>You can regard elements discovered and loaded by the use of reflection as the natural endpoint of
                    the process of reating code as components that implement interfaces and communicate by means of
                    events which they publish and subscribe to.</li>
            </ul>
            <h4>Using Type Information from and Object</h4>
            <ul>
                <li>You can start considering reflection by looking at the GetType method.</li>
                <li>All objects in a C# program expose this method, whichi will return a reference to the type that
                    defines the object.</li>
                <li>The Type of an object contains all the fields of an object, along with all the metadata describing
                    it.</li>
                <li>You can use methods and objects in the System.Reflection namespace to work with Type objects.</li>
            </ul>
            <h4>Calling a Method on an Object by Using Reflection</h4>
            <ul>
                <li>You can use infromaton provided by a type to create a call to a method in that type.</li>
                <li>It does this by finding the MethodInfo for this method and then caling the Invoke method on this
                    reference.</li>
                <li>The Invoke method is supplied with a reference to object that is the target of the method invocation
                    and an arary of object references which will be used as the arguments to that method call.</li>
                <li>It is much slower than just calling the method of an object normally but illustrates the flexibility
                    provided by reflection.</li>
                <li>A program can now obtain a reference to an object, find out what behaviours that object exposes, and
                    then make use of the behaviours that it needs.</li>
            </ul>
            <h4>Finding Components in Assemblies</h4>
            <ul>
                <li>To implement plguins you need to be able to search the classes in an assembly and find components
                    that implement particular interfcaes.</li>
                <li>This behaviour is the basis of the Managed Extensibility Framework (MEF).</li>
                <li>The Assembly type provides a method that will get the currently executing assembly.</li>
                <li>It is then possible to iterate through all the types in this assembly looking for ones of specific
                    types.</li>
                <li>It is possible to load an assembly from a file by using the Assembly.Load method.</li>
                <li>This an application could search a particular folder for assembly files, load them and then search
                    for classes that can be used in the application on launch.</li>
            </ul>
        </div>
        <div>
            <h3>Generate Code at Runtime by Using CodeDOM and Lambda Expressions</h3>
            <ul>
                <li>An entire application can be represented by objects such as Assembly and Type.</li>
                <li>You can also programmatically add your own elements to these objects so that your applications can
                    create code at runtime.</li>
                <li>You can use this technology to automate the production of code.</li>
                <li>It is used in situations where you have to create objects that will have to interact with services
                    providing a particular data scheme or when you're automatically generating code in a design tool.
                </li>
                <li>There are two techniques for generating code at runtime: Code Document Object Model (CodeDOM) and
                    Lambda expressions.</li>
            </ul>
            <h4>CodeDOM</h4>
            <ul>
                <li>A document object model is a way of representing the structure of a particular type of document.
                </li>
                <li>The obkect contains collections of other objects that represent the contents of the document.</li>
                <li>There are document object models for XML, JSON and HTML documents.</li>
                <li>The CodeDOM object represents the structure of a class.</li>
                <li>A CodeDOM object can be parsed to create a source file or an executable assembly.</li>
                <li>The constructions used in a CodeDOM object represent the logical structure of the code to be
                    implemented and are independent of the syntax of the high-level language that is used to create the
                    document.</li>
                <li>In other words, you can create either Visual Basic .NET or C# source files from a given CodeDOM
                    object and you can create CodeDOM objects using either language.</li>
                <li>A CodeCompileUnit instance is created first to servce as a container for CodeNamespace objects that
                    can be added to it.</li>
                <li>A CodeNameSpace can contain a number of CodeTypeDeclarations and a class is a kind of
                    CodeTypeDeclaration.</li>
                <li>There are a range of types that can be created and added to a document to allow you to
                    programmatically create enumerated type expressions, method calls, properties and all the elements
                    of a complete program.</li>
            </ul>
            <h4>Lambda Expression Trees</h4>
            <ul>
                <li>A lambda expression is a way of expressing a data processing action (a value goes in and a result
                    comes out).</li>
                <li>You can express a single action in a program by the use of a single lambda expression.</li>
                <li>More complex actions can be expressed in expression trees.</li>
                <li>Expression trees are widely used in C#, particularly in the context of LINQ. The code that generates
                    the result of a LINQ query will be created as an expression tree.</li>
                <li>A lambda expression tree has a lambda expression at its base.</li>
                <li>There are a number of built-in types for use with delegates, but the FUNC delegates allow us to
                    define a delegate that accepts a number of inputs and returns a single result.</li>
                <li>The System.Linq.Expressions namespace contains a range of other thypes tha can be used to represent
                    other code elements in lambda expressions, including conditional operation, loops and collections.
                </li>
            </ul>
            <h4>Modfying an Expression Tree</h4>
            <ul>
                <li>An expression tree is immutable, so it cannot be changed once created.</li>
                <li>To modify an expression tree you must make a copy of the tree which contains the modified
                    behaviours.</li>
            </ul>
        </div>
        <div>
            <h3>Using Types from the System.Reflection Namespace</h3>
            <h4>Assembly</h4>
            <ul>
                <li>An assembly is the output produced when a /NET project is compiled.</li>
                <li>The assembly type represents the contents of an assembly, which can be the currently executing
                    assembly or one that is loaded from a file.</li>
                <li>The Assembly class provides a way that programs can use reflection on the contents of the assembly
                    that it represents.</li>
                <li>It provides methods and properties to establish and manage:
                    <ul>
                        <li>The version of the assembly.</li>
                        <li>Any dependencies that the assembly has on other files.</li>
                        <li>The definition of any types that are declared in the assembly.</li>
                    </ul>
                </li>
            </ul>
            <h4>PropertyInfo</h4>
            <ul>
                <li>A C# property provides a quick way of providing get and set behaviours for a data variable in a
                    type.</li>
                <li>The PropertyInfo class provides details of a property, including the MethodInfo information for the
                    get and set behaviours.</li>
            </ul>
            <h4>MethodInfo</h4>
            <ul>
                <li>The MethodInfo class holds data about a method in a type.</li>
                <li>This includes:
                    <ul>
                        <li>The signature of the method.</li>
                        <li>The return type of the method.</li>
                        <li>Details of method parameters.</li>
                        <li>The byte code that forms the body of the method.</li>
                    </ul>
                </li>
                <li>The Invoke method can also be used to invoke a metod from its method information.</li>
            </ul>
            <h4>Type</h4>
            <ul>
                <li>The Type type is mostly used in programs that use reflection.</li>
                <li>A type instance describes the contents of a C# type, including an individual collection for all the
                    methods, variables, properties, etc.</li>
                <li>It also contains a collection of attribute class instances associated with this type and details of
                    the Base typpe from which the type is derived.</li>
                <li>The GetType method can be called on any instance to obtain a reference to the type for that object.
                </li>
                <li>The typeof method can be used on any type to obtain the type object that describes that type.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-6">Skill 2.6: Managing the Object Lifecycle</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Manage unmanaged resources</li>
            <li>Implement IDisposable, including interaction with finalization</li>
            <li>Manage IDisposable by using the Using statement</li>
            <li>Manage finalization and garbage collection</li>
        </ul>
        <div>
            <h3>Garbage Collection in .NET</h3>
            <h4>Creating Garbage</h4>
            <ul>
                <li>When a reference to an object is assigned a new instance of that object, it first instance is no
                    longer needed.</li>
                <li>When a reference variable goes out of scope, the instance of the object is no longer accessible
                    because the reference no longer exists.</li>
                <li>These objects with no reference still occupy memory, and a process has a particular amount allocated
                    to it.</li>
                <li>Garbage collection occurs when the amount of memory available for new objects falls below a
                    threshold.</li>
                <li>The rate at which garbage is collected will change, depending on the loading on the host computer.
                </li>
            </ul>
            <h4>Value Types and Garbage Collection</h4>
            <ul>
                <li>The heap is the area of memory where an applicaton stores objects that are referred to by reference.
                </li>
                <li>The contents of value types are stored on the stack, which automatically grows and contracts as
                    programs run.</li>
                <li>Upon entry to a new block the .NET runtime will allocate space on the stack for values that are
                    declared local to that block.</li>
                <li>When a program leaves the bock the .NET rutime will auto,atically contract the stack space, which
                    removes the memory allocated for those variables.</li>
            </ul>
            <h4>The Garbage Collector</h4>
            <ul>
                <li>When an application runs low on memory the garbage collector will search the heap for any objects
                    taht are no longer required and remove them.</li>
                <li>The .NET rutime contains an index of all objects that have been created since the program staretd.
                </li>
                <li>The garbage collector decides which of them are still in use, removes them from memory if they're
                    not.</li>
                <li>The remaining objects are compacted so that the area of free memory is a single large area, rather
                    than a number of smaller, free areas.</li>
                <li>The first phase of garbage collection is marking all of the objects that are in use by the program,
                    where it starts by clearing a flag on each object in the heap.</li>
                <li>It searches through all the variables in use by the program and follows all the references to the
                    objects they refer to, setting the flag on that object.</li>
                <li>After this "mark" phase, the garbage collector moves to the "compact" phase, where it works through
                    memory removing all the bojects that have not had their flag set.</li>
                <li>The final phase is the "compaction" of the heap. The objects still in use must be moved down memory
                    so that the available space is one larger block, rather than lots of spaces where unused objects
                    were removed.</li>
                <li>All managed threads are suspended while the garbage collector is running, which means an application
                    will stop responding to inputs while the garbage collection is performed.</li>
                <li>It is possible to invoke the garbage collector manually if there are points in your application when
                    you know a large number of objects have been released.</li>
                <li>The garbage collector attempts to determine which objects are long lived and short lived
                    (ephemeral). It does this by adding a generation counter to each object on the heap, starting at 0.
                    If an object survives a garbage collection the counter is advanced. Generation 2 is the highest
                    generation.</li>
                <li>The garbage collector will colect different generations, depending on circumstances. A "level 2"
                    collections will involve all objects, while a "level 0" collection will target newly created
                    objects.</li>
                <li>The garbage collector can run in "workstation" or "server" modes, depending on the role of the host
                    system.</li>
                <li>There is an option to run garbage collection cuncurrently on a separate thread. However, this
                    increases the amount of memory used by the garbage collector adn the loading on the host processor.
                </li>
            </ul>
            <h4>Reducing the Need for Garbage Collection</h4>
            <ul>
                <li>Modern applications run in systems with large amounts of available memory.</li>
                <li>The garbage collection process has been optimized over the various generations of .NET and is now
                    highly efficient and responsive.</li>
                <li>It is strongly advised not to worry about it until you have a problem. There is no need worrying
                    about the memory usage of your application when your system will almost certainly have enough memory
                    and processor performance.</li>
                <li>There are profiling tools available in Visual Studio that alow you to watch resource allocation and
                    to identify objects affected by garbage collection.</li>
                <li>If you find the garbage collection process is becoming intrusive you can force a garbage collection
                    by calling the Collect method on the garbage collector.</li>
                <li>The enforced garbage collection can be performed at points in your applications where you know large
                    objects have just been released.</li>
                <li>Again, it is advised you let the garbage collector look after itself, it is very good at what it
                    does.</li>
            </ul>
        </div>
        <div>
            <h3>Manage Unmanaged Resources</h3>
            <ul>
                <li>The .NET frameowrk will take care of the creation and destruction of our objects, but we need to
                    manage the resources our objects use.</li>
                <li>For example, if an application create a file handle and stores it in an object, when that object is
                    destroyed the file handle will be lost. If the file connected to the handle is not closed properly
                    before the object is destroyed, the file the handle is connected to will not be usable.</li>
                <li>Finalization and disposable allow are us to get control at the point an object is being destroyed
                    and to tidy up any resources that the object may be using.</li>
            </ul>
            <h4>Object Finalization Using a Finalizer Method</h4>
            <ul>
                <li>The finalization of an object is triggered by the garbage collection process.</li>
                <li>An object can contain a finalizer method that is invoked by the garbage collector in advance of that
                    object being removed from memory.</li>
                <li>This method gets control and can release any resources that are being used by that object.</li>
                <li>The finalizer method is given as a type elss method with the name of the class pre-ceded by a tilde
                    (~) character.</li>
            </ul>
            <h4>Problems with Finalization</h4>
            <ul>
                <li>When the garbage collector is about to remove an object, it checks to see if the object contains a
                    finalizer method.</li>
                <li>If there is a finalizer method present, the garbage collector adds the object to a queue of objects
                    waiting to be finalized.</li>
                <li>Once all these objects have been identified, the garbage collector starts a thread to execute all
                    the finalizer methods and waits for the thread to complete.</li>
                <li>Once the finalization methods are complete the garbage collector performs another garbage collection
                    to remove the finalized objects.</li>
                <li>Objects waiting to be finalized will remain in memory until all of the finalzier methods have
                    completed and the garbage collector has made another garbage collection pass to remove them.</li>
                <li>A slow-running finalizer can seriously impair the garbage collection process.</li>
                <li>Another problem with finalization is that there are no guarantees as to when the finalizer method
                    will run or that'll it ever be called. if the program never runs short on memory it may never
                    initiate garbage collection.</li>
                <li>C++ programmers are used to writing destructors to release memory when an object is deleted but it
                    doesn't mean you should add finalizers to C# classes.</li>
            </ul>
        </div>
        <div>
            <h3>Implement IDisposable, Including Interaction with Finalization</h3>
            <ul>
                <li>An object can implement the IDisposable interface, which means it must provide a Dispose method that
                    can be called within the application to request that the object to release any resources that is has
                    allocated.</li>
                <li>Dispose does not cause the object to be deleted from memory, nor does it mark the object for
                    deletion by the garbage collector. Only objects that have no references to them are deleted.</li>
                <li>Once Dispose has been called on an object, that object can no longer be used in an application.</li>
                <li>Objects that implement IDisposable can be used in conjuncation with the using statement, which will
                    provide an automatic call of the Dispose method when execution leaves the block that follows the
                    using statement.</li>
                <li>The Dispose method is called by the application when an object is required to release all the
                    resources that it is using.</li>
                <li>This is a significant improvement on a finalizer, in that your application can control exactly when
                    this happens.</li>
            </ul>
            <h4>Using IDisposable and Finalization on the Same Object</h4>
            <ul>
                <li>If you create an object that contains both a finalzier and a Dipose method, care needs to be taken
                    that they don't release the same resources more than once, as this may cause a failure.</li>
                <li>The SupressFinalize method canbe used to identify an object, which will not be finalized when the
                    object is deleted.</li>
                <li>This should be used by the Dispose method in a class to prevent instances being disposed more than
                    once.</li>
                <li>A dispose pattern can be used to allow an object to manage its disposal. This imakes use of a helper
                    method, Dispose(bool disposing), which accepts a flag which indicates whether the method is being
                    called from a call of Dispose or from a finalizer.</li>
                <li>If the helper method is being called from a call of Dispose it will free off managed resources as
                    well as unmanaged ones when it runs.</li>
                <li>The pattern also uses a class flag variable, disposed, which is set when dipose has been called and
                    prevents multiple attempts to dispose items.</li>
            </ul>
        </div>
        <div>
            <h3>Manage IDispsoable by Using the Using Statement</h3>
            <ul>
                <li>The using statement ensures that Dispose is called on an object in the event of exceptions being
                    thrown.</li>
                <li>If you don't use the using statement to manage calls of Dispose in your objects, make sure that your
                    application calls Dispose appropritately.</li>
                <li>The dispose pattern above results in a dispal behaviour that is tolerant of multiples calls of
                    Dispose.</li>
            </ul>
        </div>
        <div>
            <h3>Manage Finalization and Garbage Collection</h3>
            <h4>Invoking a Garbage Collection</h4>
            <ul>
                <li>A garbage collection can be forced to take place by calling the Collect method.</li>
                <li>After the collection has been performed, a program can then be made to wait until all the finalizer
                    methods have completed:
                    <code>
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                    </code>
                </li>
                <li>Overloads of the Collect method allow you to specify which geneartion of objects to garbage collect
                    and set other garbage collection option.</li>
            </ul>
            <h4>Managing Finalization</h4>
            <ul>
                <li>The garbage collector can be ordered to ignore the finalizer on an object.</li>
                <li>The code below prevents finalization from being called on the object referred to by p:
                    <code>
                        GC.SupressFinalize(p);
                    </code>
                </li>
                <li>Finalization can later be re-enabled using the ReRegisterForFinalize method with the object as a
                    parameter.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-7">Skill 2.7: Manipulating Strings</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="qa-2">Thought Experiments</h2>
        <div>
            <h3>HEADING</h3>
            <p>DESCRIPTION</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">QUESTION</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
    </div>
</div>