<div>
    <h1 id="chapter-2">Chapter 2: Create and Use Types</h1>
    <p>Skills covered in this chapter are:</p>
    <ul>
        <li><a href="#skill-2-1">Skill 2.1: Creating Types</a></li>
        <li><a href="#skill-2-2">Skill 2.2: Consuming Types</a></li>
        <li><a href="#skill-2-3">Skill 2.3: Enforcing Encapsulation</a></li>
        <li><a href="#skill-2-4">Skill 2.4: Create and Implement a Class Hierarchy</a></li>
        <li><a href="#skill-2-5">Skill 2.5: Find, Execute and Create Types At Runtime</a></li>
        <li><a href="#skill-2-6">Skill 2.6: Managing the Object Lifecycle</a></li>
        <li><a href="#skill-2-7">Skill 2.7: Manipulating Strings</a></li>
        <li><a href="#qa-2">Thought Experiments</a></li>
    </ul>
    <div>
        <h2 id="skill-2-1">Skill 2.1: Creating Types</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Create value types, including structs and enum</li>
            <li>Create reference types, generic types, constructors, static variables, method, classes and extension
                methods</li>
            <li>Create optional and named paramters</li>
            <li>Create indexed properties</li>
            <li>Create overloaded and overridden methods</li>
        </ul>
        <div>
            <h3>Value and Reference Types</h3>
            <ul>
                <li>Consider you have 2 variables, x and y, and you make the statement <code>y.Data = 99; x = y; x.Data
                        = 100;</code>...</li>
                <li>If the variables x and y are value types, the value of y is copied into the variable x. The Data
                    property of y is not affected by the final assignment to x.</li>
                <li>If the variables x and y are referemce types, the variable x is made to refer to the same object as
                    that referred to by variable y. The final assignment will make the Data property of a single object
                    set to 100.</li>
                <li>Structure variables are managed by value and class variables are managed by reference.</li>
            </ul>
            <h4>Value and Referene Types in .NET</h3>
                <ul>
                    <li>A good example of a value type is the DateTime structure provided by the .NET library.</li>
                    <li>You could represent date values in the form of a collection of individual values, but assigning
                        one date to another would be time-consuming as the program would have to transfer each value.
                    </li>
                    <li>Having a DateTime type means you can move a date value between variables with a single
                        assignment. During a DateTime assignment all the values that represent the date are copied into
                        the destination variable.</li>
                    <li>A good example of a reference type is the Bitmap class from the System.Drawing library in .NET.
                    </li>
                    <li>The Bitmap class is used to create objects that hold the pixels which make up an image which
                        could be millions.</li>
                    <li>If a Bitmap is held as a value type, when one is assigned to another, all the pixels in the
                        source Bitmap must be copied from the source image into the destination.</li>
                    <li>As they are managed by reference, an assignment simply makes the destination reference refer to
                        the same object as the source reference.</li>
                </ul>
                <h4>Type Design</h3>
                    <ul>
                        <li>Using the design of a space shooter game as an example...</li>
                        <li>The location of the alien on the screen should be a value type, as you'd want the position
                            as a single value. You don't want to share coordinates between aliens.</li>
                        <li>A sound effect would be a reference type, as it'd store a large array of integer data which
                            represent a given sound. You may want serveral aliens to share the same sound.</li>
                        <li>In C#, value types are enumerated types and references. Reference types are classes.</li>
                    </ul>
                    <h4>Immutablity in Types</h3>
                        <ul>
                            <li>An immutable type is one whose instances cannot be changed.</li>
                            <li>The DateTime structure is an immutable type. Once an isntance is created you cannot
                                change any elements of that instance.</li>
                            <li>The only way to edit them is to create a new DateTime value that contains the updated
                                values.</li>
                            <li>Changing the values of an immutable type is less efficient as it requires the creation
                                of a new object each time.</li>
                            <li>However, it removes the possiblity of elements in a variable changing once created.</li>
                            <li>They are advantagous when writing concurrent programs as they can never be corrupted
                                because they can never be changed.</li>
                            <li>The string type in C# is also immutable.</li>
                        </ul>
        </div>
        <div>
            <h3>Creating Value Types</h3>
            <h4>Structures</h4>
            <ul>
                <li>Structures can contain methods, data values, properties and can have constructors.</li>
                <li>The constructor for a structure must initalize all the data members. They cannot be initalized in
                    the structure.</li>
                <li>A structure cannot have a parameterless constructor. However, a structure can be created by calling
                    a parameterless constructor which sets all elements to have default values.</li>
                <li>A structure cannot be created by extending a parent structure object.</li>
                <li>Structure isntances are generally created on the program stack unless they are used in closures.
                </li>
                <li>An array of structure instances will be created as a block of contiguous memory, which holds all the
                    required items.</li>
                <li>A structure definition can contain overrides, e.g. ToString(). A structure cannot use a class
                    hierarchy, because it is posible to override methods from the parent type of a struct.</li>
            </ul>
            <h4>Enumerated Types</h4>
            <ul>
                <li>Enumerated types are used in situations where the programemr wants to specify a range of values a
                    given type can have.</li>
                <li>For example, they might want to represent the states of an AI: sleeping, attacking or destroyed. An
                    integer could be used for this but if 1-3 are used for these states and 4 is given, it will have no
                    meaning.</li>
                <li>Unless specified otherwise, an enumerated type is based on the int type and values start from 0.
                </li>
                <li>You would do this if you want to set particular values to be used in JSON and XML files when
                    enumerated variables are stored.</li>
            </ul>
        </div>
        <div>
            <h3>Creating Reference Types</h3>
            <ul>
                <li>A class is declared in a similar manner to a structure, but the way in which they are manipulated is
                    significantly different.</li>
                <li>When a variable of a class type is declared, the variable is now a refernce to that object.</li>
            </ul>
            <h4>Memory Allocation</h4>
            <ul>
                <li>Memory used to store variables of value type is allocated on the stack.</li>
                <li>The stack is an area of memory that is allocated and removed as programs enter and leave blocks.
                </li>
                <li>Any value type variables created during the execution of a block are stored on a local stack
                    frame and then the entire frame is discarded when the block completes.</li>
                <li>This is an extremely efficient way to manage memory.</li>
                <li>Memory used to store variables of reference type is allocated on the heap.</li>
                <li>The heap is managed for an entire application.</li>
                <li>The heap is required because, as references may eb passed between method calls as paramters, it
                    is not the ase that objects managed by refence cane be discarded when a method exits.</li>
                <li>Objects can only be removed from the heap when the garbage collection process determines that
                    there are no references to them.</li>>
            </ul>
            <h4>Generic Types</h4>
            <ul>
                <li>Generic types are used extensively in C# collections, such as with the List and Dictionary
                    classes.</li>
                <li>They allow you to create a List of any type or a Dictionary of any type, indexed on any
                    type.</li>
                <li>Without generic types you either have to reduce type safety in your programs by using
                    collections that manage only objects, or you have to waste time creating collections for
                    each type.</li>
                <li>An example of a generic stack is shown below:
                    <code>
                        class MyStack&lt;T&gt;
                        {
                        <span class="i1">&nbsp;</span>int stackTop = 0;
                        <span class="i1">&nbsp;</span>T[] items = new T[100];

                        <span class="i1">&nbsp;</span>public void Push(T item)
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>if (stackTop == items.Length)
                        <span class="i3">&nbsp;</span>throw new Exception("Stack full!");
                        <span class="i2">&nbsp;</span>items[stackTop] = item;
                        <span class="i2">&nbsp;</span>stackTop++;
                        <span class="i1">&nbsp;</span>}

                        <span class="i1">&nbsp;</span>public T Pop()
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>if (stackTop == 0)
                        <span class="i3">&nbsp;</span>throw new Exception("Stack empty!");
                        <span class="i2">&nbsp;</span>stackTop--;
                        <span class="i2">&nbsp;</span>return items[stackTop];
                        <span class="i1">&nbsp;</span> }

                        <span class="i1">&nbsp;</span>static void Main(string[] args)
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>MyStack&lt;string&gt; stringStack = new
                        <span class="i2">&nbsp;</span>MyStack&lt;string&gt;();
                        <span class="i2">&nbsp;</span>stringStack.Push("Apple");
                        <span class="i2">&nbsp;</span>Console.WriteLine(stringStack.Pop());
                        <span class="i2">&nbsp;</span>Console.ReadKey();
                        <span class="i1">&nbsp;</span>}
                        }
                    </code>
                </li>
            </ul>
            <h4>Generic Contstraints</h4>
            <ul>
                <li>There are several constraints which can be applied to the class declaration to restrict types which
                    can be represented by T:
                    <ul>
                        <li><b>where T : class</b> The type T must be a reference type.</li>
                        <li><b>where T : struct</b> The type T must be a value type.</li>
                        <li><b>where T : new()</b> The type T must have a public, parameterless, constructor. Specify
                            this constraint last if you are specifying a list of constraints.</li>
                        <li><b>where T : &lt;base class&gt;</b> The type T must be of type base class or derive from
                            base class.</li>
                        <li><b>where T : &lt;interface name&gt;</b> The type T must be or implement the specifed
                            interface. You can specify multiple interfaces.</li>
                        <li><b>where T : &lt;unmanaged&gt;</b> The type T must not be a reference type or contain any
                            members which are reference types.</li>
                    </ul>
                </li>
            </ul>
            <h4>Constructors</h4>
            <ul>
                <li>A constructor allows a programmer to control the process by which objects are craeted.</li>
                <li>Constructors can be used by both reference types (classes) and value types (stuctures).</li>
                <li>A constructor has the same name as the object it is part of but does not have a return type.</li>
                <li>They can perform validation on their parameters to ensure that any objects created contain valid
                    information.</li>
                <li>If invalid, a constructor must throw an exception to prevent the creation of an object.</li>
                <li>If an object only has a private constructor, it must be instantiated using a public factory method
                    that is declared in the same class.</li>
                <li>Constructors can be overloaded, so an object can contain multiple versions of a consntructor with
                    different signatures.</li>
                <li>A program can avoid code repition by making one constructor call another constructor by the use of
                    the keyword this.</li>
            </ul>
            <h4>Static Constructors</h4>
            <ul>
                <li>A static consturctor method is called once before the creation of the very first instance of the
                    class.</li>
                <li>It is a good place to load resources and initialize values that will be ysed by instances of the
                    class.</li>
                <li>They can include values of static members of the class.</li>
            </ul>
            <h4>Static Variables</h4>
            <ul>
                <li>A static varialb eis a member of a type, but it is not created for each instance of a type.</li>
                <li>A variable in a class is made static by using the static keyword in the declaration of that
                    variable.</li>
                <li>Code outside the class must refer to static variables via the class name, rather than the name of
                    any particular instance of that class.</li>
                <li>A program can use astic variable from a type without needing to have created any instances of that
                    type.</li>
                <li>Types can also contain static methods, which can be called without the need for an instance of that
                    object.</li>
                <li>Static variables are very useful for validation values for a type.</li>
                <li>They can be made private to a class so that their values can be managed by that class.</li>
            </ul>
            <h4>Methods</h4>
            <ul>
                <li>A method is a member of a class.</li>
                <li>It has a signature and a body.</li>
                <li>The signature defines the type and number of parameters that the method will accept.</li>
                <li>The body is a block of code that is performed when the method is called.</li>
                <li>The method method has a return type other than void, all code paths through the body of the code
                    must end with a return statement that returns a value of the type of the method.</li>
                <li>The name of a method is best expressed in a "verb-noun" manner, with an action followed by the thing
                    that the action is acting on.</li>
                <li>When talking about the signature and body we talk in terms of parameters used in the method.</li>
                <li>In the case of a method call we will talk in terms of the arguments supplied to the call.</li>
            </ul>
            <h4>Classes</h4>
            <ul>
                <li>A class can be thought of as a template required to create and instance of a class.</li>
                <li>Instances of a class are created when the new keyword is used. When used, 3 things occur:
                    <ol>
                        <li>The program code that implements the class is loaded into memory, if it is not already
                            present.</li>
                        <li>If this is the first time that the class has been referenced, any static members of the
                            class are initialized and the static constructor is called.</li>
                        <li>The constructor of the class is called.</li>
                    </ol>
                </li>
                <li>A class can contain members that are methods, data variables, or properties.</li>
                <li>A class method allows a class to provide behaviours that can be used by code running in other
                    classes.</li>
                <li>Data variables allow a class to maintain state and manage the storage of information.</li>
                <li>Properties provide a means for managing access to data within a class.</li>
            </ul>
            <h4>Extenison Methods</h4>
            <ul>
                <li>Extension methods provide a way in which behaviours can be added to a class without needing to
                    extend the class itself.</li>
                <li>The first parameter to the method specifies the type that the extension method should be added to,
                    by using the this keyword followed by the name of the type.</li>
                <li>Once created, it can be used from the namespace in which the class containing the method is
                    declared.</li>
                <li>When called the compiler searches the included namespaces for a matching method for that type, and
                    then generates a call of that method.</li>
                <li>Note that extensnion methods are never part of the object they are attached to, since they can't
                    access private members of the method class.</li>
                <li>They can never be used to replace an existing method in a class.</li>
                <li>They allow you to add behaviours to existing classes and use them as if they were part of that
                    class.</li>
            </ul>
            <h4>Optional and Named Parameters</h4>
            <ul>
                <li>If you want to make method calls without worrying about the order of the arguments, you can name
                    each one when you call the method.</li>
                <li>This makes it easy for another programmer reading your code to see the meaning of each argument
                    value.</li>
                <li>Using this format also removes the possibility of any confusion of the ordering of the values in the
                    method call.</li>
                <li>You should use named paramters whenever you call a method that has more than one parameter.</li>
                <li>A paramter is made optional by giving it a default value in the defintion of the method.</li>
                <li>Optional parameters must be provided after all of the required ones.</li>
            </ul>
            <h4>Index Properties</h4>
            <ul>
                <li>A program can access a particular array element by using an index value that identifies the element.
                </li>
                <li>A class can use the same indexing mechanism to provide indexed property values.</li>
                <li>This is how the Dictionary collection is used to index on a particular type of key value.</li>
            </ul>
            <h4>Create Overload and Overridden Methods</h4>
            <ul>
                <li>Overloading is providing a method with the same name, but a different signature in a given type.
                </li>
                <li>It is useful when you want to provide several ways of performing a particular behaviour based of
                    differing circumstances.</li>
                <li>The DateTime strcture has a large number of overloaded constructors, because there are man different
                    ways a programmer might want to initalize a DateTime value.</li>
                <li>Overriding takes place when class hierarchies are used.</li>
                <li>In a class hierarchy a child class is derived from a parent or base class.</li>
                <li>A method in a base class is overridden by a method in a child when the child class contains a method
                    with exactly the same signature as the parent class.</li>
                <li>Only methods that have been marked as virtual in the parent class can be overridden.</li>
                <li>The underlying principle of a class hierarchy is that classes at the top of the hierarchy are more
                    abstract, and classes toward the bottom are more specific.</li>
                <li>The classes higher in the hierarchy hold all the behaviours that are common. While classes lower
                    down might need a more specific behavior and have to override the parent method.</li>
                <li>The whole behavior doesn't need to be rewritten. It can be extended by calling the method in the
                    parent class by using the base keyword.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-2">Skill 2.2: Consuming Types</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Box or unbox to convert between value types</li>
            <li>Cast types</li>
            <li>Convert types</li>
            <li>Handle dynamic types</li>
            <li>Ensure interoperability with unmanaged code that accesses COM APIs</li>
        </ul>
        <div>
            <h3>Boxing and Unboxing</h3>
            <ul>
                <li>From a computational point of view, value types such as int and float have the advantage that the
                    processor can manipulate value types directly.</li>
                <li>Adding two int values tofther can be acheived by fetching the values into the processor, performing
                    the addition operation, and then storing the result.</li>
                <li>It can be useful to treat value types as refrence types. C# runtime system provides a mechanism
                    called boxing that will perform this conversion whenr required.</li>
                <li>The process of converting from a reference type into a value type is called unboxing.</li>
                <li>A .NET program processes data by moving values onto a stack (evaluation stack), performing actions
                    on them, and then storing the results.</li>
                <li>The box instruction (value to reference) and unbox instruction (reference to value) are always given
                    a destination (box) or source (unbox) type to use.</li>
                <li>Each built-in C# value type has a matching C# type called its itnerface type to which it is
                    converted when boxing is performed.</li>
                <li>Fortunately for programmers, the unboxnig and boxing process happens automatically when variables
                    are converted between types.</li>
                <li>Unfortunately, these processes slow the program down.</li>
                <li>The need to box and unbox values in a solution is a symptom of poor design, you should be clear in
                    your design which data items are value types and which references, and work with them correctly.
                </li>
            </ul>
        </div>
        <div>
            <h3>Cast Types</h3>
            <ul>
                <li>Narrowing is when a value is transferred into a type which offers a narrower range of values.</li>
                <li>The integer type does not handle the fractional part of a value, and so a float value will have its
                    fractional part discarded when the assignment takes place.</li>
                <li>The above conversion would not compile unless explicit conversion is used.</li>
                <li>This is achieved by the use of a cast, which identifies the desired type of value being assigned.
                </li>
                <li>The type is given, enclosed in brackets, before the value to be converted.</li>
                <li>Widening is when a value is transferred into a type which offers a wider ranger of value. This
                    doesn't required a cast, because there is no prospect of data loss.</li>
                <li>Casting can't be used to convert between different types, like an integer to a string.</li>
                <li>Casting is also used when converting references to objects that may be part of class hierarchies or
                    expose interfaces.</li>
            </ul>
        </div>
        <div>
            <h3>Convert Types</h3>
            <ul>
                <li>You can write your own type covnersion operators for your data classes so that you can perform
                    implicit and explicit conversions between types.</li>
                <li>An implicit conversion operator is called automatically.</li>
                <li>An explicit conversion operator requires a cast. The conversion is explicit because it is a
                    narrowing operation that will result in a loss of data.</li>
            </ul>
            <h4>Convert Types with System.Convert</h4>
            <ul>
                <li>The System.Convert class provides a set of static methods that can be used to perform type
                    conversion between .NET types.</li>
                <li>A string can be converted to an integer using:
                    <code>int myAge = Convert.ToInt32("21");</code>
                </li>
                <li>The convert method will throw an exception if the string provided cannot be converted into an
                    integer.</li>
            </ul>
        </div>
        <div>
            <h3>Handling Dynamic Types</h3>
            <ul>
                <li>C# is a strongly type language, meaning that when the program is compiled the compiler ensures that
                    all actions that are performed are valid in the contect of the types that have been defined in the
                    program.</li>
                <li>If a class does not contain a method with a particular name, the C# compiler will refuse to generate
                    a call to that method.</li>
                <li>Strong typing works well as a way of making sure C# programs are valid at the time they are
                    executed.</li>
                <li>Strong typing can create issues when a C# program is required to interact with a system with origins
                    not in C#.</li>
                <li>These situations arise when using Common Object Model (COM) interop, the Document Object Model
                    (DOM), with objects generated by C# reflection, or when interworking with dynamic languages such as
                    JavaScript.</li>
                <li>In these situations, you need to force the compiler to interact with objects for which the strong
                    typing information that is generated from compiled C# is not available.</li>
                <li>The dynamic keyword is used to identify items for which the C# compiler should suspend static type
                    checking.</li>
                <li>The compiler will then generate code that works with the items as described, without doing static
                    checking.</li>
                <li>This doesn't mean programs using dynamic objects will always work; if the description is incorrect
                    the program will fail at runtime.</li>
                <li>The dynamic keyword makes it possible to interact with objects that have behaviours, but not the C#
                    type informationthat the C# compiler would normally use to ensure that any interaction is valid.
                </li>
                <li>A variable declared as dynamic is allocated a type that is inferred from the context in which it is
                    used. Similar to variables in Python and JavaScript.</li>
                <li>Just because you can do this doesn't mean you should. The flexibilty was added to make it easier to
                    interact with other languages and libraries written using COM.</li>
            </ul>
            <h4>Use ExpandoObject</h4>
            <ul>
                <li>The ExpandoObject class allows a program to dynamically add properties to an object.
                    <code>
                        dynamic person = new ExpandoObject();

                        person.Name = "Alex Ebbage";
                        person.Age = 24;

                        Console.WriteLine($"Name: {person.Name}, Age: {person.Age}");
                    </code>
                </li>
                <li>A program can add ExpandoObject properties to an ExpandoObject to create nested data structures.
                </li>
                <li>They can also be queried by LINQ and can expose the IDictionary interface to allow its contents to
                    be queried and items to be removed.</li>
                <li>It's especially useful when creating data structures from markup languages, like when reading a JSON
                    or XML document.</li>
            </ul>
        </div>
        <div>
            <h3>Interoperability with Unmanaged Code that Accesses COM APIs</h3>
            <ul>
                <li>The COM is a mechanism that allows software components to interact.</li>
                <li>The model describes how to express an interface to which other objects can connect.</li>
                <li>COM is interesting to programmers because a great many resources you would like to use are exposed
                    via COM interfaces.</li>
                <li>The code inside a COM object runs as unmanaged code, having direct acces to the underlying system.
                </li>
                <li>While possible to run .NET applications in an unmanaged mode, .NET applications usually run inside a
                    managed environment, limiting the level of access that the applications have to the underlying
                    system.</li>
                <li>When a .NET application wants to interact with a COM object it has to perform the following:
                    <ol>
                        <li>Convert any parameters for the COM object into an appropriate format.</li>
                        <li>Switch to unmanaged eecution for the COM behaviour.</li>
                        <li>Invoke the COM behaviour.</li>
                        <li>Switch back to manged execution upon completion of the COM behaviour.</li>
                        <li>Convert any results of the COm request into the correct types of .NET objects.</li>
                    </ol>
                </li>
                <li>This is performed by the Primary Interop Assembly (PIA) component that is supplied along with the
                    COM object.</li>
                <li>The results returned by the PIA can be managed as dynamic objects, so tha thetype of the values can
                    be inferred rather than having to be specified directly.</li>
                <li>The use of dynamic types makes interaction with the Office application very easy.</li>
                <li>There is no need to cast the various elements that the program is interacting with, as they are
                    exposed by the interop as dynamic types, so conversion is performed automatically based on the
                    ienferred type of an assignment destination.</li>
            </ul>
            <h4>Embedding Type Information from Assemblies</h4>
            <ul>
                <li>You can create applications that interact with different versions of Microsoft Office by embedding
                    the Primary Interop Assembly in the application.</li>
                <li>This is achieved by setting the Embed Interop Types option of the assembly reference to True.</li>
                <li>This removes the need for any interop assemblies on the machine running the application.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-3">Skill 2.3: Enforcing Encapsulation</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Enforce encapsulation by using properties</li>
            <li>Enforce encapsulation by using accessors, including public, private, protected, and internal</li>
            <li>Enforce encapsulation by using explicit interface implementation</li>
        </ul>
        <div>
            <h3>Access Modifiers</h3>
            <h4>Public and Private Access</h4>
            <ul>
                <li>C# allows objects to encapsulate data and methods via marking them with access modifiers.</li>
                <li>The public access modifier can be accessed by code that is outside that type.</li>
                <li>A private member of a type can only be accessed by code running inside the type.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Properties</h3>
            <ul>
                <li>A propety in an object provides a way that a programmer can encapsulate data.</li>
                <li>You can get more control over the values assigned to properties by adding validation to the set
                    block of the property.</li>
                <li>If you throw an exception when invalid you ensure that the user is always made aware of any error
                    conditions.</li>
                <li>You can make the set behaviour ignore invalid values, or you could set a default value when an
                    invalid one is provided.</li>
                <li>Read-only properties can be created by only providing a get behaviour.</li>
                <li>You can also make write-only properties in a similar manner, though this ability is less frequently
                    used.</li>
                <li>Different access modifiers can also be applied to the get and set behaviours.</li>
                <li>The backing value of a property is a private data member of the same type as the property, with a
                    name starting with an "_". </li>
                <li>Auto-implemented properties have their backing values automatically created by the C# compiler.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Accessors</h3>
            <ul>
                <li>As a general rule, data held within a type should be private and the methods to access the data
                    inside should be public.</li>
                <li>Properties provide a way to manage access to individual values in a class.</li>
                <li>Making a data member of a class private will stop direct access to that data member.</li>
                <li>From a design perspective, making a class member private and only providing public methods that
                    allow access to that member is a good first step to creating secure code.</li>
                <li>However, you may also have to make sure that you provide a secure workflow that manages access to
                    the data.</li>
            </ul>
            <h4>Default Access Modifiers</h4>
            <ul>
                <li>If you don't specify an access modifer for a member of a type, it'll default to private.</li>
                <li>To make a member visible to the outside it must be done explicitly.</li>
                <li>You don't have to add the private modifier to private members, but it is strongly advised you do.
                </li>
            </ul>
            <h4>Protected Access</h4>
            <ul>
                <li>The protected access modifer makes a class member useable in any classes that extend the parent
                    (base) class in which the member is declared.</li>
                <li>It isn't recommended you use the protected access modifier to control acess to highly important data
                    members of a class.</li>
                <li>Doing so makes it easy for malicious programemrs to gain access to the protected member by extending
                    the parent class.</li>
                <li>A good use is to limit access to helper methods that have no meaningful use outside of the class
                    hierarchy.</li>
            </ul>
            <h4>Internal Access</h4>
            <ul>
                <li>The internal access modifier will make a meber of a type accessible within the assembly in which it
                    is declared.</li>
                <li>An assembly can be regarded as the output of a C# project in Visual Studio.</li>
                <li>It can be iether an executable program or a library of classes.</li>
                <li>Internal access is most useful when you have a large number of cooperating classes that are being
                    used to provide a particular library component.</li>
                <li>These classes may want to share memebers which should not be visible to programs that use the
                    library.</li>
            </ul>
            <h4>Readonly Access</h4>
            <ul>
                <li>The readonly access modifier will make a member of a type read only.</li>
                <li>The value member can only be set at declaration or within the constructor of the class.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Explicity Interface Implementation</h3>
            <ul>
                <li>When a class implements an interfface it contains methods with signatures that match the ones
                    specified in the interface.</li>
                <li>You can use an explicit interface implementation to make methods implementing an interface only
                    visible when the object is accessed via an interface reference.</li>
                <li>You might want an IPrintable interface that specifies methods used to print any object. This is a
                    good idea because now a printer can be asked to print any item that is referred to by a reference of
                    IPrintable type.</li>
                <li>In other words, any object that implemetns the method in IPrintable can be printed.</li>
                <li>Methods in the IPrintable interface only have meaning when being used by something trying to print
                    an object. It's not sensible to call the printing methods in any other context than via the
                    IPrintable reference.</li>
                <li>This can be achieved by making the implementation of the print methods explicit, thus adding the
                    interface name to the delcaration of the method body.</li>
                <li>When you use an interface in a program you should ensure that all the implementations of any
                    interface methods are explicit. This reduces the chances of the interface methods being used in an
                    incorrect contect.</li>
            </ul>
            <h4>Resolving Duplicate Method Signatures by Using Explicit Implementation</h4>
            <ul>
                <li>When a class implements an interface it must contain an implementation of all methods that are
                    defined in the interface.</li>
                <li>Sometimes a class may implement multiple interfaces, in which case it must contain all the methods
                    defined in all the interfaces.</li>
                <li>Issues can occur if 2 interfaces contain a method with the same name.</li>
                <li>This can be resolved by specifying the interface name to the declaration of the method body.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-4">Skill 2.4: Create and Implement a Class Hierarchy</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Design and implement an interface</li>
            <li>Inherit from a base class</li>
            <li>Create and implement classes based on the IComparable, IEnumerable, IDisposable, and IUnknown interfaces
            </li>
        </ul>
        <div>
            <h3>Design and Implement an Interface</h3>
            <ul>
                <li>You can think of the elements of a power specification as an "interface" that defines how an
                    electrical device in a house can be connected to a power supply.</li>
                <li>These components are possible because standard interfaces have been created to describe exactly how
                    they fit together.</li>
                <li>Components are required because without them they can't be replaced because systems would be
                    hard-wired together.</li>
            </ul>
            <h4>Software Componenets and Interfaces</h4>
            <ul>
                <li>An interface in C# specifies how a software component could be used by another software component.
                </li>
                <li>Instead of starting to build an application by designing classes, you should think about describing
                    their interfaces.</li>
                <li>How a component functions can be encapsulated inside the component.</li>
                <li>A C# interface contains a set of method signatures. </li>
                <li>If a class contains an implementation of all of the methods described in the interface it can be
                    defined as "implementing" that interface.</li>
                <li>Interfaces allow a program to regard objects in terms of their abilities, rather than what type an
                    object actually is.</li>
                <li>If you hired a painter to paint your house in real life, you'd hire them based on their ability to
                    paint rather than who they are.</li>
                <li>As an example of where interfaces are useful, consider a printing service that will print objects in
                    an application. The IPrintable interface will contain the definition of the methods that can be used
                    to print a document on paper.</li>
                <li>The methods of the interface do not ask a document to print itself, rather they ask the docment to
                    provide the text strings that the printer will put onto paper.</li>
                <li>A print object can be created that will accept and print objects implementing the IPrintable
                    interface.</li>
                <li>This interface decouples the printer from the object being printed. If you create a new object that
                    needs to be printed, it can be done without modifying the printer class.</li>
                <li>Conversely, you can add new types of print and be sure that the new print type can be used to print
                    any object that implements IPrintable.</li>
            </ul>
            <h4>Design an Interface</h4>
            <ul>
                <li>An interface is placed in a source file just like a class, and is compiled in the same way.</li>
                <li>It sets out a number of methods that relate to a particular task or role.</li>
                <li>The naming convention is to start the interface name with an I.</li>
                <li>When you tell the compiler that a class implements an interface, it means the class contains
                    implementations of all the methods described in the interface.</li>
                <li>It is good practice to explicitly implement each method for the interface so the methods are only
                    exposed when the object is referred to by a reference of the interface's type.</li>
            </ul>
            <h4>References to Interfaces</h4>
            <ul>
                <li>With interfaces you are moving away from conisdering classes in terms of what they are, and starting
                    to think about them in terms of what they can do.</li>
                <li>In the case of bank, you want to deal with objects in terms of IAccount (the set of account
                    abilities) rather than BankAccount (a particular account class).</li>
                <li>In C# terms this means that you need to create reference variables that refer to objects in terms of
                    interfaces they implement, rather than the particular type that they are.</li>
                <li>There will never be an instance of the IAccount interface, this is simply a way that you can refer
                    to something which has that ability.</li>
                <li>This is like in real life where there is no such physical thing as a "writer", merely a large number
                    of people who can be referred to as having that particular ability or role.</li>
            </ul>
        </div>
        <div>
            <h3>Inherit from a Base Class</h3>
            <ul>
                <li>One fundamental principle of software development is to ensure that you create every piece of code
                    in an application precisely once.</li>
                <li>This is because if you have a bug in a piece of code, and that code has been abstracted into a
                    method, you only have to fix the code once.</li>
                <li>A class hierarchy is a great way to reuse code so that you only have to create a behaviour in one
                    place and can reuse it where it makes sense to.</li>
                <li>A class hierarchy is used when an application must manipulate items that are part of a particular
                    group.</li>
                <li>If you have classes BankAccount and SavingsAccount which both implement IAccount, yet their
                    functionality is very similar, you'll have to rewrite a lot of the same code.</li>
                <li>Inheritance can be used to tell the compiler that SavingsAccount is based on BankAccount.</li>
                <li>Inheritance allows SavingsAccount to do everything the parent or base class, BankAccount, can do.
                </li>
            </ul>
            <h4>The Is and As Operators</h4>
            <ul>
                <li>The is and as operators are used when working with class hierarchies and interfaces.</li>
                <li>The is operator determines if the type of a given object is in a particular class hierarchy or
                    implements a specifed inteface.</li>
                <li>You apply the is operator between a reference variable and a type or interface. The operator will
                    return true if the reference can be made to refer to objects of that type.</li>
                <li>The as operator takes a reference and a type and returns a reference of the given type, or null if
                    the reference cannot be made to refer to the object.</li>
                <li>The difference between the as operator and a cast, is that if a cast cannot be performed a program
                    will throw an exception. If the as operator fails it returns a null reference and the program
                    continues.</li>
            </ul>
            <h4>Overriding Methods</h4>
            <ul>
                <li>Overriding replaces a method in a base class with a version that provides the behaviour appropriate
                    to the child class.</li>
                <li>The override keyword means "use this version of the method in preference to the one in the base
                    class".</li>
                <li>Declaring a method as virtual tell the C# compiler a method can be overridden by classes which are
                    children of the parent class. This needs to be done as the compiler calls overridden methods in a
                    slightly different way to "normal" ones.</li>
                <li>Explicit implementations of interface methods cannot be overridden. You have to sacrifice a bit of
                    encapsulation in order to use class hierarchies in this manner.</li>
                <li>If child classes need access to a private member of a parent class, the access modifier needs to be
                    changed to protected.</li>
            </ul>
            <h4>Using the Base Method</h4>
            <ul>
                <li>The base keyword in the context of an overridden method means "a reference to the thing which has
                    been overriden".</li>
                <li>By doing this, it saves you from having to duplicate code and it can allow you to keep members of
                    the base class private.</li>
                <li>If a bug occurs in the behaviour of a top-level class, only the top-level class needs to be fixed
                    for the behaviour to work in all the child classes which call back to it.</li>
            </ul>
            <h4>Replacing Methods in Base Classes</h4>
            <ul>
                <li>If the new keyword is used instead of the override one when creating a method in a child class, it
                    simply creates a new version of the method.</li>
                <li>The replacement method is not able to use base to call the method that has been overridden, as it is
                    replaced.</li>
            </ul>
            <h4>Stopping Overriding</h4>
            <ul>
                <li>Overriding/replacing is not always desirable.</li>
                <li>A malicious programmer can writer their own version of a method in a child class and override or
                    rplace the one in the parent.</li>
                <li>The sealed keyword means "You can't override this method any more". Child classes are prevented from
                    replacing a method in a parent.</li>
            </ul>
            <h4>Constructors and Class Hierarchies</h4>
            <ul>
                <li>A constructor is a method which gets control during the process of object creation and is used to
                    set the initial values of the object.</li>
                <li>Adding a constructor to a base class in a class hierarchy can break all the child classes. This is
                    because creating a child class instance involves creating an instance of the base class.</li>
                <li>If it does, a call must be made from the constructor of the child classes to the constructor of the
                    base class.</li>
            </ul>
            <h4>Abstract Methods and Classes</h4>
            <ul>
                <li>Methods can be made abstract to force child classes to provide an implementation for them.</li>
                <li>A virtual "default" method can be provided by a parent class, then the programmers of the child
                    classes can be relied on to override them with more specific behaviours.</li>
                <li>If a method is flagged as abstract then no method body is provided in the class.</li>
                <li>A class that contains an abstract method means that it is abstract itself and must be marked as
                    such.</li>
                <li>You can't create an isntance of an abstract class, they can essentially be thought of as templates.
                </li>
                <li>If you want to make an instance of a classed based on an abstract parent, you must provide
                    implementations of all the abstract methods given in the parent.</li>
            </ul>
            <h4>Abstract Classes and Interfaces</h4>
            <ul>
                <li>Abstract classes look similar to interfaces.</li>
                <li>However, abstract classes can contain fully implemented methods alongside the abstract ones.</li>
                <li>This is useful because it means you don't have to repeatedly implement the same methods in each of
                    the components that implement a particular interface.</li>
                <li>A class can only inherit from one parent, so it can only pick up the behaviours of one class.</li>
                <li>Some languages support multiple inheritance, where a class can inherit from multiple parents.</li>
            </ul>
            <h4>References in Class Hierarchies</h4>
            <ul>
                <li>A reference to a base class in a class hierarchy can refer to an instance of any of the classes that
                    inherits from that base class.</li>
                <li>A variable declared as a reference object cannot be made to refer to a class higher in the class
                    hierarchy because a child class may have added behaviours to the parent class.</li>
                <li>Some prefer to manage references to objects in terms of the interfaces than the type of the
                    particular object. It is more flexible as you're not restricted to a particular type of object.</li>
            </ul>
        </div>
        <div>
            <h3>Create and Implement Classes Based on the IComparable, IEnumerable, IDisposable, and IUnknown Interfaces
            </h3>
            <ul>
                <li>.NET framework provides services that make use of particular behaviours that may be provided by a
                    given object.</li>
                <li>Each of these behaviours is described by an interface.</li>
            </ul>
            <h4>IComparable</h4>
            <ul>
                <li>IComparable is used to determine the order of objects when they are sorted.</li>
                <li>It contains a single method, CompareTo, which compares one object to another.</li>
                <li>A result of 0 indicates a match. Less than 0 indicates it should be placed before the object it's
                    being compared to. Greater than 0 indicates it should be placed after the object it's being compared
                    to.</li>
            </ul>
            <h4>Typed IComparable</h4>
            <ul>
                <li>The IComparable interface uses a CompareTo method that accepts an object reference as a paramter.
                </li>
                <li>This reference should refer to an object of the same type as the object that is doing the comparing.
                </li>
                <li>If the program attempts to compare and object with something that isn't a comparable type an error
                    will be produced at runtime.</li>
                <li>There is another version of the IComparable interface that accepts a type. This can be used to
                    create a CompareTo that only accepts parameters of a specified type.</li>
                <li>It might be necessary to make your interface extend IComparable to ensure that any objects that
                    implement your interface also implement IComparable.</li>
                <li>So, it is possible to create interface hierarchies, though it is not something you'll do very often.
                </li>
            </ul>
            <h4>IEnumerable</h4>
            <ul>
                <li>Programs spend a lot of time consuming lists and other collections of items. This is called
                    iterarting or enumerating.</li>
                <li>Any C# object can implement IEnumerable interface that allows other programs to get an enumerator
                    from that object. The enumerator object can then be used to enumerate the object.</li>
                <li>GetEnumerator() can be called to get an enumertor, which exposes MoveNext(), which returns true if
                    it can move onto another item in the enumeration.</li>
                <li>The enumerator also exposes a proeprty called Current, which is a reference to the currently
                    selected item in the enumerator.</li>
                <li>A foreach construction can be used to automatically get the enumerator from an object and to work
                    through it.</li>
            </ul>
            <h4>Making an Object Enumerable</h4>
            <ul>
                <li>The IEnumberable interface allows you to create objects that can be enumerated within your programs,
                    like the foreach loop construction.</li>
                <li>To implement it an object needs to implement the IEnumberable and IEnumerator&lt;T&gt; interfaces.
                </li>
                <li>IEnumberable means an object can be enumeratred.</li>
                <li>IEnumerator&lt;T&gt; means an object contains a call of GetEnumerator to get an enumerator from it.
                </li>
            </ul>
            <h4>Using Yield</h4>
            <ul>
                <li>To make the creation of enumerators simpler C# includes the yield keyword.</li>
                <li>The yield keyword is followed by the return keyword and precedes the value to be returned for the
                    current iteration.</li>
                <li>The C# compiler generates all the Current and MoveNext behaviours that make the iteration work, and
                    also records the state of the iterator method so that the iterator method resumes at the statement
                    following the yield statement when the next iteration is requested.</li>
                <li>The yield keyword does 2 things:
                    <ul>
                        <li>It specifies the value to be returned for a given iteration.</li>
                        <li>It returns control to the iterating method.</li>
                    </ul>
                </li>W
            </ul>
            <h4>IDisposable</h4>
            <ul>
                <li>C# provides memory management for applications, but it can't control how programs use other
                    resources such as file hadnles, database connections and lock objects.</li>
                <li>While an object can get control when it is removed by the garbage collector it is hard for a
                    developer to know precisely when this happens. It amy not even happens until the program ends.</li>
                <li>The IDisposable interface provides a way that an object can indicate that it contains an explict
                    Dispose method that can be used to tidy up an object when an application has finished using it.</li>
                <li>A disposed object may exist in memory, but any attempts to use it will result in the
                    ObjectDisposedExpection being thrown.</li>
                <li>The action of the Dispose method depends entirely on the needs of the application.</li>
                <li>The dispose methodis not called automatically when an object is deleted from memory.</li>
                <li>There are two ways to make sure that Dipose is called correctly:
                    <ul>
                        <li>You can call the method yourself in your application.</li>
                        <li>You can make suse of the C# using construction.</li>
                    </ul>
                </li>
                <li>The using construction creates an instance of the object that implements IDisposable, is followed by
                    a block of code that uses the object, and then Dispose() is called at the end of the block.</li>
            </ul>
            <h4>IUnknown</h4>
            <ul>
                <li>Dynamic types are used to interact with services provided via the Component Object Model (COM).</li>
                <li>Interop services return results which are dynamically typed, and the program can use these results
                    by assinging them to correctly typed variables.</li>
                <li>Interop services are implemented as C# libraries that marshal te data between the managed code world
                    of C# and the unmanaged world of COM objects.</li>
                <li>The IUnknown interface is a means by which one object describes the interfaces that it makes
                    avaialable for use by others.</li>
                <li>It provides a means by which .NET applications can interoperate with COM object at this level.</li>
                <li>You can use it when connection C# applications to COM objects.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-5">Skill 2.5: Find, Execute and Create Types At Runtime</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-6">Skill 2.6: Managing the Object Lifecycle</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-7">Skill 2.7: Manipulating Strings</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="qa-2">Thought Experiments</h2>
        <div>
            <h3>HEADING</h3>
            <p>DESCRIPTION</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">QUESTION</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
    </div>
</div>