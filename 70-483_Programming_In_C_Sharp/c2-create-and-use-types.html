<div>
    <h1 id="chapter-2">Chapter 2: Create and Use Types</h1>
    <p>Skills covered in this chapter are:</p>
    <ul>
        <li><a href="#skill-2-1">Skill 2.1: Creating Types</a></li>
        <li><a href="#skill-2-2">Skill 2.2: Consuming Types</a></li>
        <li><a href="#skill-2-3">Skill 2.3: Enforcing Encapsulation</a></li>
        <li><a href="#skill-2-4">Skill 2.4: Create and Implement a Class Hierarchy</a></li>
        <li><a href="#skill-2-5">Skill 2.5: Find, Execute and Create Types At Runtime</a></li>
        <li><a href="#skill-2-6">Skill 2.6: Managing the Object Lifecycle</a></li>
        <li><a href="#skill-2-7">Skill 2.7: Manipulating Strings</a></li>
        <li><a href="#qa-2">Thought Experiments</a></li>
    </ul>
    <div>
        <h2 id="skill-2-1">Skill 2.1: Creating Types</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Create value types, including structs and enum</li>
            <li>Create reference types, generic types, constructors, static variables, method, classes and extension
                methods</li>
            <li>Create optional and named paramters</li>
            <li>Create indexed properties</li>
            <li>Create overloaded and overridden methods</li>
        </ul>
        <div>
            <h3>Value and Reference Types</h3>
            <ul>
                <li>Consider you have 2 variables, x and y, and you make the statement <code>y.Data = 99; x = y; x.Data
                        = 100;</code>...</li>
                <li>If the variables x and y are value types, the value of y is copied into the variable x. The Data
                    property of y is not affected by the final assignment to x.</li>
                <li>If the variables x and y are referemce types, the variable x is made to refer to the same object as
                    that referred to by variable y. The final assignment will make the Data property of a single object
                    set to 100.</li>
                <li>Structure variables are managed by value and class variables are managed by reference.</li>
            </ul>
            <h4>Value and Referene Types in .NET</h3>
                <ul>
                    <li>A good example of a value type is the DateTime structure provided by the .NET library.</li>
                    <li>You could represent date values in the form of a collection of individual values, but assigning
                        one date to another would be time-consuming as the program would have to transfer each value.
                    </li>
                    <li>Having a DateTime type means you can move a date value between variables with a single
                        assignment. During a DateTime assignment all the values that represent the date are copied into
                        the destination variable.</li>
                    <li>A good example of a reference type is the Bitmap class from the System.Drawing library in .NET.
                    </li>
                    <li>The Bitmap class is used to create objects that hold the pixels which make up an image which
                        could be millions.</li>
                    <li>If a Bitmap is held as a value type, when one is assigned to another, all the pixels in the
                        source Bitmap must be copied from the source image into the destination.</li>
                    <li>As they are managed by reference, an assignment simply makes the destination reference refer to
                        the same object as the source reference.</li>
                </ul>
                <h4>Type Design</h3>
                    <ul>
                        <li>Using the design of a space shooter game as an example...</li>
                        <li>The location of the alien on the screen should be a value type, as you'd want the position
                            as a single value. You don't want to share coordinates between aliens.</li>
                        <li>A sound effect would be a reference type, as it'd store a large array of integer data which
                            represent a given sound. You may want serveral aliens to share the same sound.</li>
                        <li>In C#, value types are enumerated types and references. Reference types are classes.</li>
                    </ul>
                    <h4>Immutablity in Types</h3>
                        <ul>
                            <li>An immutable type is one whose instances cannot be changed.</li>
                            <li>The DateTime structure is an immutable type. Once an isntance is created you cannot
                                change any elements of that instance.</li>
                            <li>The only way to edit them is to create a new DateTime value that contains the updated
                                values.</li>
                            <li>Changing the values of an immutable type is less efficient as it requires the creation
                                of a new object each time.</li>
                            <li>However, it removes the possiblity of elements in a variable changing once created.</li>
                            <li>They are advantagous when writing concurrent programs as they can never be corrupted
                                because they can never be changed.</li>
                            <li>The string type in C# is also immutable.</li>
                        </ul>
        </div>
        <div>
            <h3>Creating Value Types</h3>
            <h4>Structures</h4>
            <ul>
                <li>Structures can contain methods, data values, properties and can have constructors.</li>
                <li>The constructor for a structure must initalize all the data members. They cannot be initalized in
                    the structure.</li>
                <li>A structure cannot have a parameterless constructor. However, a structure can be created by calling
                    a parameterless constructor which sets all elements to have default values.</li>
                <li>A structure cannot be created by extending a parent structure object.</li>
                <li>Structure isntances are generally created on the program stack unless they are used in closures.
                </li>
                <li>An array of structure instances will be created as a block of contiguous memory, which holds all the
                    required items.</li>
                <li>A structure definition can contain overrides, e.g. ToString(). A structure cannot use a class
                    hierarchy, because it is posible to override methods from the parent type of a struct.</li>
            </ul>
            <h4>Enumerated Types</h4>
            <ul>
                <li>Enumerated types are used in situations where the programemr wants to specify a range of values a
                    given type can have.</li>
                <li>For example, they might want to represent the states of an AI: sleeping, attacking or destroyed. An
                    integer could be used for this but if 1-3 are used for these states and 4 is given, it will have no
                    meaning.</li>
                <li>Unless specified otherwise, an enumerated type is based on the int type and values start from 0.
                </li>
                <li>You would do this if you want to set particular values to be used in JSON and XML files when
                    enumerated variables are stored.</li>
            </ul>
        </div>
        <div>
            <h3>Creating Reference Types</h3>
            <ul>
                <li>A class is declared in a similar manner to a structure, but the way in which they are manipulated is
                    significantly different.</li>
                <li>When a variable of a class type is declared, the variable is now a refernce to that object.</li>
            </ul>
            <h4>Memory Allocation</h4>
            <ul>
                <li>Memory used to store variables of value type is allocated on the stack.</li>
                <li>The stack is an area of memory that is allocated and removed as programs enter and leave blocks.
                </li>
                <li>Any value type variables created during the execution of a block are stored on a local stack
                    frame and then the entire frame is discarded when the block completes.</li>
                <li>This is an extremely efficient way to manage memory.</li>
                <li>Memory used to store variables of reference type is allocated on the heap.</li>
                <li>The heap is managed for an entire application.</li>
                <li>The heap is required because, as references may eb passed between method calls as paramters, it
                    is not the ase that objects managed by refence cane be discarded when a method exits.</li>
                <li>Objects can only be removed from the heap when the garbage collection process determines that
                    there are no references to them.</li>>
            </ul>
            <h4>Generic Types</h4>
            <ul>
                <li>Generic types are used extensively in C# collections, such as with the List and Dictionary
                    classes.</li>
                <li>They allow you to create a List of any type or a Dictionary of any type, indexed on any
                    type.</li>
                <li>Without generic types you either have to reduce type safety in your programs by using
                    collections that manage only objects, or you have to waste time creating collections for
                    each type.</li>
                <li>An example of a generic stack is shown below:
                    <code>
                        class MyStack&lt;T&gt;
                        {
                        <span class="i1">&nbsp;</span>int stackTop = 0;
                        <span class="i1">&nbsp;</span>T[] items = new T[100];

                        <span class="i1">&nbsp;</span>public void Push(T item)
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>if (stackTop == items.Length)
                        <span class="i3">&nbsp;</span>throw new Exception("Stack full!");
                        <span class="i2">&nbsp;</span>items[stackTop] = item;
                        <span class="i2">&nbsp;</span>stackTop++;
                        <span class="i1">&nbsp;</span>}

                        <span class="i1">&nbsp;</span>public T Pop()
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>if (stackTop == 0)
                        <span class="i3">&nbsp;</span>throw new Exception("Stack empty!");
                        <span class="i2">&nbsp;</span>stackTop--;
                        <span class="i2">&nbsp;</span>return items[stackTop];
                        <span class="i1">&nbsp;</span> }

                        <span class="i1">&nbsp;</span>static void Main(string[] args)
                        <span class="i1">&nbsp;</span>{
                        <span class="i2">&nbsp;</span>MyStack&lt;string&gt; stringStack = new
                        <span class="i2">&nbsp;</span>MyStack&lt;string&gt;();
                        <span class="i2">&nbsp;</span>stringStack.Push("Apple");
                        <span class="i2">&nbsp;</span>Console.WriteLine(stringStack.Pop());
                        <span class="i2">&nbsp;</span>Console.ReadKey();
                        <span class="i1">&nbsp;</span>}
                        }
                    </code>
                </li>
            </ul>
            <h4>Generic Contstraints</h4>
            <ul>
                <li>There are several constraints which can be applied to the class declaration to restrict types which
                    can be represented by T:
                    <ul>
                        <li><b>where T : class</b> The type T must be a reference type.</li>
                        <li><b>where T : struct</b> The type T must be a value type.</li>
                        <li><b>where T : new()</b> The type T must have a public, parameterless, constructor. Specify
                            this constraint last if you are specifying a list of constraints.</li>
                        <li><b>where T : &lt;base class&gt;</b> The type T must be of type base class or derive from
                            base class.</li>
                        <li><b>where T : &lt;interface name&gt;</b> The type T must be or implement the specifed
                            interface. You can specify multiple interfaces.</li>
                        <li><b>where T : &lt;unmanaged&gt;</b> The type T must not be a reference type or contain any
                            members which are reference types.</li>
                    </ul>
                </li>
            </ul>
            <h4>Constructors</h4>
            <ul>
                <li>A constructor allows a programmer to control the process by which objects are craeted.</li>
                <li>Constructors can be used by both reference types (classes) and value types (stuctures).</li>
                <li>A constructor has the same name as the object it is part of but does not have a return type.</li>
                <li>They can perform validation on their parameters to ensure that any objects created contain valid
                    information.</li>
                <li>If invalid, a constructor must throw an exception to prevent the creation of an object.</li>
                <li>If an object only has a private constructor, it must be instantiated using a public factory method
                    that is declared in the same class.</li>
                <li>Constructors can be overloaded, so an object can contain multiple versions of a consntructor with
                    different signatures.</li>
                <li>A program can avoid code repition by making one constructor call another constructor by the use of
                    the keyword this.</li>
            </ul>
            <h4>Static Constructors</h4>
            <ul>
                <li>A static consturctor method is called once before the creation of the very first instance of the
                    class.</li>
                <li>It is a good place to load resources and initialize values that will be ysed by instances of the
                    class.</li>
                <li>They can include values of static members of the class.</li>
            </ul>
            <h4>Static Variables</h4>
            <ul>
                <li>A static varialb eis a member of a type, but it is not created for each instance of a type.</li>
                <li>A variable in a class is made static by using the static keyword in the declaration of that
                    variable.</li>
                <li>Code outside the class must refer to static variables via the class name, rather than the name of
                    any particular instance of that class.</li>
                <li>A program can use astic variable from a type without needing to have created any instances of that
                    type.</li>
                <li>Types can also contain static methods, which can be called without the need for an instance of that
                    object.</li>
                <li>Static variables are very useful for validation values for a type.</li>
                <li>They can be made private to a class so that their values can be managed by that class.</li>
            </ul>
            <h4>Methods</h4>
            <ul>
                <li>A method is a member of a class.</li>
                <li>It has a signature and a body.</li>
                <li>The signature defines the type and number of parameters that the method will accept.</li>
                <li>The body is a block of code that is performed when the method is called.</li>
                <li>The method method has a return type other than void, all code paths through the body of the code
                    must end with a return statement that returns a value of the type of the method.</li>
                <li>The name of a method is best expressed in a "verb-noun" manner, with an action followed by the thing
                    that the action is acting on.</li>
                <li>When talking about the signature and body we talk in terms of parameters used in the method.</li>
                <li>In the case of a method call we will talk in terms of the arguments supplied to the call.</li>
            </ul>
            <h4>Classes</h4>
            <ul>
                <li>A class can be thought of as a template required to create and instance of a class.</li>
                <li>Instances of a class are created when the new keyword is used. When used, 3 things occur:
                    <ol>
                        <li>The program code that implements the class is loaded into memory, if it is not already
                            present.</li>
                        <li>If this is the first time that the class has been referenced, any static members of the
                            class are initialized and the static constructor is called.</li>
                        <li>The constructor of the class is called.</li>
                    </ol>
                </li>
                <li>A class can contain members that are methods, data variables, or properties.</li>
                <li>A class method allows a class to provide behaviours that can be used by code running in other
                    classes.</li>
                <li>Data variables allow a class to maintain state and manage the storage of information.</li>
                <li>Properties provide a means for managing access to data within a class.</li>
            </ul>
            <h4>Extenison Methods</h4>
            <ul>
                <li>Extension methods provide a way in which behaviours can be added to a class without needing to
                    extend the class itself.</li>
                <li>The first parameter to the method specifies the type that the extension method should be added to,
                    by using the this keyword followed by the name of the type.</li>
                <li>Once created, it can be used from the namespace in which the class containing the method is
                    declared.</li>
                <li>When called the compiler searches the included namespaces for a matching method for that type, and
                    then generates a call of that method.</li>
                <li>Note that extensnion methods are never part of the object they are attached to, since they can't
                    access private members of the method class.</li>
                <li>They can never be used to replace an existing method in a class.</li>
                <li>They allow you to add behaviours to existing classes and use them as if they were part of that
                    class.</li>
            </ul>
            <h4>Optional and Named Parameters</h4>
            <ul>
                <li>If you want to make method calls without worrying about the order of the arguments, you can name
                    each one when you call the method.</li>
                <li>This makes it easy for another programmer reading your code to see the meaning of each argument
                    value.</li>
                <li>Using this format also removes the possibility of any confusion of the ordering of the values in the
                    method call.</li>
                <li>You should use named paramters whenever you call a method that has more than one parameter.</li>
                <li>A paramter is made optional by giving it a default value in the defintion of the method.</li>
                <li>Optional parameters must be provided after all of the required ones.</li>
            </ul>
            <h4>Index Properties</h4>
            <ul>
                <li>A program can access a particular array element by using an index value that identifies the element.
                </li>
                <li>A class can use the same indexing mechanism to provide indexed property values.</li>
                <li>This is how the Dictionary collection is used to index on a particular type of key value.</li>
            </ul>
            <h4>Create Overload and Overridden Methods</h4>
            <ul>
                <li>Overloading is providing a method with the same name, but a different signature in a given type.
                </li>
                <li>It is useful when you want to provide several ways of performing a particular behaviour based of
                    differing circumstances.</li>
                <li>The DateTime strcture has a large number of overloaded constructors, because there are man different
                    ways a programmer might want to initalize a DateTime value.</li>
                <li>Overriding takes place when class hierarchies are used.</li>
                <li>In a class hierarchy a child class is derived from a parent or base class.</li>
                <li>A method in a base class is overridden by a method in a child when the child class contains a method
                    with exactly the same signature as the parent class.</li>
                <li>Only methods that have been marked as virtual in the parent class can be overridden.</li>
                <li>The underlying principle of a class hierarchy is that classes at the top of the hierarchy are more
                    abstract, and classes toward the bottom are more specific.</li>
                <li>The classes higher in the hierarchy hold all the behaviours that are common. While classes lower
                    down might need a more specific behavior and have to override the parent method.</li>
                <li>The whole behavior doesn't need to be rewritten. It can be extended by calling the method in the
                    parent class by using the base keyword.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-2">Skill 2.2: Consuming Types</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Box or unbox to convert between value types</li>
            <li>Cast types</li>
            <li>Convert types</li>
            <li>Handle dynamic types</li>
            <li>Ensure interoperability with unmanaged code that accesses COM APIs</li>
        </ul>
        <div>
            <h3>Boxing and Unboxing</h3>
            <ul>
                <li>From a computational point of view, value types such as int and float have the advantage that the
                    processor can manipulate value types directly.</li>
                <li>Adding two int values tofther can be acheived by fetching the values into the processor, performing
                    the addition operation, and then storing the result.</li>
                <li>It can be useful to treat value types as refrence types. C# runtime system provides a mechanism
                    called boxing that will perform this conversion whenr required.</li>
                <li>The process of converting from a reference type into a value type is called unboxing.</li>
                <li>A .NET program processes data by moving values onto a stack (evaluation stack), performing actions
                    on them, and then storing the results.</li>
                <li>The box instruction (value to reference) and unbox instruction (reference to value) are always given
                    a destination (box) or source (unbox) type to use.</li>
                <li>Each built-in C# value type has a matching C# type called its itnerface type to which it is
                    converted when boxing is performed.</li>
                <li>Fortunately for programmers, the unboxnig and boxing process happens automatically when variables
                    are converted between types.</li>
                <li>Unfortunately, these processes slow the program down.</li>
                <li>The need to box and unbox values in a solution is a symptom of poor design, you should be clear in
                    your design which data items are value types and which references, and work with them correctly.
                </li>
            </ul>
        </div>
        <div>
            <h3>Cast Types</h3>
            <ul>
                <li>Narrowing is when a value is transferred into a type which offers a narrower range of values.</li>
                <li>The integer type does not handle the fractional part of a value, and so a float value will have its
                    fractional part discarded when the assignment takes place.</li>
                <li>The above conversion would not compile unless explicit conversion is used.</li>
                <li>This is achieved by the use of a cast, which identifies the desired type of value being assigned.
                </li>
                <li>The type is given, enclosed in brackets, before the value to be converted.</li>
                <li>Widening is when a value is transferred into a type which offers a wider ranger of value. This
                    doesn't required a cast, because there is no prospect of data loss.</li>
                <li>Casting can't be used to convert between different types, like an integer to a string.</li>
                <li>Casting is also used when converting references to objects that may be part of class hierarchies or
                    expose interfaces.</li>
            </ul>
        </div>
        <div>
            <h3>Convert Types</h3>
            <ul>
                <li>You can write your own type covnersion operators for your data classes so that you can perform
                    implicit and explicit conversions between types.</li>
                <li>An implicit conversion operator is called automatically.</li>
                <li>An explicit conversion operator requires a cast. The conversion is explicit because it is a
                    narrowing operation that will result in a loss of data.</li>
            </ul>
            <h4>Convert Types with System.Convert</h4>
            <ul>
                <li>The System.Convert class provides a set of static methods that can be used to perform type
                    conversion between .NET types.</li>
                <li>A string can be converted to an integer using:
                    <code>int myAge = Convert.ToInt32("21");</code>
                </li>
                <li>The convert method will throw an exception if the string provided cannot be converted into an
                    integer.</li>
            </ul>
        </div>
        <div>
            <h3>Handling Dynamic Types</h3>
            <ul>
                <li>C# is a strongly type language, meaning that when the program is compiled the compiler ensures that
                    all actions that are performed are valid in the contect of the types that have been defined in the
                    program.</li>
                <li>If a class does not contain a method with a particular name, the C# compiler will refuse to generate
                    a call to that method.</li>
                <li>Strong typing works well as a way of making sure C# programs are valid at the time they are
                    executed.</li>
                <li>Strong typing can create issues when a C# program is required to interact with a system with origins
                    not in C#.</li>
                <li>These situations arise when using Common Object Model (COM) interop, the Document Object Model
                    (DOM), with objects generated by C# reflection, or when interworking with dynamic languages such as
                    JavaScript.</li>
                <li>In these situations, you need to force the compiler to interact with objects for which the strong
                    typing information that is generated from compiled C# is not available.</li>
                <li>The dynamic keyword is used to identify items for which the C# compiler should suspend static type
                    checking.</li>
                <li>The compiler will then generate code that works with the items as described, without doing static
                    checking.</li>
                <li>This doesn't mean programs using dynamic objects will always work; if the description is incorrect
                    the program will fail at runtime.</li>
                <li>The dynamic keyword makes it possible to interact with objects that have behaviours, but not the C#
                    type informationthat the C# compiler would normally use to ensure that any interaction is valid.
                </li>
                <li>A variable declared as dynamic is allocated a type that is inferred from the context in which it is
                    used. Similar to variables in Python and JavaScript.</li>
                <li>Just because you can do this doesn't mean you should. The flexibilty was added to make it easier to
                    interact with other languages and libraries written using COM.</li>
            </ul>
            <h4>Use ExpandoObject</h4>
            <ul>
                <li>The ExpandoObject class allows a program to dynamically add properties to an object.
                    <code>
                        dynamic person = new ExpandoObject();

                        person.Name = "Alex Ebbage";
                        person.Age = 24;

                        Console.WriteLine($"Name: {person.Name}, Age: {person.Age}");
                    </code>
                </li>
                <li>A program can add ExpandoObject properties to an ExpandoObject to create nested data structures.
                </li>
                <li>They can also be queried by LINQ and can expose the IDictionary interface to allow its contents to
                    be queried and items to be removed.</li>
                <li>It's especially useful when creating data structures from markup languages, like when reading a JSON
                    or XML document.</li>
            </ul>
        </div>
        <div>
            <h3>Interoperability with Unmanaged Code that Accesses COM APIs</h3>
            <ul>
                <li>The COM is a mechanism that allows software components to interact.</li>
                <li>The model describes how to express an interface to which other objects can connect.</li>
                <li>COM is interesting to programmers because a great many resources you would like to use are exposed
                    via COM interfaces.</li>
                <li>The code inside a COM object runs as unmanaged code, having direct acces to the underlying system.
                </li>
                <li>While possible to run .NET applications in an unmanaged mode, .NET applications usually run inside a
                    managed environment, limiting the level of access that the applications have to the underlying
                    system.</li>
                <li>When a .NET application wants to interact with a COM object it has to perform the following:
                    <ol>
                        <li>Convert any parameters for the COM object into an appropriate format.</li>
                        <li>Switch to unmanaged eecution for the COM behaviour.</li>
                        <li>Invoke the COM behaviour.</li>
                        <li>Switch back to manged execution upon completion of the COM behaviour.</li>
                        <li>Convert any results of the COm request into the correct types of .NET objects.</li>
                    </ol>
                </li>
                <li>This is performed by the Primary Interop Assembly (PIA) component that is supplied along with the
                    COM object.</li>
                <li>The results returned by the PIA can be managed as dynamic objects, so tha thetype of the values can
                    be inferred rather than having to be specified directly.</li>
                <li>The use of dynamic types makes interaction with the Office application very easy.</li>
                <li>There is no need to cast the various elements that the program is interacting with, as they are
                    exposed by the interop as dynamic types, so conversion is performed automatically based on the
                    ienferred type of an assignment destination.</li>
            </ul>
            <h4>Embedding Type Information from Assemblies</h4>
            <ul>
                <li>You can create applications that interact with different versions of Microsoft Office by embedding
                    the Primary Interop Assembly in the application.</li>
                <li>This is achieved by setting the Embed Interop Types option of the assembly reference to True.</li>
                <li>This removes the need for any interop assemblies on the machine running the application.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-3">Skill 2.3: Enforcing Encapsulation</h2>
        <p>This section covers how to:</p>
        <ul>
            <li>Enforce encapsulation by using properties</li>
            <li>Enforce encapsulation by using accessors, including public, private, protected, and internal</li>
            <li>Enforce encapsulation by using explicit interface implementation</li>
        </ul>
        <div>
            <h3>Access Modifiers</h3>
            <h4>Public and Private Access</h4>
            <ul>
                <li>C# allows objects to encapsulate data and methods via marking them with access modifiers.</li>
                <li>The public access modifier can be accessed by code that is outside that type.</li>
                <li>A private member of a type can only be accessed by code running inside the type.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Properties</h3>
            <ul>
                <li>A propety in an object provides a way that a programmer can encapsulate data.</li>
                <li>You can get more control over the values assigned to properties by adding validation to the set block of the property.</li>
                <li>If you throw an exception when invalid you ensure that the user is always made aware of any error conditions.</li>
                <li>You can make the set behaviour ignore invalid values, or you could set a default value when an invalid one is provided.</li>
                <li>Read-only properties can be created by only providing a get behaviour.</li>
                <li>You can also make write-only properties in a similar manner, though this ability is less frequently used.</li>
                <li>Different access modifiers can also be applied to the get and set behaviours.</li>
                <li>The backing value of a property is a private data member of the same type as the property, with a name starting with an "_". </li>
                <li>Auto-implemented properties have their backing values automatically created by the C# compiler.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Accessors</h3>
            <ul>
                <li>As a general rule, data held within a type should be private and the methods to access the data inside should be public.</li>
                <li>Properties provide a way to manage access to individual values in a class.</li>
                <li>Making a data member of a class private will stop direct access to that data member.</li>
                <li>From a design perspective, making a class member private and only providing public methods that allow access to that member is a good first step to creating secure code.</li>
                <li>However, you may also have to make sure that you provide a secure workflow that manages access to the data.</li>
            </ul>
            <h4>Default Access Modifiers</h4>
            <ul>
                <li>If you don't specify an access modifer for a member of a type, it'll default to private.</li>
                <li>To make a member visible to the outside it must be done explicitly.</li>
                <li>You don't have to add the private modifier to private members, but it is strongly advised you do.</li>
            </ul>
            <h4>Protected Access</h4>
            <ul>
                <li>The protected access modifer makes a class member useable in any classes that extend the parent (base) class in which the member is declared.</li>
                <li>It isn't recommended you use the protected access modifier to control acess to highly important data members of a class.</li>
                <li>Doing so makes it easy for malicious programemrs to gain access to the protected member by extending the parent class.</li>
                <li>A good use is to limit access to helper methods that have no meaningful use outside of the class hierarchy.</li>
            </ul>
            <h4>Internal Access</h4>
            <ul>
                <li>The internal access modifier will make a meber of a type accessible within the assembly in which it is declared.</li>
                <li>An assembly can be regarded as the output of a C# project in Visual Studio.</li>
                <li>It can be iether an executable program or a library of classes.</li>
                <li>Internal access is most useful when you have a large number of cooperating classes that are being used to provide a particular library component.</li>
                <li>These classes may want to share memebers which should not be visible to programs that use the library.</li>
            </ul>
            <h4>Readonly Access</h4>
            <ul>
                <li>The readonly access modifier will make a member of a type read only.</li>
                <li>The value member can only be set at declaration or within the constructor of the class.</li>
            </ul>
        </div>
        <div>
            <h3>Enforce Encapsulation by Using Explicity Interface Implementation</h3>
            <ul>
                <li>When a class implements an interfface it contains methods with signatures that match the ones specified in the interface.</li>
                <li>You can use an explicit interface implementation to make methods implementing an interface only visible when the object is accessed via an interface reference.</li>
                <li>You might want an IPrintable interface that specifies methods used to print any object. This is a good idea because now a printer can be asked to print any item that is referred to by a reference of IPrintable type.</li>
                <li>In other words, any object that implemetns the method in IPrintable can be printed.</li>
                <li>Methods in the IPrintable interface only have meaning when being used by something trying to print an object. It's not sensible to call the printing methods in any other context than via the IPrintable reference.</li>
                <li>This can be achieved by making the implementation of the print methods explicit, thus adding the interface name to the delcaration of the method body.</li>
                <li>When you use an interface in a program you should ensure that all the implementations of any interface methods are explicit. This reduces the chances of the interface methods being used in an incorrect contect.</li>
            </ul>
            <h4>Resolving Duplicate Method Signatures by Using Explicit Implementation</h4>
            <ul>
                <li>When a class implements an interface it must contain an implementation of all methods that are defined in the interface.</li>
                <li>Sometimes a class may implement multiple interfaces, in which case it must contain all the methods defined in all the interfaces.</li>
                <li>Issues can occur if 2 interfaces contain a method with the same name.</li>
                <li>This can be resolved by specifying the interface name to the declaration of the method body.</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-4">Skill 2.4: Create and Implement a Class Hierarchy</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-5">Skill 2.5: Find, Execute and Create Types At Runtime</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-6">Skill 2.6: Managing the Object Lifecycle</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="skill-2-7">Skill 2.7: Manipulating Strings</h2>
        <ul>
            <li>NOTES</li>
            <li>NOTES</li>
            <li>NOTES</li>
        </ul>
        <p>This section covers how to:</p>
        <ul>
            <li>TOPIC</li>
            <li>TOPIC</li>
            <li>TOPIC</li>
        </ul>
        <div>
            <h3>HEADING</h3>
            <ul>
                <li>NOTES</li>
                <li>NOTES</li>
                <li>NOTES</li>
            </ul>
        </div>
    </div>
    <div>
        <h2 id="qa-2">Thought Experiments</h2>
        <div>
            <h3>HEADING</h3>
            <p>DESCRIPTION</p>
            <p>Here are some questions to consider:</p>
            <ol>
                <li class="question-answer">
                    <div class="question">QUESTION</div>
                    <div class="answer">
                        <ul>
                            <li>ANSWER</li>
                            <li>ANSWER</li>
                        </ul>
                    </div>
                </li>
            </ol>
        </div>
    </div>
</div>